import{PublicKey as e,MAX_SEED_LENGTH as t,ComputeBudgetProgram as n,SystemProgram as i,TransactionInstruction as o,SYSVAR_RENT_PUBKEY as s,SYSVAR_CLOCK_PUBKEY as a,AddressLookupTableAccount as r,sendAndConfirmRawTransaction as u,Transaction as c,TransactionMessage as m,VersionedTransaction as d}from"@solana/web3.js";import{Market as p,OpenOrders as l,Orderbook as g}from"@project-serum/serum";import{calculateAmpFactor as h,SWAP_PROGRAM_ID as S,StableSwap as k}from"@saberhq/stableswap-sdk";import{TokenSwapStable as f,Fraction as M,TokenSwapConstantProduct as A,toDecimal as y,Stable as w,ZERO_FRACTION as P,ZERO as T,TWO as v,ONE as b}from"@jup-ag/math";import B from"jsbi";import*as I from"fzstd";import{deserializeAccount as F,deserializeMint as L,TransactionError as D,parseErrorForTransaction as q,UNKNOWN_ERROR as x}from"@mercurial-finance/optimist";export{TransactionError}from"@mercurial-finance/optimist";import{AnchorProvider as E,Program as O,BorshAccountsCoder as V,BorshCoder as C,BN as R,utils as N}from"@project-serum/anchor";import{findProgramAddressSync as U,createProgramAddressSync as K}from"@project-serum/anchor/dist/cjs/utils/pubkey";import{u64 as X,Token as j,TOKEN_PROGRAM_ID as W,ASSOCIATED_TOKEN_PROGRAM_ID as Y,NATIVE_MINT as Q}from"@solana/spl-token";import{Layout as z,blob as H,struct as _,u8 as G,u32 as J,nu64 as $}from"@solana/buffer-layout";import{sha256 as Z}from"@noble/hashes/sha256";import ee,{BN as te}from"bn.js";import ne from"decimal.js";import{PDAUtil as ie,TickUtil as oe,TICK_ARRAY_SIZE as se,computeSwap as ae,TickMath as re,IDL as ue}from"@jup-ag/crema-sdk-v2";import{tickPosition as ce,TickMath as me,generateBitmapWord as de,TICK_SEED as pe,u32ToSeed as le,BITMAP_SEED as ge,u16ToSeed as he,nextInitializedBit as Se,buildTick as ke,Pool as fe,OBSERVATION_SEED as Me,IDL as Ae}from"@jup-ag/cykura-sdk";import{Token as ye,CurrencyAmount as we}from"@jup-ag/cykura-sdk-core";import{getSwappedAmountsAndPriceImpactFromRawValue as Pe,getDeltafiDexV2 as Te}from"@jup-ag/deltafi-sdk";import{parsePriceData as ve}from"@pythnetwork/client";import{BigNumber as be}from"bignumber.js";import{PAIR_LAYOUT as Be,SyncSwap as Ie,SSL as Fe,wasm as Le,loadWasm as De}from"@jup-ag/goosefx-ssl-sdk";import{calculatePriceSqrt as qe,MIN_TICK as xe,MAX_TICK as Ee,toDecimal as Oe,simulateSwap as Ve,findClosestTicks as Ce,TICK_CROSSES_PER_IX as Re,IDL as Ne,DENOMINATOR as Ue}from"@jup-ag/invariant";import{LIFINITY_AMM_LAYOUT as Ke,getParsedData as Xe,TradeDirection as je,getCurveAmount as We}from"@jup-ag/lifinity-sdk";import{IDL as Ye,getParsedData as Qe,TradeDirection as ze,getCurveAmount as He}from"@jup-ag/lifinity-sdk-v2";import{AmmIdl as _e,PROGRAM_ID as Ge,VaultIdl as Je,calculateSwapQuote as $e}from"@mercurial-finance/dynamic-amm-sdk";import{SwapUtils as Ze,swapQuoteWithParams as et,ParsableWhirlpool as tt,ParsableTickArray as nt}from"@jup-ag/whirlpools-sdk";import{dexCoder as it,QuoteCalculator as ot}from"@jup-ag/dradex-sdk";import{OrderBook as st}from"@jup-ag/dradex-idl";import{IDL as at,Amm as rt}from"@jup-ag/raydium-clmm-sdk";import ut from"cross-fetch";import{bs58 as ct}from"@project-serum/anchor/dist/cjs/utils/bytes";const mt={Raydium:{Openbook:!0}},dt={Openbook:!0,Cykura:!0,Meteora:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0,"Marco Polo":!0},Crema:{Balansol:!0,Raydium:!0,Lifinity:!0,"Lifinity V2":!0},"Marco Polo":{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0},Dradex:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Raydium:!0},Balansol:{Raydium:!0},Lifinity:{Raydium:!0},"Lifinity V2":{Raydium:!0}},pt={Raydium:!0,GooseFX:!0,Meteora:!0,Serum:!0,Openbook:!0,Dradex:!0,Crema:!0,Lifinity:!0,"Lifinity V2":!0},lt=(e,t,n)=>{const i=e[t];if(i){if(!0===i||!0===i["*"])return!0;if(n)return!0===i[n]}return!1},gt=(e,t,n)=>lt(e,t,n)||!!n&&lt(e,n,t);function ht(e,t){return Array.apply(0,new Array(Math.ceil(e.length/t))).map(((n,i)=>e.slice(i*t,(i+1)*t)))}async function St(t,n,i=1e3,o=100){return(await Promise.all(ht(n,i).map((async n=>{const i=ht(n,o).map((e=>({methodName:"getMultipleAccounts",args:t._buildArgs([e],t.commitment,"base64+zstd")})));return t._rpcBatchRequest(i).then((t=>t.reduce(((t,n)=>(n.result.value.forEach((n=>{if(n){const i=n;i.data=Buffer.from(I.decompress(Buffer.from(n.data[0],"base64"))),i.owner=new e(n.owner),t.push(i)}else t.push(null)})),t)),[]))).catch((e=>n.map((()=>null))))})))).flat()}var kt;!function(e){e.ExactIn="ExactIn",e.ExactOut="ExactOut"}(kt||(kt={}));const ft=(e,t)=>t.map((t=>{const n=e.get(t.toString());if(!n)throw new Error(`Account info ${t.toBase58()} missing`);return n})),Mt=e=>e.map((e=>{const t=F(e.data);if(!t)throw new Error("Invalid token account");return t})).map((e=>B.BigInt(e.amount))),At=async(e,t)=>{const n=e.map((e=>e.getAccountsForUpdate().map((e=>e.toBase58())))).flat(),i=new Map;(await St(t,n)).forEach(((e,t)=>{e&&i.set(n[t],e)}));for(let t of e)t.update(i)},yt={version:"0.1.0",name:"jupiter",instructions:[{name:"route",accounts:[{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"destinationTokenAccount",isMut:!1,isSigner:!1}],args:[{name:"swapLeg",type:{defined:"SwapLeg"}},{name:"inAmount",type:"u64"},{name:"quotedOutAmount",type:"u64"},{name:"slippageBps",type:"u16"},{name:"platformFeeBps",type:"u8"}]},{name:"whirlpoolSwapExactOutput",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[{name:"outAmount",type:"u64"},{name:"inAmountWithSlippage",type:{defined:"AmountWithSlippage"}},{name:"aToB",type:"bool"},{name:"platformFeeBps",type:"u8"}]},{name:"createOpenOrders",accounts:[{name:"openOrders",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"market",isMut:!1,isSigner:!1}],args:[]},{name:"mercurialSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"poolAuthority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceTokenAccount",isMut:!0,isSigner:!1},{name:"destinationTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"cykuraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"signer",isMut:!1,isSigner:!0},{name:"factoryState",isMut:!1,isSigner:!1},{name:"poolState",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"inputVault",isMut:!0,isSigner:!1},{name:"outputVault",isMut:!0,isSigner:!1},{name:"lastObservationState",isMut:!0,isSigner:!1},{name:"coreProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"serumSwap",accounts:[{name:"market",accounts:[{name:"market",isMut:!0,isSigner:!1},{name:"openOrders",isMut:!0,isSigner:!1},{name:"requestQueue",isMut:!0,isSigner:!1},{name:"eventQueue",isMut:!0,isSigner:!1},{name:"bids",isMut:!0,isSigner:!1},{name:"asks",isMut:!0,isSigner:!1},{name:"coinVault",isMut:!0,isSigner:!1},{name:"pcVault",isMut:!0,isSigner:!1},{name:"vaultSigner",isMut:!1,isSigner:!1}]},{name:"authority",isMut:!1,isSigner:!0},{name:"orderPayerTokenAccount",isMut:!0,isSigner:!1},{name:"coinWallet",isMut:!0,isSigner:!1},{name:"pcWallet",isMut:!0,isSigner:!1},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"saberSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapAuthority",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"feesTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"saberAddDecimals",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"tokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"senchaSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!0,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"inputFeesAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"outputFeesAccount",isMut:!0,isSigner:!1}],args:[]},{name:"stepSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"cropperSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"raydiumSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[]},{name:"cremaSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"clmmConfig",isMut:!1,isSigner:!1},{name:"clmmpool",isMut:!0,isSigner:!1},{name:"tokenA",isMut:!1,isSigner:!1},{name:"tokenB",isMut:!1,isSigner:!1},{name:"accountA",isMut:!0,isSigner:!1},{name:"accountB",isMut:!0,isSigner:!1},{name:"tokenAVault",isMut:!0,isSigner:!1},{name:"tokenBVault",isMut:!0,isSigner:!1},{name:"tickArrayMap",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"partner",isMut:!1,isSigner:!1},{name:"partnerAtaA",isMut:!0,isSigner:!1},{name:"partnerAtaB",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"lifinitySwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"amm",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceInfo",isMut:!0,isSigner:!1},{name:"destinationInfo",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"feeAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"pythAccount",isMut:!1,isSigner:!1},{name:"pythPcAccount",isMut:!1,isSigner:!1},{name:"configAccount",isMut:!0,isSigner:!1}],args:[]},{name:"marinadeDeposit",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1},{name:"tempWsolTokenAccount",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!0,isSigner:!0},{name:"wsolMint",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"marinadeUnstake",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"aldrinSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"aldrinV2Swap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"curve",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"whirlpoolSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[]},{name:"invariantSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tickmap",isMut:!0,isSigner:!1},{name:"accountX",isMut:!0,isSigner:!1},{name:"accountY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"meteoraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"userSourceToken",isMut:!0,isSigner:!1},{name:"userDestinationToken",isMut:!0,isSigner:!1},{name:"aVault",isMut:!0,isSigner:!1},{name:"bVault",isMut:!0,isSigner:!1},{name:"aTokenVault",isMut:!0,isSigner:!1},{name:"bTokenVault",isMut:!0,isSigner:!1},{name:"aVaultLpMint",isMut:!0,isSigner:!1},{name:"bVaultLpMint",isMut:!0,isSigner:!1},{name:"aVaultLp",isMut:!0,isSigner:!1},{name:"bVaultLp",isMut:!0,isSigner:!1},{name:"adminTokenFee",isMut:!0,isSigner:!1},{name:"user",isMut:!1,isSigner:!0},{name:"vaultProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"goosefxSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"controller",isMut:!1,isSigner:!1},{name:"pair",isMut:!0,isSigner:!1},{name:"sslIn",isMut:!0,isSigner:!1},{name:"sslOut",isMut:!0,isSigner:!1},{name:"liabilityVaultIn",isMut:!0,isSigner:!1},{name:"swappedLiabilityVaultIn",isMut:!0,isSigner:!1},{name:"liabilityVaultOut",isMut:!0,isSigner:!1},{name:"swappedLiabilityVaultOut",isMut:!0,isSigner:!1},{name:"userInAta",isMut:!0,isSigner:!1},{name:"userOutAta",isMut:!0,isSigner:!1},{name:"feeCollectorAta",isMut:!0,isSigner:!1},{name:"userWallet",isMut:!1,isSigner:!0},{name:"feeCollector",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"deltafiSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"marketConfig",isMut:!1,isSigner:!1},{name:"swapInfo",isMut:!0,isSigner:!1},{name:"userSourceToken",isMut:!0,isSigner:!1},{name:"userDestinationToken",isMut:!0,isSigner:!1},{name:"swapSourceToken",isMut:!0,isSigner:!1},{name:"swapDestinationToken",isMut:!0,isSigner:!1},{name:"deltafiUser",isMut:!0,isSigner:!1},{name:"adminDestinationToken",isMut:!0,isSigner:!1},{name:"pythPriceBase",isMut:!1,isSigner:!1},{name:"pythPriceQuote",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"balansolSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!0,isSigner:!0},{name:"pool",isMut:!0,isSigner:!1},{name:"taxMan",isMut:!0,isSigner:!1},{name:"bidMint",isMut:!1,isSigner:!1},{name:"treasurer",isMut:!1,isSigner:!1},{name:"srcTreasury",isMut:!0,isSigner:!1},{name:"srcAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"askMint",isMut:!1,isSigner:!1},{name:"dstTreasury",isMut:!0,isSigner:!1},{name:"dstAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"dstTokenAccountTaxman",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"marcoPoloSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"swapperXAccount",isMut:!0,isSigner:!1},{name:"swapperYAccount",isMut:!0,isSigner:!1},{name:"swapper",isMut:!0,isSigner:!0},{name:"referrerXAccount",isMut:!0,isSigner:!1},{name:"referrerYAccount",isMut:!0,isSigner:!1},{name:"referrer",isMut:!0,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"dradexSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pair",isMut:!0,isSigner:!1},{name:"market",isMut:!0,isSigner:!1},{name:"eventQueue",isMut:!0,isSigner:!1},{name:"dexUser",isMut:!1,isSigner:!1},{name:"marketUser",isMut:!0,isSigner:!1},{name:"bids",isMut:!0,isSigner:!1},{name:"asks",isMut:!0,isSigner:!1},{name:"t0Vault",isMut:!0,isSigner:!1},{name:"t1Vault",isMut:!0,isSigner:!1},{name:"t0User",isMut:!0,isSigner:!1},{name:"t1User",isMut:!0,isSigner:!1},{name:"master",isMut:!1,isSigner:!1},{name:"signer",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"logger",isMut:!1,isSigner:!1}],args:[]},{name:"lifinityV2Swap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"amm",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceInfo",isMut:!0,isSigner:!1},{name:"destinationInfo",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"feeAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"oracleMainAccount",isMut:!1,isSigner:!1},{name:"oracleSubAccount",isMut:!1,isSigner:!1},{name:"oraclePcAccount",isMut:!1,isSigner:!1}],args:[]},{name:"raydiumClmmSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"payer",isMut:!1,isSigner:!0},{name:"ammConfig",isMut:!1,isSigner:!1},{name:"poolState",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"inputVault",isMut:!0,isSigner:!1},{name:"outputVault",isMut:!0,isSigner:!1},{name:"observationState",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tickArray",isMut:!0,isSigner:!1}],args:[]}],types:[{name:"AmountWithSlippage",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"slippageBps",type:"u16"}]}},{name:"SplitLegDeeper",type:{kind:"struct",fields:[{name:"percent",type:"u8"},{name:"swapLeg",type:{defined:"SwapLegSwap"}}]}},{name:"SplitLeg",type:{kind:"struct",fields:[{name:"percent",type:"u8"},{name:"swapLeg",type:{defined:"SwapLegDeeper"}}]}},{name:"SwapInstrution",type:{kind:"enum",variants:[{name:"Swap",fields:[{defined:"Swap"}]}]}},{name:"Side",type:{kind:"enum",variants:[{name:"Bid"},{name:"Ask"}]}},{name:"SwapLegSwap",type:{kind:"enum",variants:[{name:"PlaceholderOne"},{name:"PlaceholderTwo"},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"SwapLegDeeper",type:{kind:"enum",variants:[{name:"Chain",fields:[{name:"swap_legs",type:{vec:{defined:"SwapLegSwap"}}}]},{name:"Split",fields:[{name:"split_legs",type:{vec:{defined:"SplitLegDeeper"}}}]},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"SwapLeg",type:{kind:"enum",variants:[{name:"Chain",fields:[{name:"swap_legs",type:{vec:{defined:"SwapLegDeeper"}}}]},{name:"Split",fields:[{name:"split_legs",type:{vec:{defined:"SplitLeg"}}}]},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"Swap",type:{kind:"enum",variants:[{name:"Saber"},{name:"SaberAddDecimalsDeposit"},{name:"SaberAddDecimalsWithdraw"},{name:"TokenSwap"},{name:"Sencha"},{name:"Step"},{name:"Cropper"},{name:"Raydium"},{name:"Crema",fields:[{name:"a_to_b",type:"bool"}]},{name:"Lifinity"},{name:"Mercurial"},{name:"Cykura"},{name:"Serum",fields:[{name:"side",type:{defined:"Side"}}]},{name:"MarinadeDeposit"},{name:"MarinadeUnstake"},{name:"Aldrin",fields:[{name:"side",type:{defined:"Side"}}]},{name:"AldrinV2",fields:[{name:"side",type:{defined:"Side"}}]},{name:"Whirlpool",fields:[{name:"a_to_b",type:"bool"}]},{name:"Invariant",fields:[{name:"x_to_y",type:"bool"}]},{name:"Meteora"},{name:"GooseFX"},{name:"DeltaFi",fields:[{name:"stable",type:"bool"}]},{name:"Balansol"},{name:"MarcoPolo",fields:[{name:"x_to_y",type:"bool"}]},{name:"Dradex",fields:[{name:"side",type:{defined:"Side"}}]},{name:"LifinityV2"},{name:"RaydiumClmm"},{name:"Openbook",fields:[{name:"side",type:{defined:"Side"}}]}]}},{name:"SwapAction",type:{kind:"enum",variants:[{name:"SetupSplit",fields:[{name:"percents",type:"bytes"}]},{name:"NextSplitLeg"},{name:"MergeSplit"},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}}],events:[{name:"Swap",fields:[{name:"amm",type:"publicKey",index:!1},{name:"inputMint",type:"publicKey",index:!1},{name:"inputAmount",type:"u64",index:!1},{name:"outputMint",type:"publicKey",index:!1},{name:"outputAmount",type:"u64",index:!1}]},{name:"Fee",fields:[{name:"account",type:"publicKey",index:!1},{name:"mint",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1}]}],errors:[{code:6e3,name:"EmptyRoute",msg:"Empty route"},{code:6001,name:"SlippageToleranceExceeded",msg:"Slippage tolerance exceeded"},{code:6002,name:"InvalidCalculation",msg:"Invalid calculation"},{code:6003,name:"MissingPlatformFeeAccount",msg:"Missing platform fee account"},{code:6004,name:"InvalidSlippage",msg:"Invalid slippage"},{code:6005,name:"NotEnoughPercent",msg:"Not enough percent to 100"},{code:6006,name:"InAmountsStackIsEmpty",msg:"In amounts stack is empty"},{code:6007,name:"OutAmountsStackIsEmpty",msg:"Out amounts stack is empty"},{code:6008,name:"NotEnoughAccountKeys",msg:"Not Enough Account keys"}]},wt=new e("So11111111111111111111111111111111111111112"),Pt=new e("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Tt=new e("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY"),vt={devnet:"https://jupiter-devnet.zhen8558.workers.dev/markets?v=3","mainnet-beta":"https://cache.jup.ag/markets?v=3",testnet:"https://api.jup.ag/api/markets/cache/devnet"},bt="https://cache.jup.ag/indexed-route-maps-v2",Bt={devnet:"https://api.jup.ag/api/tokens/devnet",testnet:"https://api.jup.ag/api/markets/devnet","mainnet-beta":"https://cache.jup.ag/tokens"},It=5e3,Ft=new e("BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9"),Lt=new e("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Dt=new e("AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6"),qt=new e("CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4"),xt=new e("DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB"),Et=new e("CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh"),Ot=new e("SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ"),Vt=new e("EewxydAPCCVuNEyrVN68PuSYdQ7wKn27V9Gjeoi8dy3S"),Ct=new e("CLMM9tUoggJu2wagPkkqs9eFG4BWhVBZWkP1qv3Sp7tR"),Rt=new e("FxYoB1VAx8TfLCwvmworJy16VH89v992qznUvBX5aR8K"),Nt=new e("BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9"),Ut=new e("MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky"),Kt=new e("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"),Xt=new e("HyaB3W9q6XdA5xwpU4XnSZV94htfmbmqJXZcEbRaJutt"),jt=new e("8NsPwRFYqob3FzYvHYTjFK6WVFJADFN8Hn7yNQKcVNW1"),Wt=new e("J4uBbeoWpZE8fH58PM1Fp9n9K6f1aThyeVCyRdJbaXqt"),Yt=new e("cysPXAjehMpVKUapzbMCCnpFxUFFryEWEaLgnb9NrR8"),Qt=new e("DBsMwKfeoUHhxMi9x6wd2AsT12UwUCssjNbUzu1aKgqj"),zt=new e("MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD"),Ht=new e("Dooar9JkhdZ7J3LHN3A7YCuoGRUggXhQaG4kijfLGU2j"),_t=new e("DjVE6JNiYqPL2QXyCUUh8rNjHrbz9hXHNYt99MQ59qw1"),Gt=new e("9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP"),Jt=new e("SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1"),$t=new e("PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP"),Zt=new e("SSwapUtytfBdBn1b9NUGG6foMVPtcWgpRU32HToDUZr"),en=new e("Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"),tn=new e("24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi"),nn=new e("GNExJhNUhc9LN2DauuQAUJnXoy6DJ6zey3t9kT9A2PF3"),on=new e("ziSPuDShwunW4xNrCfTnSHTPVT6FZDREtdofpf1BJwe"),sn=new e("7WduLbRfYhTJktjLw5FDEyrqoEv61aTTCuGAetgLjzN5"),an=new e("8CxKnuJeoeQXFwiG6XiGY2akBjvJA5k3bE52BfnuEmNQ"),rn=new e("D3BBjqUdCYuP18fNvvMbPAZ8DpcRi4io2EsYHQawJDag"),un=new e("dp2waEWSBy5yKmq65ergoU3G6qRLmqa6K7We4rZSKph"),cn=new e("1gE3LGQze8DQ3KD2C4ZUCmRX5g4njhY5yLfYmnmcvJR"),mn=new e("76ygWLcvJLR6nSzRUpiQqqtX4Pabkq4vpaTxwr3mDcXA"),dn=new e("2wT8Yq49kHgDzXuPxZSaeLaH1qbmGXtEyPy64bL7aD3c"),pn=new e("571oqNkJauZ2tccLwf8CUB56hpLPZkop9X1Px4DE9rnQ"),ln=new e("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),gn=new e("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),hn=new e("9tKE7Mbmj4mxDjWatikzGAtkoWosiiZX9y6J4Hfm2R8H"),Sn=new e("BE5YRQ6N6LCw7UL3JwzVp317EWa4mzJY6JKDaudcXu7A"),kn=new e("JM78XNzeQRmZXDAP4DSq88ZdErbuSXSLE6fkRsVDKSu"),fn=["StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT","DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz"],Mn=Object.freeze({AlreadyInUse:{code:1,name:"AlreadyInUsed",msg:"Account already In Used"},InsufficientSOL:{code:1,name:"InsufficientSOL",msg:"Insufficient SOL"},TransactionNotConfirmed:{code:7e3,name:"TransactionNotConfirmed",msg:"Transaction was not confirmed"},BalancesNotExtractedProperly:{code:7001,name:"BalancesNotExtractedProperly",msg:"Balances cannot be extracted properly"},...yt.errors.reduce(((e,t)=>({...e,[t.name]:t})),{})}),An="development"===process.env.NODE_ENV,yn="test"===process.env.NODE_ENV,wn="production"===process.env.NODE_ENV,Pn=100,Tn=new E(null,null,{skipPreflight:!1});class vn extends z{constructor(e){const t=H(32);super(t.span,e),this.layout=void 0,this.layout=t}getSpan(e,t){return this.layout.getSpan(e,t)}decode(t,n){return new e(this.layout.decode(t,n))}encode(e,t,n){return this.layout.encode(e.toBuffer(),t,n)}}const bn=e=>new vn(e);class Bn extends z{constructor(e=8,t){const n=H(e);super(n.span,t),this.layout=void 0,this.layout=n}getSpan(e,t){return this.layout.getSpan(e,t)}decode(e,t){return new X(this.layout.decode(e,t),10,"le")}encode(e,t,n){return this.layout.encode(e.toArrayLike(Buffer,"le",this.layout.span),t,n)}}const In=e=>new Bn(8,e),Fn=e=>new Bn(16,e);function Ln(n,i){let o=Buffer.alloc(0);n.forEach((function(e){if(e.length>t)throw new TypeError("Max seed length exceeded");var n;o=Buffer.concat([o,(n=e,Buffer.isBuffer(n)?n:n instanceof Uint8Array?Buffer.from(n.buffer,n.byteOffset,n.byteLength):Buffer.from(n))])})),o=Buffer.concat([o,i.toBuffer(),Buffer.from("ProgramDerivedAddress")]);let s=Z(new Uint8Array(o)),a=new ee(s,16).toArray(void 0,32);return new e(a)}const Dn=_([G("version"),G("isInitialized"),G("nonce"),bn("ammId"),bn("serumProgramId"),bn("serumMarket"),bn("tokenProgramId"),bn("tokenAAccount"),bn("tokenBAccount"),bn("poolMint"),bn("mintA"),bn("mintB")]),qn=_([G("isInitialized"),bn("stateOwner"),bn("feeOwner"),In("initialSupply"),In("returnFeeNumerator"),In("fixedFeeNumerator"),In("feeDenominator"),G("curveType"),H(32,"curveParameters")]),xn=new e("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),En=(e,t)=>{const n=t.owner,i=Dn.decode(t.data);return{programId:n,authority:Ln([e.toBuffer(),Buffer.from([i.nonce])],n),version:i.version,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:i.ammId,serumProgramId:i.serumProgramId,tokenProgramId:i.tokenProgramId,tokenAAccount:i.tokenAAccount,tokenBAccount:i.tokenBAccount,serumMarket:i.serumMarket,poolMint:i.poolMint,mintA:i.mintA,mintB:i.mintB}},On={Bid:{bid:{}},Ask:{ask:{}}},Vn=e=>({serum:{side:e}}),Cn=e=>({crema:{aToB:e}}),Rn=e=>({aldrin:{side:e}}),Nn=e=>({aldrinV2:{side:e}}),Un=e=>({whirlpool:{aToB:e}}),Kn=e=>({invariant:{xToY:e}}),Xn=e=>({dradex:{side:e}}),jn=e=>({openbook:{side:e}}),Wn=e=>({marcoPolo:{xToY:e}}),Yn=e=>({chain:{swapLegs:e}}),Qn=e=>({split:{splitLegs:e}}),zn=e=>({swap:{swap:e}}),Hn=(e,t)=>({percent:e,swapLeg:t}),_n=()=>({setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]}),Gn=e=>n.setComputeUnitLimit({units:Math.min(e,14e5)});async function Jn({connection:e,amount:t,owner:{publicKey:n}}){const o={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},s=Zn({walletAddress:n,tokenMintAddress:wt});return null===await e.getAccountInfo(s)&&o.setupInstructions.push($n(n,s,n,wt)),o.setupInstructions.push(i.transfer({fromPubkey:n,toPubkey:s,lamports:B.toNumber(t)})),o.setupInstructions.push(j.createSyncNativeInstruction(W,s)),o.cleanupInstructions=[j.createCloseAccountInstruction(W,s,n,n,[])],{address:s,...o}}function $n(e,t,n,s,a=W,r=Y){return new o({keys:[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i.programId,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}],programId:r,data:Buffer.alloc(0)})}const Zn=({walletAddress:t,tokenMintAddress:n})=>e.findProgramAddressSync([t.toBuffer(),W.toBuffer(),n.toBuffer()],Y)[0],ei=new e("JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB"),ti=new O(yt,ei,{}),ni={pubkey:ei,isSigner:!1,isWritable:!1};function ii(e,t,n,i,o,s,a,r){return ti.instruction.route(n,o,s,a,r,{accounts:{tokenProgram:W,userTransferAuthority:e,destinationTokenAccount:t},remainingAccounts:i})}function oi(e,t,n,i){return{swapProgram:Ut,swapState:e.ammId,tokenProgram:W,poolAuthority:e.authority,userTransferAuthority:i,sourceTokenAccount:t,destinationTokenAccount:n}}const[si]=U([new Uint8Array(Buffer.from("amm authority".replace(" "," "),"utf-8"))],Lt);function ai(e,t,n,i){if(!e.serumMarketKeys)throw new Error("RaydiumAmm is missing serumMarketKeys");return{swapProgram:Lt,tokenProgram:W,ammId:e.ammId,ammAuthority:si,ammOpenOrders:e.ammOpenOrders,poolCoinTokenAccount:e.poolCoinTokenAccount,poolPcTokenAccount:e.poolPcTokenAccount,serumProgramId:e.serumProgramId,serumMarket:e.serumMarket,serumBids:e.serumMarketKeys.serumBids,serumAsks:e.serumMarketKeys.serumAsks,serumEventQueue:e.serumMarketKeys.serumEventQueue,serumCoinVaultAccount:e.serumMarketKeys.serumCoinVaultAccount,serumPcVaultAccount:e.serumMarketKeys.serumPcVaultAccount,serumVaultSigner:e.serumMarketKeys.serumVaultSigner,userSourceTokenAccount:t,userDestinationTokenAccount:n,userSourceOwner:i}}function ri(e,t,n,i,o,a){const r=K([e.address.toBuffer(),e.decoded.vaultSignerNonce.toArrayLike(Buffer,"le",8)],e.programId);return{market:{market:e.address,openOrders:t,requestQueue:e.decoded.requestQueue,eventQueue:e.decoded.eventQueue,bids:e.bidsAddress,asks:e.asksAddress,coinVault:e.decoded.baseVault,pcVault:e.decoded.quoteVault,vaultSigner:r},authority:a,orderPayerTokenAccount:n,coinWallet:i,pcWallet:o,dexProgram:e.programId,tokenProgram:W,rent:s}}function ui(e,t,n,i,o){const s=t.equals(e.state.tokenA.mint)?e.state.tokenB.adminFeeAccount:e.state.tokenA.adminFeeAccount,[a,r]=t.equals(e.state.tokenA.mint)?[e.state.tokenA.reserve,e.state.tokenB.reserve]:[e.state.tokenB.reserve,e.state.tokenA.reserve];return{swapProgram:e.config.swapProgramID,tokenProgram:W,swap:e.config.swapAccount,swapAuthority:e.config.authority,userAuthority:o,inputUserAccount:n,inputTokenAccount:a,outputUserAccount:i,outputTokenAccount:r,feesTokenAccount:s}}function ci(e,t){const n=[];return n.push(e?{pubkey:e,isSigner:!1,isWritable:!0}:t?{pubkey:t,isSigner:!1,isWritable:!0}:ni),n}const mi=new X(0);class di{constructor(e,t){this.numerator=void 0,this.denominator=void 0,this.toString=()=>`${this.numerator.toString()}/${this.denominator.toString()}`,this.numerator=e,this.denominator=t}static fromDecimal(e){return di.fromFraction(e.toDecimalPlaces(1).mul(10).toNumber(),1e3)}static fromFraction(e,t){const n="number"==typeof e?new X(e.toString()):e,i="number"==typeof t?new X(t.toString()):t;return new di(n,i)}toDecimal(){return this.denominator.eq(mi)?new ne(0):new ne(this.numerator.toString()).div(new ne(this.denominator.toString()))}add(e){const t=this.denominator.gcd(e.denominator),n=this.denominator.div(t).mul(e.denominator),i=n.div(this.denominator),o=n.div(e.denominator),s=this.numerator.mul(i),a=e.numerator.mul(o),r=s.add(a);return new di(new X(r.toString()),new X(n.toString()))}}const pi=_([In("tradeFeeNumerator"),In("tradeFeeDenominator"),In("ownerTradeFeeNumerator"),In("ownerTradeFeeDenominator"),In("ownerWithdrawFeeNumerator"),In("ownerWithdrawFeeDenominator")],"fees"),li=[H(8,"padding"),bn("lpTokenFreezeVault"),bn("poolMint"),bn("baseTokenVault"),bn("baseTokenMint"),bn("quoteTokenVault"),bn("quoteTokenMint"),bn("poolSigner"),G("poolSignerNonce"),bn("authority"),bn("initializerAccount"),bn("feeBaseAccount"),bn("feeQuoteAccount"),bn("feePoolTokenAccount"),pi],gi=_(li),hi=_([...li,G("curveType"),bn("curve")]),Si=_([H(8,"padding"),In("amp")]);function ki(e,t){const n=!!t.owner.equals(qt),i=(n?hi:gi).decode(t.data),o="curveType"in i?{curveType:i.curveType,curve:i.curve}:{};return{isV2:n,address:e,poolMint:i.poolMint,baseTokenVault:i.baseTokenVault,baseTokenMint:i.baseTokenMint,quoteTokenVault:i.quoteTokenVault,quoteTokenMint:i.quoteTokenMint,poolSigner:i.poolSigner,feeBaseAccount:i.feeBaseAccount,feeQuoteAccount:i.feeQuoteAccount,feePoolTokenAccount:i.feePoolTokenAccount,fees:{traderFee:di.fromFraction(i.fees.tradeFeeNumerator,i.fees.tradeFeeDenominator),ownerFee:di.fromFraction(i.fees.ownerTradeFeeNumerator,i.fees.ownerTradeFeeDenominator)},...o}}class fi{constructor(e,t,n){if(this.params=void 0,this.id=void 0,this.label="Aldrin",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.params=n,this.poolState=ki(e,t),this.id=e.toBase58(),1===this.poolState.curveType){const{amp:e}=this.params;if(!e)throw new Error("Amp is required for a stable curve");this.calculator=new f(B.BigInt(e),new M(B.BigInt(this.poolState.fees.traderFee.numerator.toString()),B.BigInt(this.poolState.fees.traderFee.denominator.toString())),new M(B.BigInt(this.poolState.fees.ownerFee.numerator.toString()),B.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}else this.calculator=new A(new M(B.BigInt(this.poolState.fees.traderFee.numerator.toString()),B.BigInt(this.poolState.fees.traderFee.denominator.toString())),new M(B.BigInt(this.poolState.fees.ownerFee.numerator.toString()),B.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}static decodeStableCurveAmp(e){const{amp:t}=Si.decode(e.data);return 2*t.toNumber()}getAccountsForUpdate(){return[this.poolState.quoteTokenVault,this.poolState.baseTokenVault]}update(e){const t=ft(e,this.getAccountsForUpdate());this.tokenReserveAmounts=Mt(t)}getQuote({sourceMint:e,amount:t}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");let n=new ne(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new ne(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));const i=this.poolState.baseTokenMint.equals(e)?0:1;let o=this.calculator.exchange(this.tokenReserveAmounts,t,i);return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:n.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){if(this.poolState.isV2){if(!this.poolState.curve)throw new Error("Unable to fetch curve account.");return function({poolState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,curve:o,userTransferAuthority:s}){const[a,r,u]=t.equals(e.baseTokenMint)?[On.Ask,n,i]:[On.Bid,i,n];return[zn(Nn(a)),ti.instruction.aldrinV2Swap({accounts:{swapProgram:qt,pool:e.address,poolSigner:e.poolSigner,poolMint:e.poolMint,baseTokenVault:e.baseTokenVault,quoteTokenVault:e.quoteTokenVault,feePoolTokenAccount:e.feePoolTokenAccount,walletAuthority:s,userBaseTokenAccount:r,userQuoteTokenAccount:u,curve:o,tokenProgram:W}}).keys]}({poolState:this.poolState,curve:this.poolState.curve,...e})}return function({poolState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,a,r]=t.equals(e.baseTokenMint)?[On.Ask,n,i]:[On.Bid,i,n];return[zn(Rn(s)),ti.instruction.aldrinSwap({accounts:{swapProgram:Dt,pool:e.address,poolSigner:e.poolSigner,poolMint:e.poolMint,baseTokenVault:e.baseTokenVault,quoteTokenVault:e.quoteTokenVault,feePoolTokenAccount:e.feePoolTokenAccount,walletAuthority:o,userBaseTokenAccount:a,userQuoteTokenAccount:r,tokenProgram:W}}).keys]}({poolState:this.poolState,...e})}get reserveTokenMints(){return[this.poolState.quoteTokenMint,this.poolState.baseTokenMint]}}fi.accountInfoToAldrinPoolState=ki;const Mi={version:"0.1.0",name:"balancer_amm",instructions:[{name:"swap",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"pool",isMut:!0,isSigner:!1},{name:"taxMan",isMut:!0,isSigner:!1},{name:"bidMint",isMut:!1,isSigner:!1},{name:"treasurer",isMut:!1,isSigner:!1},{name:"srcTreasury",isMut:!0,isSigner:!1},{name:"srcAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"askMint",isMut:!1,isSigner:!1},{name:"dstTreasury",isMut:!0,isSigner:!1},{name:"dstAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"dstTokenAccountTaxman",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"bidAmount",type:"u64"},{name:"limit",type:"u64"}],returns:"u64"}],accounts:[{name:"pool",type:{kind:"struct",fields:[{name:"authority",type:"publicKey"},{name:"fee",type:"u64"},{name:"taxFee",type:"u64"},{name:"state",type:{defined:"PoolState"}},{name:"mintLpt",type:"publicKey"},{name:"taxMan",type:"publicKey"},{name:"mints",type:{vec:"publicKey"}},{name:"actions",type:{vec:{defined:"MintActionState"}}},{name:"treasuries",type:{vec:"publicKey"}},{name:"reserves",type:{vec:"u64"}},{name:"weights",type:{vec:"u64"}}]}}],types:[{name:"PoolState",type:{kind:"enum",variants:[{name:"Uninitialized"},{name:"Initialized"},{name:"Frozen"},{name:"Deleted"}]}},{name:"MintActionState",type:{kind:"enum",variants:[{name:"Active"},{name:"BidOnly"},{name:"AskOnly"},{name:"Paused"}]}}],errors:[]},Ai=(e,t)=>{const n=e.map((e=>e.toNumber()/1e9));return t.toNumber()/1e9/n.reduce(((e,t)=>e+t),0)},yi=(e,t)=>{const{balanceIn:n,balanceOut:i,weightIn:o,weightOut:s,swapFee:a}=t,r=Number(n.toString()),u=Number(i.toString()),c=o,m=s,d=Number(a.toString())/1e9;return-r*m/(u*(-1+d)*(r/(e+r-e*d))**((c+m)/m)*c)},wi=new V(Mi);class Pi{constructor(e,t){this.address=void 0,this.label="Balansol",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolData=void 0,this.address=e,this.id=e.toBase58(),this.poolData=wi.decode("pool",t.data)}getAccountsForUpdate(){return[new e(this.id)]}update(e){let[t]=ft(e,this.getAccountsForUpdate());const n=wi.decode("pool",t.data);this.poolData=n}getQuote({sourceMint:e,destinationMint:t,amount:n}){var i,o;if(!this.poolData)throw new Error(`Invalid pool data ${this.address.toBase58()}`);if(!this.poolData.state.initialized)throw new Error(`Pool is not initialized ${this.address.toBase58()}`);const s=this.poolData.mints.map((e=>e.toBase58())),a=s.indexOf(e.toBase58()),r=s.indexOf(t.toBase58());if(null===(i=this.poolData.actions[a])||void 0===i||!i.active)throw new Error(`Invalid bid mint state ${this.address.toBase58()}`);if(null===(o=this.poolData.actions[r])||void 0===o||!o.active)throw new Error(`Invalid ask mint state ${this.address.toBase58()}`);const u=Ai(this.poolData.weights,this.poolData.weights[a]),c=Ai(this.poolData.weights,this.poolData.weights[r]),m=((e,t,n,i,o,s)=>{const a=Number(t.toString()),r=Number(n.toString());return a*(1-(r/(r+e))**(o/i))*(1-Number(s.toString())/1e9)})(Number(n.toString()),this.poolData.reserves[r],this.poolData.reserves[a],c,u,this.poolData.fee.add(this.poolData.taxFee)),d=((e,t)=>{const n=yi(0,t),i=yi(e,t);return i<n?0:1-n/i})(Number(n.toString()),{balanceIn:this.poolData.reserves[a],balanceOut:this.poolData.reserves[r],weightIn:u,weightOut:c,swapFee:this.poolData.fee.add(this.poolData.taxFee)}),p=this.poolData.fee.add(this.poolData.taxFee).toNumber()/10**9,l=m/(1-p)*p;return{notEnoughLiquidity:!1,inAmount:n,outAmount:B.BigInt(Math.floor(m)),feeAmount:B.BigInt(Math.floor(l)),feeMint:t.toBase58(),feePct:0,priceImpactPct:d}}getSwapLegAndAccounts(t){var n;if(!this.poolData)throw new Error(`Invalid pool data ${this.address.toBase58()}`);const o=this.poolData.mints.findIndex((e=>e.equals(t.sourceMint))),a=this.poolData.mints.findIndex((e=>e.equals(t.destinationMint))),[r]=e.findProgramAddressSync([Buffer.from("treasurer"),this.address.toBuffer()],rn),u=Zn({tokenMintAddress:t.destinationMint,walletAddress:this.poolData.taxMan});return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o,sourceMint:a,destinationMint:r}){return[zn({balansol:{}}),ti.instruction.balansolSwap({accounts:{swapProgram:rn,authority:o,pool:e.pool,taxMan:e.taxMan,bidMint:a,treasurer:e.treasurer,srcTreasury:e.srcTreasury,srcAssociatedTokenAccount:t,askMint:r,dstTreasury:e.dstTreasury,dstAssociatedTokenAccount:n,dstTokenAccountTaxman:e.dstTokenAccountTaxman,systemProgram:i.programId,tokenProgram:W,associatedTokenProgram:Y,rent:s},remainingAccounts:e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[ni]}).keys]}({...t,additionalArgs:{pool:this.address,taxMan:this.poolData.taxMan,dstTokenAccountTaxman:u,treasurer:r,srcTreasury:this.poolData.treasuries[o],dstTreasury:this.poolData.treasuries[a],referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.destinationMint.toBase58())}})}get reserveTokenMints(){return this.poolData.mints}}Pi.getIDL=()=>Mi;const Ti=new C(ue);class vi{constructor(e,t,n){this.address=void 0,this.id=void 0,this.label="Crema",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.clmmpoolData=void 0,this.reserveTokenDecimals=void 0,this.tickArrayMapPubkey=void 0,this.feeRate=void 0,this.tickArrayMap=void 0,this.tickArrayPubkeys=[],this.tickArrays=[],this.arrayStartIndex=void 0,this.swapTicks=void 0,this.address=e,this.id=e.toBase58(),this.clmmpoolData=Ti.accounts.decode("clmmpool",t.data),this.feeRate=this.clmmpoolData.feeRate,this.tickArrayMapPubkey=ie.getTickArrayMapPDA(Ct,e).publicKey,this.reserveTokenDecimals=[n.decimalA,n.decimalB],this.arrayStartIndex=0}getAccountsForUpdate(){return[this.address,this.tickArrayMapPubkey,...this.tickArrayPubkeys]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing poolData ${this.address.toBase58()}`);this.clmmpoolData=Ti.accounts.decode("clmmpool",t.data),this.feeRate=this.clmmpoolData.feeRate;const n=e.get(this.tickArrayMapPubkey.toBase58());if(!n)throw new Error(`Missing tickArrayMap ${this.tickArrayMapPubkey.toBase58()}`);const i=Ti.accounts.decode("tickArrayMap",n.data);this.tickArrayPubkeys=this.getTickArrayPubkeys(this.address,i),this.tickArrayMap=i;const o=oe.getArrayIndex(this.clmmpoolData.currentTickIndex,this.clmmpoolData.tickSpacing);let s=!1;const a=[];for(let t=0;t<this.tickArrayPubkeys.length;t++){const n=e.get(this.tickArrayPubkeys[t].toBase58());if(n){const e=Ti.accounts.decode("tickArray",n.data);!1===s&&e.arrayIndex>=o&&(s=!0,this.arrayStartIndex=t),a.push({address:this.tickArrayPubkeys[t],data:e})}}this.tickArrays=a;const r={aToB:[],bToA:[]};for(let e=this.arrayStartIndex;e>this.arrayStartIndex-3;e--){let t=this.tickArrays[e];t&&r.aToB.push(t)}for(let e=this.arrayStartIndex;e<this.arrayStartIndex+3;e++){let t=this.tickArrays[e];t&&r.bToA.push(t)}this.swapTicks={aToB:[],bToA:[]},[r.aToB,r.bToA].forEach(((e,t)=>{for(let n=0;n<e.length;n++){const i=e[n];if(0===t)for(let e=se-1;e>=0;e--)i.data&&i.data.ticks[e].isInitialized&&this.swapTicks.aToB.push(i.data.ticks[e]);else for(let e=0;e<se;e++)i.data&&i.data.ticks[e].isInitialized&&this.swapTicks.bToA.push(i.data.ticks[e])}}))}getTickArrayPubkeys(e,t){let n=[];for(let e=0;e<868;e++){let i=t.bitmap[e];for(let e=0;e<8;e++)n.push((i>>e&1)>0)}const i=[];for(let t=0;t<n.length;t++)if(n[t]){const n=ie.getTickArrayPDA(Ct,e,t).publicKey;i.push(n)}return i}getQuote(e){let t,n,i;if(!this.swapTicks)throw new Error("swapTicks is not initialized");"ExactIn"===e.swapMode?(t=e.destinationMint,i=!0):(t=e.sourceMint,i=!1),n=!!e.sourceMint.equals(this.reserveTokenMints[0]);const o=new te(e.amount.toString()),s=ae(n,i,o,this.clmmpoolData,this.swapTicks[n?"aToB":"bToA"]),a=re.sqrtPriceX64ToPrice(this.clmmpoolData.currentSqrtPrice,this.reserveTokenDecimals[0],this.reserveTokenDecimals[1]).toNumber(),r=re.sqrtPriceX64ToPrice(s.nextSqrtPrice,this.reserveTokenDecimals[0],this.reserveTokenDecimals[1]).toNumber();let u=!1;if(u=i?s.amountIn.lt(o):s.amountOut.lt(o),u)throw new Error("not enough liquidity");return{notEnoughLiquidity:u,inAmount:B.BigInt(s.amountIn),outAmount:B.BigInt(s.amountOut),feeMint:t.toString(),feeAmount:B.multiply(B.BigInt(e.amount),B.BigInt(this.feeRate)),feePct:this.feeRate,priceImpactPct:Math.abs(a-r)/a}}getSwapLegAndAccounts(e){let t,n;if(!this.swapTicks)throw new Error("swapTicks is not initialized");const i=ie.getClmmConfigPDA(Ct).publicKey;if(t=!!e.sourceMint.equals(this.reserveTokenMints[0]),n="ExactIn"===e.swapMode,!this.tickArrayMap)throw new Error("tickArrayMap is not initialized");const o=new te(e.amount.toString()),s=ae(t,n,o,this.clmmpoolData,this.swapTicks[t?"aToB":"bToA"],this.address,this.tickArrayMap);return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i,sourceMint:o}){const{aToB:s,accountA:a,accountB:r}=o.equals(e.tokenA)?{aToB:!0,accountA:t,accountB:n}:{aToB:!1,accountA:n,accountB:t};let u=[];return e.remainingAccounts.forEach((e=>{u.push({pubkey:e,isSigner:!1,isWritable:!0})})),u.push(ni),[zn(Cn(s)),ti.instruction.cremaSwap({accounts:{swapProgram:Ct,clmmConfig:e.clmmConfig,clmmpool:e.clmmpool,tokenA:e.tokenA,tokenB:e.tokenB,accountA:a,accountB:r,tokenAVault:e.tokenAVault,tokenBVault:e.tokenBVault,tickArrayMap:e.tickArrayMap,owner:i,partner:Rt,partnerAtaA:Zn({walletAddress:Rt,tokenMintAddress:e.tokenA}),partnerAtaB:Zn({walletAddress:Rt,tokenMintAddress:e.tokenB}),tokenProgram:W},remainingAccounts:u}).keys]}({additionalArgs:{clmmConfig:i,clmmpool:this.address,tokenA:this.clmmpoolData.tokenA,tokenB:this.clmmpoolData.tokenB,tokenAVault:this.clmmpoolData.tokenAVault,tokenBVault:this.clmmpoolData.tokenBVault,tickArrayMap:this.tickArrayMapPubkey,remainingAccounts:s.swapTickArrays},...e})}get reserveTokenMints(){return[this.clmmpoolData.tokenA,this.clmmpoolData.tokenB]}}class bi{static async getStateFromStateAccount(e){const t=await e.getAccountInfo(xn);if(!t)throw new Error("State account not found");return(e=>{const t=qn.decode(e.data);return{isInitialized:Boolean(t.isInitialized),stateOwner:t.stateOwner,feeOwner:t.feeOwner,initialSupply:t.initialSupply,returnFeeNumerator:t.returnFeeNumerator.toNumber(),fixedFeeNumerator:t.fixedFeeNumerator.toNumber(),feeDenominator:t.feeDenominator.toNumber(),curveType:t.curveType,curveParameters:t.curveParameters}})(t)}constructor(t,n,i){this.id=void 0,this.label="Cropper",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.feePct=void 0,this.params=void 0,this.id=t.toBase58(),this.poolState=En(t,n),this.params={...i,tokenAFeeAccount:new e(i.tokenAFeeAccount),tokenBFeeAccount:new e(i.tokenBFeeAccount)},this.feePct=new ne(this.params.fixedFeeNumerator).add(new ne(this.params.returnFeeNumerator)).div(this.params.feeDenominator),this.calculator=new A(new M(B.BigInt(this.params.fixedFeeNumerator),B.BigInt(this.params.feeDenominator)),new M(B.BigInt(this.params.returnFeeNumerator),B.BigInt(this.params.feeDenominator)))}getAccountsForUpdate(){return[this.poolState.tokenAAccount,this.poolState.tokenBAccount]}update(e){const t=ft(e,this.getAccountsForUpdate());this.tokenReserveAmounts=Mt(t)}getQuote({sourceMint:e,amount:t}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const n=this.poolState.mintA.equals(e)?1:0,i=this.calculator.exchange(this.tokenReserveAmounts,t,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){const t=e.sourceMint.equals(this.poolState.mintA)?this.params.tokenAFeeAccount:this.params.tokenBFeeAccount;return function({poolState:e,feeAccount:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[a,r]=n.equals(e.mintA)?[e.tokenAAccount,e.tokenBAccount]:[e.tokenBAccount,e.tokenAAccount];return[zn({cropper:{}}),ti.instruction.cropperSwap({accounts:{tokenSwapProgram:e.programId,tokenProgram:W,swap:e.ammId,swapState:xn,authority:e.authority,userTransferAuthority:s,source:i,swapSource:a,swapDestination:r,destination:o,poolMint:e.poolMint,poolFee:t}}).keys]}({poolState:this.poolState,feeAccount:t,...e})}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}bi.decodePoolState=En;class Bi{constructor(e,t){this.program=void 0,this.pool=void 0,this.bitmapCache=void 0,this.tickCache=void 0,this.accountsToFetch={bitmaps:[],ticks:[]},this.program=e,this.pool=t,this.bitmapCache=new Map,this.tickCache=new Map}async eagerLoadCache(e,t){const n=B.toNumber(B.divide(B.BigInt(e),B.BigInt(t))),{wordPos:i}=ce(n);try{const e=[],{wordPos:n}=ce(Math.floor(me.MIN_TICK/t)),{wordPos:s}=ce(Math.floor(me.MAX_TICK/t)),a=Math.max(i-10,n),r=Math.min(i+10,s);for(let t=a;t<r;t++)e.push(this.getBitmapAddressSync(t));const u=await this.program.account.tickBitmapState.fetchMultiple(e),c=[];for(let n=0;n<r-a;n++){var o;const i=n+a,s=null===(o=u[n])||void 0===o?void 0:o.word,r=s?de(s):new R(0);if(this.bitmapCache.set(i,{address:e[n],word:r}),r&&!r.eqn(0))for(let e=0;e<256;e++)if(r.shrn(e).and(new R(1)).eqn(1)){const n=this.getTickAddressSync(((i<<8)+e)*t);c.push(n)}}const m=await this.program.account.tickState.fetchMultiple(c);for(const e in c){const t=m[e];if(!t)continue;const{tick:n,liquidityNet:i}=t;this.tickCache.set(n,{address:c[e],liquidityNet:B.BigInt(i)})}}catch(e){}}lazyLoadAccountsToCache(e,t){const n=B.toNumber(B.divide(B.BigInt(e),B.BigInt(t))),{wordPos:i}=ce(n),o=[],s=[],{wordPos:a}=ce(Math.floor(me.MIN_TICK/t)),{wordPos:r}=ce(Math.floor(me.MAX_TICK/t)),u=Math.max(i-10,a),c=Math.min(i+10,r);for(let e=u;e<c;e++){o.push(this.getBitmapAddressSync(e));const t=this.bitmapCache.get(e);s.push(t)}const m=[];for(let e=0;e<c-u;e++){var d,p;const n=e+u,i=null!==(d=null===(p=s[e])||void 0===p?void 0:p.word)&&void 0!==d?d:new R(0);if(this.bitmapCache.set(n,{address:o[e],word:i}),i&&!i.eqn(0))for(let e=0;e<256;e++)if(i.shrn(e).and(new R(1)).eqn(1)){const i=this.getTickAddressSync(((n<<8)+e)*t);m.push(i)}}return this.accountsToFetch={bitmaps:o,ticks:m},[...o,...m]}getTick(e){let t=this.tickCache.get(e);if(!t)throw new Error("Tick not cached");return{address:t.address,liquidityNet:t.liquidityNet}}async getTickAddress(e){return this.getTickAddressSync(e)}getTickAddressSync(e){return U([pe,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),le(this.pool.fee),le(e)],this.program.programId)[0]}async getBitmapAddress(e){return this.getBitmapAddressSync(e)}getBitmapAddressSync(e){return U([ge,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),le(this.pool.fee),he(e)],this.program.programId)[0]}getBitmap(e){let t=this.bitmapCache.get(e);if(!t)throw new Error("Bitmap not cached");return t}nextInitializedTickWithinOneWord(e,t,n){let i=B.toNumber(B.divide(B.BigInt(e),B.BigInt(n)));e<0&&e%n!=0&&(i-=1),t||(i+=1);const{wordPos:o,bitPos:s}=ce(i),a=this.getBitmap(o),{next:r,initialized:u}=Se(a.word,s,t);return[ke(o,r,n),u,o,s,a.address]}updateCachedAccountInfos(e){for(const t of this.accountsToFetch.bitmaps){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickBitmapState",n.data);this.bitmapCache.set(e.wordPos,{address:t,word:de(e.word)})}}for(const t of this.accountsToFetch.ticks){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickState",n.data);this.tickCache.set(e.tick,{address:t,liquidityNet:B.BigInt(e.liquidityNet)})}}}}const Ii=B.BigInt(1e6),Fi=new O(Ae,Yt,Tn);class Li{constructor(e,t){this.address=void 0,this.label="Cykura",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolState=void 0,this.pool=void 0,this.tickDataProvider=void 0,this.tokens=void 0,this.vaults=void 0,this.feePct=void 0,this.fee=void 0,this.address=e,this.id=e.toBase58(),this.poolState=Fi.coder.accounts.decode("poolState",t.data);const{token0:n,token1:i,fee:o,sqrtPriceX32:s,liquidity:a,tick:r}=this.poolState;this.tickDataProvider=new Bi(Fi,{token0:n,token1:i,fee:o}),this.tokens={token0:new ye(101,n,0,"",""),token1:new ye(101,i,0,"","")},this.pool=new fe(this.tokens.token0,this.tokens.token1,o,B.BigInt(s.toString()),B.BigInt(a.toString()),r,this.tickDataProvider),this.vaults={vault0:U([this.address.toBuffer(),W.toBuffer(),n.toBuffer()],Y)[0],vault1:U([this.address.toBuffer(),W.toBuffer(),i.toBuffer()],Y)[0]},this.fee=B.BigInt(this.poolState.fee),this.feePct=this.poolState.fee/B.toNumber(Ii)}getAccountsForUpdate(){return[this.address,...this.tickDataProvider.lazyLoadAccountsToCache(this.pool.tickCurrent,this.pool.tickSpacing)]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Could not find poolAccountInfo ${this.address.toBase58()}`);this.poolState=Fi.coder.accounts.decode("poolState",t.data);const{fee:n,sqrtPriceX32:i,liquidity:o,tick:s}=this.poolState;this.pool=new fe(this.tokens.token0,this.tokens.token1,n,B.BigInt(i.toString()),B.BigInt(o.toString()),s,this.tickDataProvider),this.tickDataProvider.updateCachedAccountInfos(e)}getQuote({sourceMint:e,amount:t}){const n=e.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[i,o,s]=this.pool.getOutputAmount(we.fromRawAmount(n,t)),a=y(B.subtract(this.pool.sqrtRatioX32,o.sqrtRatioX32)).div(this.pool.sqrtRatioX32.toString());return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.quotient,feeAmount:B.divide(B.multiply(t,this.fee),Ii),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:a.toNumber()}}getSwapLegAndAccounts(e){const[t,n]=e.sourceMint.equals(this.poolState.token0)?[this.vaults.vault0,this.vaults.vault1]:[this.vaults.vault1,this.vaults.vault0],i=U([Me,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),le(this.poolState.fee),he(this.poolState.observationIndex)],Yt)[0],o=e.sourceMint.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[,,s]=this.pool.getOutputAmount(we.fromRawAmount(o,e.amount)),a=U([Me,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),le(this.poolState.fee),he((this.poolState.observationIndex+1)%this.poolState.observationCardinalityNext)],Yt)[0],r={poolAddress:this.address,inputVault:t,outputVault:n,nextObservationState:a,lastObservationState:i,swapAccountMetas:s};return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){return[zn({cykura:{}}),ti.instruction.cykuraSwap({accounts:{swapProgram:Yt,signer:i,factoryState:Qt,poolState:e.poolAddress,inputTokenAccount:t,outputTokenAccount:n,inputVault:e.inputVault,outputVault:e.outputVault,lastObservationState:e.lastObservationState,coreProgram:Yt,tokenProgram:W},remainingAccounts:[...e.swapAccountMetas,{pubkey:e.nextObservationState,isSigner:!1,isWritable:!0},ni]}).keys]}({...e,additionalArgs:r})}get reserveTokenMints(){return[this.poolState.token0,this.poolState.token1]}}const Di={DkwiQyA2JfD8ARfvMbMqu2DD4XKRkewRZVDE94SZNxSS:{price:1}},qi=Te(nn,Tn);class xi{constructor(e,t){this.address=void 0,this.id=void 0,this.label="DeltaFi",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapInfo=void 0,this.feePct=void 0,this.prices=void 0,this.pythAddresses=void 0,this.address=e,this.id=e.toBase58(),this.swapInfo=qi.coder.accounts.decode("SwapInfo",t.data);const{swapConfig:n}=this.swapInfo;this.feePct=n.tradeFeeNumerator/n.tradeFeeDenominator,this.pythAddresses=[this.swapInfo.pythPriceBase,this.swapInfo.pythPriceQuote].filter((e=>!i.programId.equals(e)))}getAccountsForUpdate(){return[this.address,...this.pythAddresses]}getPriceData(e,t){const{id:n}=this,i=e.get(t.toBase58())||Di[n];if(!i)throw new Error(`Missing pyth account info for ${t.toBase58()}`);return"data"in i?ve(i.data):i}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing ${this.address.toBase58()}`);this.swapInfo=qi.coder.accounts.decode("SwapInfo",t.data);try{const t=this.getPriceData(e,this.swapInfo.pythPriceBase),n=this.getPriceData(e,this.swapInfo.pythPriceQuote);if(t.price&&n.price){const e=new be(t.price).dividedBy(new be(n.price)),i=new be(t.price+t.confidence).dividedBy(new be(n.price-n.confidence)),o=new be(t.price-t.confidence).dividedBy(new be(n.price+n.confidence));this.prices={marketPrice:e,highPrice:i,lowPrice:o}}else this.prices=void 0}catch(e){this.prices=void 0}}getQuote({destinationMint:e,amount:t}){if(!this.prices)throw new Error("Missing price data from pyth");const{swapInfo:n}=this,{amountIn:i,amountOut:o,priceImpact:s}=Pe(n,e.equals(n.mintQuote)?{sellBase:{}}:{sellQuote:{}},new be(t.toString()),this.prices.marketPrice,this.prices.highPrice,this.prices.lowPrice),a=o.multipliedBy(n.swapConfig.tradeFeeNumerator.toString()).dividedBy(n.swapConfig.tradeFeeDenominator.toString()).decimalPlaces(0),r=o.minus(a);return{notEnoughLiquidity:!1,inAmount:B.BigInt(i),outAmount:B.BigInt(r),feeAmount:B.BigInt(a),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:Number(s)}}getSwapLegAndAccounts(e){var t;if(!this.prices)throw new Error("Missing price data from pyth");const{swapSourceToken:n,swapDestinationToken:i,adminDestinationToken:o}=this.swapInfo.mintBase.equals(e.sourceMint)?{swapSourceToken:this.swapInfo.tokenBase,swapDestinationToken:this.swapInfo.tokenQuote,adminDestinationToken:this.swapInfo.adminFeeTokenQuote}:{swapSourceToken:this.swapInfo.tokenQuote,swapDestinationToken:this.swapInfo.tokenBase,adminDestinationToken:this.swapInfo.adminFeeTokenBase};return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){return[zn((o=e.stable,{deltaFi:{stable:o}})),ti.instruction.deltafiSwap({accounts:{swapProgram:nn,marketConfig:e.marketConfig,swapInfo:e.swapInfo,userSourceToken:t,userDestinationToken:n,swapSourceToken:e.swapSourceToken,swapDestinationToken:e.swapDestinationToken,deltafiUser:on,adminDestinationToken:e.adminDestinationToken,pythPriceBase:e.pythPriceBase,pythPriceQuote:e.pythPriceQuote,userAuthority:i,tokenProgram:W},remainingAccounts:e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[ni]}).keys];var o}({additionalArgs:{stable:!!this.swapInfo.swapType.stableSwap,marketConfig:this.swapInfo.configKey,swapInfo:this.address,swapSourceToken:n,swapDestinationToken:i,adminDestinationToken:o,pythPriceBase:this.swapInfo.pythPriceBase,pythPriceQuote:this.swapInfo.pythPriceQuote,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.destinationMint.toBase58())},...e})}get reserveTokenMints(){return[this.swapInfo.mintQuote,this.swapInfo.mintBase]}}const Ei=e=>X.fromBuffer(e.data.slice(64,72)),Oi=e=>X.fromBuffer(e.data.slice(36,44));function Vi(e){const t=e.readBigUInt64LE();return Number(t)}class Ci{constructor(e,t){this.address=void 0,this.id=void 0,this.label="GooseFX",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.pairLayout=void 0,this.quoter=void 0,this.gooseFxAccounts=void 0,this.fixedAccounts=void 0,this.oracleAccounts=[],this.quoteParams=void 0,this.isQuoteInvalid=!0,this.slot=void 0,this.address=e,this.id=e.toBase58(),this.pairLayout=Be.decode(t.data);const[n,i]=this.pairLayout.mints,o=new Ie;this.quoter=o.getSyncQuoter(n,i),this.gooseFxAccounts=this.quoter.getAccounts();const{pairAddress:s,sslIn:r,sslOut:u,liabilityVaultIn:c,liabilityVaultOut:m,swappedLiabilityVaultIn:d,swappedLiabilityVaultOut:p}=this.gooseFxAccounts;this.fixedAccounts=[a,s,r,u,c,m,d,p],this.updateOracles()}updateOracles(){const e=Number(this.pairLayout.nOracle.toString()),t=this.pairLayout.oracles.slice(0,e).reduce(((e,t)=>{const n=Number(t.n);for(const i of t.elements.slice(0,n))e.push(i.address);return e}),[]);this.oracleAccounts=t}getAccountsForUpdate(){return[...this.fixedAccounts,...this.oracleAccounts]}isSuspended(e){if(this.quoteParams){let t=Boolean(this.quoteParams.suspended);if(void 0!==e)for(const n of this.quoteParams.publishedSlots)t||=n+this.quoteParams.maxDelay<=e;return t}return!0}update(e){var t;const[n,i,o,s,a,r,u,c]=ft(e,this.fixedAccounts);if(!(i&&o&&s&&a&&r&&u&&c))throw new Error("Missing account data");const m=Le.OracleRegistry;this.pairLayout=Be.decode(i.data);const{oracles:d,nOracle:p,maxDelay:l}=this.pairLayout,g=Number(p.toString()),h=new m;this.updateOracles();let S=[];for(const t of d.slice(0,g)){const n=Number(t.n);for(const i of t.elements.slice(0,n)){const t=e.get(i.address.toBase58());if(!t)return void(this.isQuoteInvalid=!0);h.add_oracle(i.address.toBuffer(),t.data),S.push(BigInt(ve(t.data).aggregate.publishSlot))}}this.slot=BigInt(Vi(n.data)),this.isQuoteInvalid&&(this.isQuoteInvalid=!1),null===(t=this.quoteParams)||void 0===t||t.registry.free(),this.quoteParams={liabilityIn:BigInt(Ei(a).toString()),liabilityOut:BigInt(Ei(r).toString()),pairData:i.data,sslInData:o.data,sslOutData:s.data,swappedLiabilityIn:BigInt(Ei(u).toString()),swappedLiabilityOut:BigInt(Ei(c).toString()),registry:h,suspended:new Fe(o).isSuspended()||new Fe(s).isSuspended(),maxDelay:l,publishedSlots:S}}getQuote({sourceMint:e,amount:t}){if(!this.quoteParams||this.isQuoteInvalid)throw new Error("Missing quote data");if(this.isSuspended(this.slot))throw new Error("Quote suspended");const{quoteParams:n}=this,i=Le.swap;let o;const s=e.equals(this.pairLayout.mints[0]);o=s?i(n.sslInData.slice(),n.sslOutData.slice(),n.pairData.slice(),n.liabilityIn,n.liabilityOut,n.swappedLiabilityIn,n.swappedLiabilityOut,n.registry,BigInt(t.toString())):i(n.sslOutData.slice(),n.sslInData.slice(),n.pairData.slice(),n.liabilityOut,n.liabilityIn,n.swappedLiabilityOut,n.swappedLiabilityIn,n.registry,BigInt(t.toString()));const a=this.pairLayout.feeRates[s?0:1],r={notEnoughLiquidity:!1,inAmount:B.BigInt(o.amount_in.toString()),outAmount:B.BigInt(o.amount_out.toString()),feeAmount:B.BigInt(o.fee_paid.toString()),feeMint:e.toBase58(),feePct:a/1e4,priceImpactPct:o.price_impact};return o.free(),r}getSwapLegAndAccounts(e){var t;if(!this.quoteParams)throw new Error("Missing quote data");const n=e.sourceMint.equals(this.pairLayout.mints[0]),{gooseFxAccounts:i}=this,[o,s,a,r,u,c]=n?[i.sslIn,i.liabilityVaultIn,i.swappedLiabilityVaultIn,i.sslOut,i.liabilityVaultOut,i.swappedLiabilityVaultOut]:[i.sslOut,i.liabilityVaultOut,i.swappedLiabilityVaultOut,i.sslIn,i.liabilityVaultIn,i.swappedLiabilityVaultIn];return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=[];return o.push(e.referrer?{pubkey:e.referrer,isSigner:!1,isWritable:!0}:ni),e.oracles.forEach((e=>{o.push({pubkey:e,isSigner:!1,isWritable:!1})})),o.push(ni),[zn({gooseFx:{}}),ti.instruction.goosefxSwap({accounts:{swapProgram:sn,controller:an,pair:e.pair,sslIn:e.sslIn,sslOut:e.sslOut,liabilityVaultIn:e.liabilityVaultIn,swappedLiabilityVaultIn:e.swappedLiabilityVaultIn,liabilityVaultOut:e.liabilityVaultOut,swappedLiabilityVaultOut:e.swappedLiabilityVaultOut,userInAta:t,userOutAta:n,feeCollectorAta:e.feeCollectorAta,userWallet:i,feeCollector:e.feeCollector,tokenProgram:W},remainingAccounts:o}).keys]}({additionalArgs:{pair:this.gooseFxAccounts.pairAddress,sslIn:o,sslOut:r,liabilityVaultIn:s,swappedLiabilityVaultIn:a,liabilityVaultOut:u,swappedLiabilityVaultOut:c,feeCollectorAta:Zn({walletAddress:this.pairLayout.feeCollector,tokenMintAddress:e.sourceMint}),feeCollector:this.pairLayout.feeCollector,oracles:this.oracleAccounts,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.sourceMint.toBase58())},...e})}get reserveTokenMints(){return this.pairLayout.mints}}const Ri=new O(Ne,Xt,Tn);class Ni{static parsePoolStructure(e){return Ri.coder.accounts.decode("pool",e.data)}static parseTickmap(e){return Ri.coder.accounts.decode("tickmap",e.data)}static parseTick(e){return{...Ri.coder.accounts.decode("tick",e.data)}}static getQuote(e,t,n,i,o,s){const{currentTickIndex:a,fee:r,tickSpacing:u,tokenX:c,liquidity:m,sqrtPrice:d}=e,p={currentTickIndex:a,tickSpacing:u,liquidity:m,fee:r,sqrtPrice:d},l={xToY:i.equals(c),byAmountIn:s===kt.ExactIn,swapAmount:new te(o.toString()),priceLimit:i.equals(c)?qe(xe):qe(Ee),slippage:Oe(0),ticks:t,tickmap:n,pool:p};return Ve(l)}static getTickIndexToTickPubkeyHash(e,t,n){if(!n){const{tickAddress:n}=this.getTickAddress(e,t.currentTickIndex),i=new Map;return i.set(t.currentTickIndex,n),i}const i=Ce(n.bitmap,t.currentTickIndex,t.tickSpacing,Re,Infinity,"down"),o=Ce(n.bitmap,t.currentTickIndex,t.tickSpacing,Re,Infinity,"up");return i.concat([t.currentTickIndex]).concat(o).reduce(((t,n)=>{const{tickAddress:i}=this.getTickAddress(e,n);return t.set(n,i),t}),new Map)}static getTickAddress(t,n){const i=Buffer.alloc(4);i.writeInt32LE(n);const[o,s]=e.findProgramAddressSync([Buffer.from(N.bytes.utf8.encode("tickv1")),t.toBuffer(),i],Ri.programId);return{tickAddress:o,tickBump:s}}}class Ui{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Invariant",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolStructure=void 0,this.tickmap=void 0,this.tickPkToTickIndexHash=void 0,this.ticks=new Map,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.poolStructure=Ni.parsePoolStructure(t),this.tickPkToTickIndexHash=Ni.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.feePct=new ne(this.poolStructure.fee.v.toString()).div(Ue.toString()).toNumber()}getAccountsForUpdate(){const e=this.tickPkToTickIndexHash.values();return[this.address,this.poolStructure.tickmap,...e]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing invariant pool data ${this.address.toBase58()}`);this.poolStructure=Ni.parsePoolStructure(t);const n=e.get(this.poolStructure.tickmap.toBase58());n&&(this.tickmap=Ni.parseTickmap(n)),this.tickPkToTickIndexHash=Ni.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.ticks.clear();for(const[t,n]of this.tickPkToTickIndexHash){const i=e.get(n.toBase58());if(!i)continue;const o=Ni.parseTick(i);this.ticks.set(t,o)}}getQuote({sourceMint:e,amount:t,swapMode:n}){if(!this.tickmap)throw new Error("Missing tickmap");const i=Ni.getQuote(this.poolStructure,this.ticks,this.tickmap,e,t,n),o=new ne(i.priceImpact.toString()).div(Ue.toString()).toNumber();if(0!==i.status)throw new Error(`Invariant simulation failed: ${this.address}`);return{notEnoughLiquidity:!1,inAmount:B.BigInt(i.accumulatedAmountIn.toString()),outAmount:B.BigInt(i.accumulatedAmountOut.toString()),feeAmount:B.BigInt(i.accumulatedFee.toString()),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:o}}getSwapLegAndAccounts(e){var t;if(!this.tickmap)throw new Error("Missing tickmap");const n=Ni.getQuote(this.poolStructure,this.ticks,this.tickmap,e.sourceMint,e.amount,e.swapMode),i={};this.tickPkToTickIndexHash.forEach(((e,t)=>{i[t]=e}));const o=n.crossedTicks.concat(this.poolStructure.currentTickIndex).map((e=>{const t=i[e];if(!t)throw new Error("Missing tick account.");return t})),s=e.sourceMint.equals(this.poolStructure.tokenX);return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const[o,s]=e.xToY?[t,n]:[n,t],a=e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[];return e.crossedTickAddresses.forEach((e=>{a.push({pubkey:e,isSigner:!1,isWritable:!0})})),a.push(ni),[zn(Kn(e.xToY)),ti.instruction.invariantSwap({accounts:{swapProgram:Xt,tokenProgram:W,owner:i,state:jt,pool:e.pool,tickmap:e.tickmap,accountX:o,accountY:s,reserveX:e.reserveX,reserveY:e.reserveY,programAuthority:Wt},remainingAccounts:a}).keys]}({...e,additionalArgs:{xToY:s,pool:this.address,tickmap:this.poolStructure.tickmap,reserveX:this.poolStructure.tokenXReserve,reserveY:this.poolStructure.tokenYReserve,crossedTickAddresses:o,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.sourceMint.toBase58())}})}get reserveTokenMints(){return[this.poolStructure.tokenX,this.poolStructure.tokenY]}}class Ki{constructor(e,t){var n;this.ammAccountInfo=void 0,this.id=void 0,this.label="Lifinity",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapState=void 0,this.poolInfo=void 0,this.ammData=void 0,this.ammAccountInfo=t,this.id=e.toBase58(),this.swapState=((e,t)=>{const n=t.owner,i=Ke.decode(t.data),[o]=U([e.toBuffer()],n);return{programId:n,authority:o,amm:e,tokenAMint:i.tokenAMint,tokenBMint:i.tokenBMint,poolMint:i.poolMint,feeAccount:i.poolFeeAccount,pythAccount:i.pythAccount,pythPcAccount:i.pythPcAccount,configAccount:i.configAccount,poolCoinTokenAccount:i.tokenAAccount,poolCoinMint:i.tokenAMint,poolPcTokenAccount:i.tokenBAccount,poolPcMint:i.tokenBMint}})(e,t),this.poolInfo={amm:(n=this.swapState).amm.toBase58(),configAccount:n.configAccount.toBase58(),feeAccount:n.feeAccount.toBase58(),pythAccount:n.pythAccount.toBase58(),pythPcAccount:n.pythPcAccount.toBase58(),poolCoinMint:n.poolCoinMint.toBase58(),poolCoinTokenAccount:n.poolCoinTokenAccount.toBase58(),poolMint:n.poolMint.toBase58(),poolPcTokenAccount:n.poolPcTokenAccount.toBase58(),poolPcMint:n.poolPcMint.toBase58(),poolCoinDecimal:0,poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:0}}getAccountsForUpdate(){return[this.swapState.poolCoinTokenAccount,this.swapState.poolPcTokenAccount,this.swapState.configAccount,this.swapState.pythAccount,this.swapState.pythPcAccount]}update(e){const t=[];this.getAccountsForUpdate().forEach(((n,i)=>{const o=e.get(n.toBase58());o&&t.push({publicKey:n,account:o})})),this.ammData=Xe([{publicKey:this.swapState.amm,account:this.ammAccountInfo},...t],this.poolInfo)}getQuote({sourceMint:e,amount:t}){if(!this.ammData)throw new Error("Accounts not loaded, missing ammData");if(this.isTradeFrozen)throw new Error("Trade is frozen");const n=this.swapState.poolCoinMint.equals(e)?je.AtoB:je.BtoA;if(!this.ammData.pyth.status.equals(1)||this.ammData.pythPc&&!this.ammData.pythPc.status.equals(1))throw new Error("Pyth accounts are outdated");const i=new ne(t.toString()),o=We(i,this.ammData.pyth.publishSlot.toNumber(),this.ammData.amm,this.ammData.fees,this.ammData.coinBalance,this.ammData.pcBalance,this.ammData.config,this.ammData.pyth,this.ammData.pythPc,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:B.BigInt(o.amountSwapped.toString()),feeAmount:B.BigInt(o.fee.ceil().toString()),feeMint:e.toBase58(),feePct:o.feePercent.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({swapState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,a]=t.equals(e.tokenAMint)?[e.poolCoinTokenAccount,e.poolPcTokenAccount]:[e.poolPcTokenAccount,e.poolCoinTokenAccount];return[zn({lifinity:{}}),ti.instruction.lifinitySwap({accounts:{swapProgram:e.programId,authority:e.authority,amm:e.amm,userTransferAuthority:o,sourceInfo:n,destinationInfo:i,swapSource:s,swapDestination:a,poolMint:e.poolMint,feeAccount:e.feeAccount,tokenProgram:W,pythAccount:e.pythAccount,pythPcAccount:e.pythPcAccount,configAccount:e.configAccount}}).keys]}({swapState:this.swapState,...e})}get reserveTokenMints(){return[this.swapState.poolCoinMint,this.swapState.poolPcMint]}get isTradeFrozen(){var e;return 1===(null===(e=this.ammData)||void 0===e?void 0:e.amm.freezeTrade)}}class Xi{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Lifinity V2",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.ammState=void 0,this.poolInfo=void 0,this.ammData=void 0,this.slot=void 0,this.address=e;const n=new V(Ye);var i;this.id=e.toBase58(),this.ammState=n.decode("amm",t.data),this.poolInfo={amm:this.id,poolMint:(i=this.ammState).poolMint.toBase58(),feeAccount:i.feeAccount.toBase58(),oracleMainAccount:i.oracleMainAccount.toBase58(),oracleSubAccount:i.oracleSubAccount.toBase58(),oraclePcAccount:i.oraclePcAccount.toBase58(),poolCoinTokenAccount:i.tokenAAccount.toBase58(),poolCoinMint:i.tokenAMint.toBase58(),poolCoinDecimal:0,poolPcTokenAccount:i.tokenBAccount.toBase58(),poolPcMint:i.tokenBMint.toBase58(),poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:i.baseDecimals}}getAccountsForUpdate(){return[this.address,this.ammState.tokenAAccount,this.ammState.tokenBAccount,this.ammState.oracleMainAccount,this.ammState.oracleSubAccount,this.ammState.oraclePcAccount,a]}update(e){const t=this.getAccountsForUpdate().reduce(((t,n)=>{const i=e.get(n.toBase58());return i&&t.push({publicKey:n,account:i}),t}),new Array);this.ammData=Qe(t,this.poolInfo),this.slot=Vi(t[t.length-1].account.data)}getQuote({sourceMint:e,amount:t}){if(!this.ammData)throw new Error("Accounts not loaded, missing ammData");if(void 0===this.slot)throw new Error("Slot not fetched");if(this.isTradeFrozen)throw new Error("Trade is frozen");const n=this.ammState.tokenAMint.equals(e)?ze.AtoB:ze.BtoA;if(this.ammData.oracleMain&&!this.ammData.oracleMain.status.equals(1)||this.ammData.oracleSub&&!this.ammData.oracleSub.status.equals(1)||this.ammData.oraclePc&&!this.ammData.oraclePc.status.equals(1))throw new Error("Pyth accounts are outdated");const i=new ne(t.toString()),o=He(i,this.slot,this.ammData.amm,this.ammData.fees,this.ammData.coinBalance,this.ammData.pcBalance,this.ammData.config,this.ammData.oracleMain,this.ammData.oracleSub,this.ammData.oraclePc,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:B.BigInt(o.amountSwapped.toString()),feeAmount:B.BigInt(o.fee.ceil().toString()),feeMint:e.toBase58(),feePct:o.feePercent.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({ammState:e,amm:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[a,r]=n.equals(e.tokenAMint)?[e.tokenAAccount,e.tokenBAccount]:[e.tokenBAccount,e.tokenAAccount];return[zn({lifinityV2:{}}),ti.instruction.lifinityV2Swap({accounts:{swapProgram:dn,authority:U([t.toBuffer()],dn)[0],amm:t,userTransferAuthority:s,sourceInfo:i,destinationInfo:o,swapSource:a,swapDestination:r,poolMint:e.poolMint,feeAccount:e.feeAccount,tokenProgram:W,oracleMainAccount:e.oracleMainAccount,oracleSubAccount:e.oracleSubAccount,oraclePcAccount:e.oraclePcAccount}}).keys]}({ammState:this.ammState,amm:this.address,...e})}get reserveTokenMints(){return[this.ammState.tokenAMint,this.ammState.tokenBMint]}get isTradeFrozen(){return 1===this.ammState.freezeTrade}}var ji="marinade_finance",Wi=[{name:"initialize",accounts:[{name:"creatorAuthority",isMut:!1,isSigner:!0},{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!1,isSigner:!1},{name:"liqPool",accounts:[{name:"lpMint",isMut:!1,isSigner:!1},{name:"solLegPda",isMut:!1,isSigner:!1},{name:"msolLeg",isMut:!1,isSigner:!1}]},{name:"treasuryMsolAccount",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"data",type:{defined:"InitializeData"}}]},{name:"changeAuthority",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"data",type:{defined:"ChangeAuthorityData"}}]},{name:"addValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!1,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"score",type:"u32"}]},{name:"removeValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"}]},{name:"setValidatorScore",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"},{name:"score",type:"u32"}]},{name:"configValidatorSystem",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0}],args:[{name:"extraRuns",type:"u32"}]},{name:"deposit",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"depositStakeAccount",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeAuthority",isMut:!1,isSigner:!0},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"msolMint",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"liquidUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"addLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"lpMintAuthority",isMut:!1,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!1,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"removeLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"burnFrom",isMut:!0,isSigner:!1},{name:"burnFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"transferMsolTo",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokens",type:"u64"}]},{name:"setLpParams",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"minFee",type:{defined:"Fee"}},{name:"maxFee",type:{defined:"Fee"}},{name:"liquidityTarget",type:"u64"}]},{name:"configMarinade",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"params",type:{defined:"ConfigMarinadeParams"}}]},{name:"orderUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"burnMsolFrom",isMut:!0,isSigner:!1},{name:"burnMsolAuthority",isMut:!1,isSigner:!0},{name:"newTicketAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"claim",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"ticketAccount",isMut:!0,isSigner:!1},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"stakeReserve",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeConfig",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"updateActive",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"updateDeactivated",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"}]},{name:"deactivateStake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"splitStakeAccount",isMut:!0,isSigner:!0},{name:"splitStakeRentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"emergencyUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorManagerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"mergeStakes",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"destinationStake",isMut:!0,isSigner:!1},{name:"sourceStake",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"destinationStakeIndex",type:"u32"},{name:"sourceStakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]}],Yi=[{name:"State",type:{kind:"struct",fields:[{name:"msolMint",type:"publicKey"},{name:"adminAuthority",type:"publicKey"},{name:"operationalSolAccount",type:"publicKey"},{name:"treasuryMsolAccount",type:"publicKey"},{name:"reserveBumpSeed",type:"u8"},{name:"msolMintAuthorityBumpSeed",type:"u8"},{name:"rentExemptForTokenAcc",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"stakeSystem",type:{defined:"StakeSystem"}},{name:"validatorSystem",type:{defined:"ValidatorSystem"}},{name:"liqPool",type:{defined:"LiqPool"}},{name:"availableReserveBalance",type:"u64"},{name:"msolSupply",type:"u64"},{name:"msolPrice",type:"u64"},{name:"circulatingTicketCount",type:"u64"},{name:"circulatingTicketBalance",type:"u64"},{name:"lentFromReserve",type:"u64"},{name:"minDeposit",type:"u64"},{name:"minWithdraw",type:"u64"},{name:"stakingSolCap",type:"u64"},{name:"emergencyCoolingDown",type:"u64"}]}},{name:"TicketAccountData",type:{kind:"struct",fields:[{name:"stateAddress",type:"publicKey"},{name:"beneficiary",type:"publicKey"},{name:"lamportsAmount",type:"u64"},{name:"createdEpoch",type:"u64"}]}}],Qi=[{name:"Fee",type:{kind:"struct",fields:[{name:"basisPoints",type:"u32"}]}},{name:"InitializeData",type:{kind:"struct",fields:[{name:"adminAuthority",type:"publicKey"},{name:"validatorManagerAuthority",type:"publicKey"},{name:"minStake",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"liqPool",type:{defined:"LiqPoolInitializeData"}},{name:"additionalStakeRecordSpace",type:"u32"},{name:"additionalValidatorRecordSpace",type:"u32"},{name:"slotsForStakeDelta",type:"u64"}]}},{name:"LiqPoolInitializeData",type:{kind:"struct",fields:[{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"lpTreasuryCut",type:{defined:"Fee"}}]}},{name:"ChangeAuthorityData",type:{kind:"struct",fields:[{name:"admin",type:{option:"publicKey"}},{name:"validatorManager",type:{option:"publicKey"}},{name:"operationalSolAccount",type:{option:"publicKey"}},{name:"treasuryMsolAccount",type:{option:"publicKey"}}]}},{name:"ConfigMarinadeParams",type:{kind:"struct",fields:[{name:"rewardsFee",type:{option:{defined:"Fee"}}},{name:"slotsForStakeDelta",type:{option:"u64"}},{name:"minStake",type:{option:"u64"}},{name:"minDeposit",type:{option:"u64"}},{name:"minWithdraw",type:{option:"u64"}},{name:"stakingSolCap",type:{option:"u64"}},{name:"liquiditySolCap",type:{option:"u64"}},{name:"autoAddValidatorEnabled",type:{option:"bool"}}]}},{name:"LiqPool",type:{kind:"struct",fields:[{name:"lpMint",type:"publicKey"},{name:"lpMintAuthorityBumpSeed",type:"u8"},{name:"solLegBumpSeed",type:"u8"},{name:"msolLegAuthorityBumpSeed",type:"u8"},{name:"msolLeg",type:"publicKey"},{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"treasuryCut",type:{defined:"Fee"}},{name:"lpSupply",type:"u64"},{name:"lentFromSolLeg",type:"u64"},{name:"liquiditySolCap",type:"u64"}]}},{name:"List",type:{kind:"struct",fields:[{name:"account",type:"publicKey"},{name:"itemSize",type:"u32"},{name:"count",type:"u32"},{name:"newAccount",type:"publicKey"},{name:"copiedCount",type:"u32"}]}},{name:"StakeRecord",type:{kind:"struct",fields:[{name:"stakeAccount",type:"publicKey"},{name:"lastUpdateDelegatedLamports",type:"u64"},{name:"lastUpdateEpoch",type:"u64"},{name:"isEmergencyUnstaking",type:"u8"}]}},{name:"StakeSystem",type:{kind:"struct",fields:[{name:"stakeList",type:{defined:"List"}},{name:"delayedUnstakeCoolingDown",type:"u64"},{name:"stakeDepositBumpSeed",type:"u8"},{name:"stakeWithdrawBumpSeed",type:"u8"},{name:"slotsForStakeDelta",type:"u64"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"minStake",type:"u64"},{name:"extraStakeDeltaRuns",type:"u32"}]}},{name:"ValidatorRecord",type:{kind:"struct",fields:[{name:"validatorAccount",type:"publicKey"},{name:"activeBalance",type:"u64"},{name:"score",type:"u32"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"duplicationFlagBumpSeed",type:"u8"}]}},{name:"ValidatorSystem",type:{kind:"struct",fields:[{name:"validatorList",type:{defined:"List"}},{name:"managerAuthority",type:"publicKey"},{name:"totalValidatorScore",type:"u32"},{name:"totalActiveBalance",type:"u64"},{name:"autoAddValidatorEnabled",type:"u8"}]}},{name:"CommonError",type:{kind:"enum",variants:[{name:"InvalidProgramId",fields:["publicKey"]},{name:"UnexpectedAccount",fields:["publicKey"]},{name:"CalculationFailure"},{name:"AccountWithLockup"},{name:"NumberTooLow",fields:["u64","u64"]},{name:"NumberTooHigh",fields:["u64","u64"]},{name:"FeeTooHigh",fields:[{defined:"Fee"}]},{name:"FeesWrongWayRound",fields:[{defined:"Fee"},{defined:"Fee"}]},{name:"LiquidityTargetTooLow"},{name:"TicketNotDue",fields:["u64"]},{name:"TicketNotReady"},{name:"WrongBeneficiary"},{name:"InsufficientLiquidity"},{name:"InvalidValidator"}]}},{name:"InitializeError",type:{kind:"enum",variants:[{name:"WrongReserveOwner",fields:["publicKey"]},{name:"NonEmptyReserveData",fields:[{defined:"usize"}]},{name:"InvalidInitialReserveLamports",fields:["u64"]},{name:"ZeroValidatorChunkSize"},{name:"TooBigValidatorChunkSize",fields:["u32"]},{name:"ZeroCreditChunkSize"},{name:"TooBigCreditChunkSize",fields:["u32"]},{name:"TooLowCreditFee",fields:["u64"]},{name:"InvalidMintAuthority",fields:[{name:"expected",type:"publicKey"},{name:"got",type:"publicKey"}]},{name:"MintHasInitialSupply",fields:["u64"]},{name:"InvalidOwnerFeeState",fields:[{defined:"spl_token::state::AccountState"}]}]}}],zi={__proto__:null,version:"0.0.0",name:ji,instructions:Wi,accounts:Yi,types:Qi,default:{version:"0.0.0",name:ji,instructions:Wi,accounts:Yi,types:Qi}};function Hi(e,t,n){return n.isZero()?e:e.mul(t).div(n)}class _i{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Marinade",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.marinadeFinanceProgram=void 0,this.marinadeStateResponse=void 0,this.liqPoolSolLegPdaAddress=void 0,this.marinadeState=void 0,this.id=e.toBase58(),this.marinadeFinanceProgram=new O(zi,zt,{}),this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data),this.address=e,this.liqPoolSolLegPdaAddress=this.findProgramDerivedAddress("liq_sol")}getAccountsForUpdate(){return[this.address,this.liqPoolSolLegPdaAddress,this.marinadeStateResponse.liqPool.msolLeg]}update(e){const[t,n,i]=ft(e,this.getAccountsForUpdate());this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data);const o=F(i.data);if(!o)throw new Error(`liqPoolMSOLLeg token account cannot be deserialized ${this.marinadeStateResponse.liqPool.msolLeg.toBase58()}`);this.marinadeState=new Gi(this.marinadeStateResponse,new ee(n.lamports),o.amount)}getQuote({sourceMint:e,amount:t}){if(!this.marinadeState)throw new Error("Update was not run to create a complete marinadeState");const n=new ee(t.toString()),i=e.equals(Q)?this.marinadeState.depositQuote(n):this.marinadeState.liquidUnstakeQuote(n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:B.BigInt(i.outAmount.toString()),feeAmount:B.BigInt(i.feeAmount.toString()),feeMint:this.marinadeStateResponse.msolMint.toBase58(),feePct:i.feePct,priceImpactPct:0}}getSwapLegAndAccounts(e){return e.sourceMint.equals(Q)?function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){const a=U([Buffer.from("temp-wsol-token-account"),o.toBuffer()],ei)[0],r=U([Buffer.from("temp-sol-pda"),o.toBuffer()],ei)[0];return[zn({marinadeDeposit:{}}),ti.instruction.marinadeDeposit({accounts:{marinadeFinanceProgram:zt,state:e.address,msolMint:e.marinadeStateResponse.msolMint,liqPoolSolLegPda:e.liqPoolSolLegPda,liqPoolMsolLeg:e.marinadeStateResponse.liqPool.msolLeg,liqPoolMsolLegAuthority:e.liqPoolMsolLegAuthority,reservePda:e.reservePda,transferFrom:r,mintTo:n,msolMintAuthority:e.msolMintAuthority,systemProgram:i.programId,tokenProgram:W,userWsolTokenAccount:t,tempWsolTokenAccount:a,userTransferAuthority:o,wsolMint:Q,rent:s}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress,liqPoolMsolLegAuthority:this.findProgramDerivedAddress("liq_st_sol_authority"),reservePda:this.findProgramDerivedAddress("reserve"),msolMintAuthority:this.findProgramDerivedAddress("st_mint")},...e}):function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o}){const s=U([Buffer.from("temp-sol-pda"),o.toBuffer()],ei)[0];return[zn({marinadeUnstake:{}}),ti.instruction.marinadeUnstake({accounts:{marinadeFinanceProgram:zt,state:e.address,msolMint:e.marinadeStateResponse.msolMint,liqPoolSolLegPda:e.liqPoolSolLegPda,liqPoolMsolLeg:e.marinadeStateResponse.liqPool.msolLeg,treasuryMsolAccount:e.marinadeStateResponse.treasuryMsolAccount,getMsolFrom:t,getMsolFromAuthority:o,transferSolTo:s,systemProgram:i.programId,tokenProgram:W,userWsolTokenAccount:n}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress},...e})}get reserveTokenMints(){return[Q,this.marinadeStateResponse.msolMint]}findProgramDerivedAddress(e,t=[]){const n=[this.address.toBuffer(),Buffer.from(e),...t],[i]=U(n,this.marinadeFinanceProgram.programId);return i}}class Gi{constructor(e,t,n){this.state=void 0,this.liqPoolSolLegPdaLamports=void 0,this.liqPoolMSOLLegAmount=void 0,this.state=e,this.liqPoolSolLegPdaLamports=t,this.liqPoolMSOLLegAmount=n}depositQuote(e){let t=e;const n=this.calcMSOLFromLamports(t),i=ee.min(n,this.liqPoolMSOLLegAmount);let o=new ee(0);if(t=(()=>{if(i.gt(new ee(0))){const e=n.eq(i)?t:this.calcLamportsFromMSOLAmount(i);return o=o.add(i),Ji(t,e)}return t})(),t.gt(new ee(0))){this.checkStakingCap(t);const e=this.calcMSOLFromLamports(t);o=o.add(e)}return{outAmount:o,feeAmount:0,feePct:0,priceImpactPct:0}}checkStakingCap(e){if(this.totalLamportsUnderControl().add(e).gt(this.state.stakingSolCap))throw new Error("Staking cap reached")}calcMSOLFromLamports(e){return t=e,n=this.totalVirtualStakedLamports(),(i=this.state.msolSupply).eq(new ee(0))?t:Hi(t,i,n);var t,n,i}calcLamportsFromMSOLAmount(e){return Hi(e,this.totalVirtualStakedLamports(),this.state.msolSupply)}totalVirtualStakedLamports(){return Ji(this.totalLamportsUnderControl(),this.state.circulatingTicketBalance)}totalLamportsUnderControl(){return this.state.validatorSystem.totalActiveBalance.add(this.totalCoolingDown()).add(this.state.availableReserveBalance)}totalCoolingDown(){return this.state.stakeSystem.delayedUnstakeCoolingDown.add(this.state.emergencyCoolingDown)}liquidUnstakeQuote(e){const t=Ji(this.liqPoolSolLegPdaLamports,this.state.rentExemptForTokenAcc),n=this.calcLamportsFromMSOLAmount(e),i=function(e,t,n,i,o){if(o.gte(i))return t;const s=i.sub(o);return s.gte(n)?e:t-Hi(new ee(t-e),s,n).toNumber()}(this.state.liqPool.lpMinFee.basisPoints,this.state.liqPool.lpMaxFee.basisPoints,this.state.liqPool.lpLiquidityTarget,t,n),o=e.mul(new ee(i)).div(new ee(1e4)),s=this.calcLamportsFromMSOLAmount(e.sub(o));if(s.add(this.state.rentExemptForTokenAcc).gt(this.liqPoolSolLegPdaLamports))throw new Error("Insufficient liquidity");return{outAmount:s,feeAmount:o,feePct:i/1e4,priceImpactPct:0}}}function Ji(e,t){return e.gt(t)?e.sub(t):new ee(0)}const $i=Math.pow(10,10),Zi=_([G("version"),G("isInitialized"),G("nonce"),In("amplificationCoefficient"),In("feeNumerator"),In("adminFeeNumerator"),J("tokenAccountsLength"),In("precisionFactor"),In("precisionMultiplierA"),In("precisionMultiplierB"),In("precisionMultiplierC"),In("precisionMultiplierD"),bn("tokenAccountA"),bn("tokenAccountB"),bn("tokenAccountC"),bn("tokenAccountD")]),eo=(e,t)=>{const n=t.owner,i=Zi.decode(t.data),o=i.tokenAccountsLength,s=Ln([e.toBuffer(),Buffer.from([i.nonce])],n),a=[i.precisionMultiplierA.toNumber(),i.precisionMultiplierB.toNumber(),i.precisionMultiplierC.toNumber(),i.precisionMultiplierD.toNumber()].slice(0,o),r=[i.tokenAccountA,i.tokenAccountB,i.tokenAccountC,i.tokenAccountD].slice(0,o);return{programId:n,authority:s,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:e,amplificationCoefficient:i.amplificationCoefficient.toNumber(),feeNumerator:i.feeNumerator.toNumber(),tokenAccountsLength:o,precisionFactor:i.precisionFactor.toNumber(),precisionMultipliers:a,tokenAccounts:r}};class to{constructor(t,n,i){this.params=void 0,this.id=void 0,this.label="Mercurial",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapLayout=void 0,this.tokenMints=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.params=i,this.id=t.toBase58(),this.swapLayout=eo(t,n),this.calculator=new w(B.BigInt(this.swapLayout.tokenAccountsLength),B.BigInt(this.swapLayout.amplificationCoefficient),this.swapLayout.precisionMultipliers.map((e=>B.BigInt(e))),new M(B.BigInt(this.swapLayout.feeNumerator),B.BigInt($i))),this.tokenMints=i.tokenMints.map((t=>new e(t)))}getAccountsForUpdate(){return this.swapLayout.tokenAccounts}update(e){const t=ft(e,this.getAccountsForUpdate());this.tokenReserveAmounts=Mt(t)}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const i=this.tokenReserveAmounts.findIndex(((t,n)=>this.tokenMints[n].equals(e))),o=this.tokenReserveAmounts.findIndex(((e,n)=>this.tokenMints[n].equals(t))),s=this.calculator.exchange(this.tokenReserveAmounts,n,i,o),a=this.swapLayout.feeNumerator/$i;return{notEnoughLiquidity:!1,inAmount:n,outAmount:s.expectedOutputAmount,feeAmount:s.fees,feeMint:t.toBase58(),feePct:a,priceImpactPct:s.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({swapLayout:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=[];for(const t of e.tokenAccounts)o.push({pubkey:t,isSigner:!1,isWritable:!0});return[zn({mercurial:{}}),ti.instruction.mercurialSwap({accounts:oi(e,t,n,i),remainingAccounts:o}).keys]}({swapLayout:this.swapLayout,...e})}get reserveTokenMints(){return this.params.tokenMints.map((t=>new e(t)))}}to.decodeSwapLayout=eo;const no=new O(_e,Ge,Tn),io=new O(Je,Ge,Tn),oo=e=>no.coder.accounts.decode("pool",e.data),so=e=>io.coder.accounts.decode("vault",e.data);class ao{constructor(t,n,i){this.address=void 0,this.id=void 0,this.label="Meteora",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.data=void 0,this.depegAccount=void 0,this.depegAccounts=new Map,this.vaultLpMint=void 0,this.vaultToken=void 0,this.feePct=void 0,this.address=t,this.id=t.toBase58(),this.poolState=oo(n),this.vaultLpMint={a:new e(i.vaultLpMint.a),b:new e(i.vaultLpMint.b)},this.vaultToken={a:new e(i.vaultToken.a),b:new e(i.vaultToken.b)},i.depegAccount&&(this.depegAccount={...i.depegAccount,pubkey:new e(i.depegAccount.pubkey),data:Buffer.from(i.depegAccount.data[0],i.depegAccount.data[1]),owner:new e(i.depegAccount.owner)},this.depegAccounts=new Map([[this.depegAccount.pubkey.toBase58(),this.depegAccount]]));const{ownerTradeFeeDenominator:o,ownerTradeFeeNumerator:s,tradeFeeDenominator:a,tradeFeeNumerator:r}=this.poolState.fees;this.feePct=new ne(s.toString()).div(o.toString()).add(new ne(r.toString()).div(a.toString())).toNumber()}getAccountsForUpdate(){var e;const t=[this.poolState.aVault,this.poolState.bVault,this.poolState.aVaultLp,this.poolState.bVaultLp,this.poolState.lpMint,this.vaultLpMint.a,this.vaultLpMint.b,this.vaultToken.a,this.vaultToken.b,a];return null!==(e=this.depegAccount)&&void 0!==e&&e.pubkey&&t.push(this.depegAccount.pubkey),t}update(e){const[t,n,i,o,s,a,r,u,c,m,d]=ft(e,this.getAccountsForUpdate());d&&this.depegAccount&&(this.depegAccount.data=d.data),this.data={vaultA:so(t),vaultB:so(n),poolAVaultLpAmount:Ei(i),poolBVaultLpAmount:Ei(o),poolLpTotalSupply:Oi(s),vaultALpTotalSupply:Oi(a),vaultBLpTotalSupply:Oi(r),vaultAReserve:Ei(u),vaultBReserve:Ei(c),currentTime:new te(m.data.readBigInt64LE(32).toString()).toNumber()}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(void 0===this.data)throw new Error("Unable to fetch accounts.");let i=new te(n.toString());const o=$e(e,i,{currentTime:this.data.currentTime,depegAccounts:this.depegAccounts,poolState:this.poolState,poolVaultALp:this.data.poolAVaultLpAmount,poolVaultBLp:this.data.poolBVaultLpAmount,vaultA:this.data.vaultA,vaultALpSupply:this.data.vaultALpTotalSupply,vaultB:this.data.vaultB,vaultBLpSupply:this.data.vaultBLpTotalSupply,vaultAReserve:this.data.vaultAReserve,vaultBReserve:this.data.vaultBReserve});return{notEnoughLiquidity:!1,inAmount:n,outAmount:B.BigInt(o.amountOut.toString()),feeAmount:B.BigInt(o.fee.toString()),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:0}}getSwapLegAndAccounts(e){var t,n;if(void 0===this.data)throw new Error("Unable to fetch accounts.");const i=e.sourceMint.equals(this.poolState.tokenAMint)?this.poolState.adminTokenAFee:this.poolState.adminTokenBFee;return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=[];return o.push(e.referrer?{pubkey:e.referrer,isSigner:!1,isWritable:!0}:ni),o.push(e.depeg?{pubkey:e.depeg,isSigner:!1,isWritable:!1}:ni),[zn({meteora:{}}),ti.instruction.meteoraSwap({accounts:{swapProgram:en,pool:e.pool,userSourceToken:t,userDestinationToken:n,aVault:e.aVault,bVault:e.bVault,aTokenVault:e.aTokenVault,bTokenVault:e.bTokenVault,aVaultLpMint:e.aVaultLpMint,bVaultLpMint:e.bVaultLpMint,aVaultLp:e.aVaultLp,bVaultLp:e.bVaultLp,adminTokenFee:e.adminTokenFee,user:i,vaultProgram:tn,tokenProgram:W},remainingAccounts:o}).keys]}({additionalArgs:{pool:this.address,aVault:this.poolState.aVault,bVault:this.poolState.bVault,aTokenVault:this.vaultToken.a,bTokenVault:this.vaultToken.b,aVaultLpMint:this.vaultLpMint.a,bVaultLpMint:this.vaultLpMint.b,aVaultLp:this.poolState.aVaultLp,bVaultLp:this.poolState.bVaultLp,adminTokenFee:i,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.sourceMint.toBase58()),depeg:null===(n=this.depegAccount)||void 0===n?void 0:n.pubkey},...e})}get reserveTokenMints(){return[this.poolState.tokenAMint,this.poolState.tokenBMint]}}ao.accountInfoToMeteoraSwapLayout=oo,ao.accountInfoToVaultLayout=so;const ro=_([$("status"),$("nonce"),$("orderNum"),$("depth"),$("coinDecimals"),$("pcDecimals"),$("state"),$("resetFlag"),$("minSize"),$("volMaxCutRatio"),$("amountWaveRatio"),$("coinLotSize"),$("pcLotSize"),$("minPriceMultiplier"),$("maxPriceMultiplier"),$("systemDecimalsValue"),$("minSeparateNumerator"),$("minSeparateDenominator"),$("tradeFeeNumerator"),$("tradeFeeDenominator"),$("pnlNumerator"),$("pnlDenominator"),$("swapFeeNumerator"),$("swapFeeDenominator"),$("needTakePnlCoin"),$("needTakePnlPc"),$("totalPnlPc"),$("totalPnlCoin"),Fn("poolTotalDepositPc"),Fn("poolTotalDepositCoin"),Fn("swapCoinInAmount"),Fn("swapPcOutAmount"),$("swapCoin2PcFee"),Fn("swapPcInAmount"),Fn("swapCoinOutAmount"),$("swapPc2CoinFee"),bn("poolCoinTokenAccount"),bn("poolPcTokenAccount"),bn("coinMintAddress"),bn("pcMintAddress"),bn("lpMintAddress"),bn("ammOpenOrders"),bn("serumMarket"),bn("serumProgramId"),bn("ammTargetOrders"),bn("poolWithdrawQueue"),bn("poolTempLpTokenAccount"),bn("ammOwner"),bn("pnlOwner")]);class uo{constructor(t,n,i){this.ammId=void 0,this.id=void 0,this.label="Raydium",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.coinMint=void 0,this.pcMint=void 0,this.status=void 0,this.serumProgramId=void 0,this.serumMarket=void 0,this.ammOpenOrders=void 0,this.ammTargetOrders=void 0,this.poolCoinTokenAccount=void 0,this.poolPcTokenAccount=void 0,this.serumMarketKeys=void 0,this.coinReserve=void 0,this.pcReserve=void 0,this.feePct=void 0,this.calculator=void 0,this.ammId=t,this.id=t.toBase58();const o=ro.decode(n.data);this.status=o.status,this.coinMint=new e(o.coinMintAddress),this.pcMint=new e(o.pcMintAddress),this.poolCoinTokenAccount=new e(o.poolCoinTokenAccount),this.poolPcTokenAccount=new e(o.poolPcTokenAccount),this.serumProgramId=new e(o.serumProgramId),this.serumMarket=new e(o.serumMarket),this.ammOpenOrders=new e(o.ammOpenOrders),this.ammTargetOrders=new e(o.ammTargetOrders),this.serumMarketKeys=Object.keys(i).reduce(((t,n)=>{if(!i[n])throw new Error(`Could not find ${n} in params`);return t[n]=new e(i[n]),t}),{});const s=o.swapFeeNumerator,a=o.swapFeeDenominator;this.feePct=new ne(s.toString()).div(a.toString()),this.calculator=new A(new M(B.BigInt(s),B.BigInt(a)),P)}static decodeSerumMarketKeysString(e,t,n,i){if(!t.equals(gn))return{serumBids:e.toBase58(),serumAsks:e.toBase58(),serumEventQueue:e.toBase58(),serumCoinVaultAccount:e.toBase58(),serumPcVaultAccount:e.toBase58(),serumVaultSigner:e.toBase58()};const o=p.getLayout(t).decode(i.data),s=Ln([n.toBuffer(),o.vaultSignerNonce.toArrayLike(Buffer,"le",8)],t);return{serumBids:o.bids.toBase58(),serumAsks:o.asks.toBase58(),serumEventQueue:o.eventQueue.toBase58(),serumCoinVaultAccount:o.baseVault.toBase58(),serumPcVaultAccount:o.quoteVault.toBase58(),serumVaultSigner:s.toBase58()}}getAccountsForUpdate(){return[this.ammId,this.poolCoinTokenAccount,this.poolPcTokenAccount,this.ammOpenOrders]}update(e){const[t,n,i,o]=ft(e,this.getAccountsForUpdate()),[s,a]=[Ei(n),Ei(i)],r=l.fromAccountInfo(this.ammOpenOrders,o,o.owner),u=ro.decode(t.data);this.coinReserve=s.add(r.baseTokenTotal).sub(new X(String(u.needTakePnlCoin))),this.pcReserve=a.add(r.quoteTokenTotal).sub(new X(String(u.needTakePnlPc)))}getQuote({sourceMint:e,amount:t}){const{coinReserve:n,pcReserve:i}=this;if(!this.isTradable)throw new Error("Pool is not tradable");if(!n||!i)throw new Error("Pool token accounts balances not refreshed or empty");const o=this.coinMint.equals(e)?1:0,s=this.calculator.exchange([B.BigInt(n),B.BigInt(i)],t,o);return{notEnoughLiquidity:!1,inAmount:t,outAmount:s.expectedOutputAmount,feeAmount:s.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:s.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({raydiumAmm:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){return[zn({raydium:{}}),ti.instruction.raydiumSwap({accounts:ai(e,t,n,i)}).keys]}({raydiumAmm:this,...e})}get reserveTokenMints(){return[this.coinMint,this.pcMint]}get isTradable(){return 1===this.status||6===this.status}}const co=new O({version:"0.0.1",name:"add_decimals",instructions:[],accounts:[{name:"wrappedToken",type:{kind:"struct",fields:[{name:"decimals",type:"u8"},{name:"multiplier",type:"u64"},{name:"wrappedUnderlyingMint",type:"publicKey"},{name:"wrappedUnderlyingTokens",type:"publicKey"},{name:"wrapperMint",type:"publicKey"},{name:"nonce",type:"u8"}]}}],errors:[]},xt,Tn);class mo{constructor(e,t){this.address=void 0,this.accountInfo=void 0,this.id=void 0,this.label="Saber (Decimals)",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.wrappedToken=void 0,this.multiplierJsbi=void 0,this.address=e,this.accountInfo=t,this.id=e.toBase58(),this.wrappedToken=co.coder.accounts.decode("wrappedToken",t.data),this.multiplierJsbi=B.BigInt(this.wrappedToken.multiplier)}getAccountsForUpdate(){return new Array}update(e){}toWrappedAmount(e){return B.multiply(this.multiplierJsbi,e)}toUnderlyingAmount(e){return B.divide(e,this.multiplierJsbi)}getAmounts(e,t){if(t)return[e,this.toWrappedAmount(e)];{const t=this.toUnderlyingAmount(e);return[this.toWrappedAmount(t),t]}}getQuote({sourceMint:e,amount:t}){const n=this.wrappedToken.wrappedUnderlyingMint.equals(e),[i,o]=this.getAmounts(t,n);return{notEnoughLiquidity:!1,inAmount:i,outAmount:o,feeAmount:T,feeMint:e.toBase58(),feePct:0,priceImpactPct:0}}getSwapLegAndAccounts(e){return function({wrapper:e,wrappedToken:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,deposit:s}){return[zn(s?{saberAddDecimalsDeposit:{}}:{saberAddDecimalsWithdraw:{}}),ti.instruction.saberAddDecimals({accounts:{addDecimalsProgram:xt,wrapper:e,wrapperMint:t.wrapperMint,wrapperUnderlyingTokens:t.wrappedUnderlyingTokens,owner:o,userUnderlyingTokens:s?n:i,userWrappedTokens:s?i:n,tokenProgram:W}}).keys]}({wrapper:this.address,wrappedToken:this.wrappedToken,...e,deposit:this.wrappedToken.wrappedUnderlyingMint.equals(e.sourceMint)})}get reserveTokenMints(){return[this.wrappedToken.wrappedUnderlyingMint,this.wrappedToken.wrapperMint]}get wrapperMint(){return this.wrappedToken.wrapperMint}}class po{constructor(e){this.stableSwap=void 0,this.id=void 0,this.label="Saber",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.stableSwap=e,this.id=e.config.swapAccount.toBase58(),this.calculator=new w(v,h(this.stableSwap.state),[b,b],new M(this.stableSwap.state.fees.trade.numerator,this.stableSwap.state.fees.trade.denominator))}getAccountsForUpdate(){return[this.stableSwap.state.tokenA.reserve,this.stableSwap.state.tokenB.reserve]}update(e){const t=ft(e,this.getAccountsForUpdate());this.tokenReserveAmounts=Mt(t)}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(this.stableSwap.state.isPaused)throw new Error("Saber pool is paused");if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const i=new ne(this.stableSwap.state.fees.trade.asFraction.toFixed(4)),[o,s]=this.stableSwap.state.tokenA.mint.equals(e)?[0,1]:[1,0];this.calculator.setAmp(h(this.stableSwap.state));const a=this.calculator.exchange(this.tokenReserveAmounts,n,o,s);return{notEnoughLiquidity:!1,inAmount:n,outAmount:a.expectedOutputAmount,feeAmount:a.fees,feeMint:t.toBase58(),feePct:i.toNumber(),priceImpactPct:a.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({stableSwap:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){return[zn({saber:{}}),ti.instruction.saberSwap({accounts:ui(e,t,n,i,o)}).keys]}({stableSwap:this.stableSwap,...e})}get reserveTokenMints(){return[this.stableSwap.state.tokenA.mint,this.stableSwap.state.tokenB.mint]}}const lo=_([H(8,"discriminator"),bn("factory"),G("bump"),In("index"),bn("admin"),bn("token0Reserves"),bn("token0Mint"),bn("token0Fees"),bn("token1Reserves"),bn("token1Mint"),bn("token1Fees"),G("isPaused"),bn("poolMint"),In("tradeFeeKbps"),In("withdrawFeeKbps"),In("adminTradeFeeKbps"),In("adminWithdrawFeeKbps")]);class go{constructor(e,t){this.id=void 0,this.label="Sencha",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.calculator=void 0,this.tokenReserveAmounts=void 0,this.id=e.toBase58(),this.poolState=((e,t)=>{const n=t.owner,i=lo.decode(t.data);return{programId:n,isPaused:Boolean(i.isPaused),bump:i.bump,ammId:e,token0Reserves:i.token0Reserves,token1Reserves:i.token1Reserves,token0Mint:i.token0Mint,token1Mint:i.token1Mint,token0Fees:i.token0Fees,token1Fees:i.token1Fees,poolMint:i.poolMint,tradeFeeKbps:i.tradeFeeKbps.toNumber()}})(e,t),this.calculator=new A(new M(B.BigInt(this.poolState.tradeFeeKbps),B.BigInt(1e7)),new M(T,T),!1)}get isPaused(){return this.poolState.isPaused}getAccountsForUpdate(){return[this.poolState.token0Reserves,this.poolState.token1Reserves]}update(e){const t=ft(e,this.getAccountsForUpdate());this.tokenReserveAmounts=Mt(t)}getQuote({sourceMint:e,amount:t}){if(this.isPaused)throw new Error("Sencha pool is paused");if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const n=this.poolState.token0Mint.equals(e)?1:0;let i=this.calculator.exchange(this.tokenReserveAmounts,t,n),o=this.poolState.tradeFeeKbps/1e7;return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:o,priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({poolState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,a]=t.equals(e.token0Mint)?[e.token0Reserves,e.token1Reserves]:[e.token1Reserves,e.token0Reserves],[r,u]=t.equals(e.token0Mint)?[e.token0Fees,e.token1Fees]:[e.token1Fees,e.token0Fees];return[zn({sencha:{}}),ti.instruction.senchaSwap({accounts:{swapProgram:e.programId,tokenProgram:W,swap:e.ammId,userAuthority:o,inputUserAccount:n,inputTokenAccount:s,inputFeesAccount:r,outputUserAccount:i,outputTokenAccount:a,outputFeesAccount:u}}).keys]}({poolState:this.poolState,...e})}get reserveTokenMints(){return[this.poolState.token0Mint,this.poolState.token1Mint]}}const ho=["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS","5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z","EERNEEnBqdGzBS8dd46wwNY5F2kwnaCQ3vsq2fNKGogZ","8sFf9TW3KzxLiBXcDcjAxqabEsRroo4EiRr3UG1xbJ9m","2iDSTGhjJEiRxNaLF27CY6daMYPs5hgYrP2REHd5YD62"],So=["B2na8Awyd7cpC59iEU43FagJAPLigr3AP3s38KM982bu"];function*ko(e){const t=e.isBids;for(const{key:n,quantity:i}of e.slab.items(t)){const e=B.BigInt(n.ushrn(64).toString());yield[e,B.BigInt(i.toString())]}}function fo(e,t){const n=e._decoded.baseLotSize;return n.isZero()?new ne(0):function(e,t){const n=new ne(e.div(t).toString()),i=e.umod(t),o=i.gcd(t);return n.add(new ne(i.div(o).toString()).div(new ne(t.div(o).toString())))}(t.mul(e._decoded.quoteLotSize).mul(e._baseSplTokenMultiplier),n.mul(e._quoteSplTokenMultiplier))}class Mo{constructor(e){this.market=void 0,this.id=void 0,this.label=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this._orderbooks=void 0,this.isOpenbook=void 0,this.market=e,this.id=e.address.toBase58(),this.isOpenbook=e.programId.equals(gn),this.label=this.isOpenbook?"Openbook":"Serum"}get orderbooks(){return this._orderbooks}getAccountsForUpdate(){return[this.market.asksAddress,this.market.bidsAddress]}update(e){const[t,n]=ft(e,this.getAccountsForUpdate()),i=g.decode(this.market,t.data),o=g.decode(this.market,n.data);this._orderbooks={asks:i,bids:o}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.orderbooks)throw new Error("Failed to find orderbooks");const i=function({market:e,asks:t,bids:n,fromAmount:i,fromMint:o,toMint:s,isOpenbook:a}){const r=a?So.includes(e.address.toBase58())?1e-4:4e-4:ho.includes(e.address.toBase58())?1e-4:4e-4;return o.equals(e.quoteMintAddress)&&s.equals(e.baseMintAddress)?function(e,t,n,i){let o=T,s=T,a=T,r=T,u=T;const c=e.quoteSizeLotsToNumber(new ee(1));let m=c?B.BigInt(new ne(n.toString()).div(1+i).div(c).floor()):T;const d=B.BigInt(e.baseSizeLotsToNumber(new ee(1)).toString());for(let[e,n]of ko(t)){B.equal(s,T)&&(s=e),a=e;const t=B.multiply(n,d),i=B.multiply(n,e);if(u=B.add(u,t),B.greaterThanOrEqual(i,m)){const t=B.divide(m,e);r=B.add(r,B.multiply(e,t)),o=B.add(o,B.multiply(d,t)),m=T;break}r=B.add(r,B.multiply(e,n)),o=B.add(o,t),m=B.subtract(m,i)}let p=0;if(B.notEqual(s,T)){const e=new ne(s.toString());p=new ne(a.toString()).sub(e).div(e).toNumber()}const l=fo(e,new ee(s.toString())),g=fo(e,new ee(r.toString())),h=g.mul(d.toString()).ceil(),S=g.mul(d.toString()).mul(i).ceil();return{side:"buy",notEnoughLiquidity:B.lessThanOrEqual(u,o),minimum:{in:B.BigInt(l.mul(d.toString()).mul(1+i).ceil()),out:d},inAmount:B.BigInt(h.add(S)),outAmount:o,feeAmount:B.BigInt(S),priceImpactPct:p,feePct:i}}(e,t,i,r):function(e,t,n,i){let o=B.BigInt(0),s=B.BigInt(0),a=B.BigInt(0),r=B.BigInt(0),u=n,c=B.BigInt(0);const m=B.BigInt(e.baseSizeLotsToNumber(new ee(1))),d=B.BigInt(e.quoteSizeLotsToNumber(new ee(1)));for(const[e,n]of ko(t)){B.equal(s,T)&&(s=e),a=e;const t=B.multiply(m,n),i=B.multiply(n,B.multiply(e,d));if(r=B.add(r,t),B.greaterThanOrEqual(t,u)){const t=B.divide(u,m),n=B.multiply(t,e);o=B.add(o,B.multiply(n,d)),u=B.subtract(u,n),c=B.add(c,B.multiply(t,m));break}o=B.add(o,i),u=B.subtract(u,t),c=B.add(c,t)}let p=new ne(o.toString()).mul(1-i).floor(),l=0;const g=fo(e,new ee(s.toString()));if(B.notEqual(s,T)){const t=fo(e,new ee(a.toString()));l=g.minus(t).div(g).toNumber()}return{side:"sell",notEnoughLiquidity:B.greaterThan(B.BigInt(n),r),minimum:{in:m,out:B.BigInt(g.mul(B.toNumber(m)).mul(1-i).floor().toString())},inAmount:c,outAmount:B.BigInt(p),feeAmount:B.BigInt(new ne(o.toString()).mul(i).round()),priceImpactPct:l,feePct:i}}(e,n,i,r)}({market:this.market,asks:this.orderbooks.asks,bids:this.orderbooks.bids,fromMint:e,toMint:t,fromAmount:n,isOpenbook:this.isOpenbook});return{notEnoughLiquidity:i.notEnoughLiquidity,minInAmount:i.minimum.in,minOutAmount:i.minimum.out,inAmount:i.inAmount,outAmount:i.outAmount,feeAmount:i.feeAmount,feeMint:this.market.quoteMintAddress.toBase58(),feePct:i.feePct,priceImpactPct:i.priceImpactPct}}getSwapLegAndAccounts(e){var t;if(!e.openOrdersAddress)throw new Error("Missing open orders");return function({market:e,sourceMint:t,openOrdersAddress:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s,referrer:a,isOpenbook:r}){const{side:u,coinWallet:c,pcWallet:m}=t.equals(e.baseMintAddress)?{side:On.Ask,coinWallet:i,pcWallet:o}:{side:On.Bid,coinWallet:o,pcWallet:i};return[zn(r?jn(u):Vn(u)),ti.instruction.serumSwap({accounts:ri(e,n,i,c,m,s),remainingAccounts:a?[{pubkey:a,isSigner:!1,isWritable:!0}]:[ni]}).keys]}({market:this.market,openOrdersAddress:e.openOrdersAddress,referrer:null==e||null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(this.market.quoteMintAddress.toBase58()),isOpenbook:this.isOpenbook,...e})}get reserveTokenMints(){return[this.market.baseMintAddress,this.market.quoteMintAddress]}}Mo.getL2=ko;const Ao=_([G("version"),G("isInitialized"),G("bumpSeed"),bn("tokenProgramId"),bn("tokenAccountA"),bn("tokenAccountB"),bn("tokenPool"),bn("mintA"),bn("mintB"),bn("feeAccount"),In("tradeFeeNumerator"),In("tradeFeeDenominator"),In("ownerTradeFeeNumerator"),In("ownerTradeFeeDenominator"),In("ownerWithdrawFeeNumerator"),In("ownerWithdrawFeeDenominator"),In("hostFeeNumerator"),In("hostFeeDenominator"),G("curveType"),H(32,"curveParameters")]),yo=_([G("version"),G("isInitialized"),G("bumpSeed"),bn("tokenProgramId"),bn("tokenAccountA"),bn("tokenAccountB"),bn("tokenPool"),bn("mintA"),bn("mintB"),bn("feeAccount"),In("tradeFeeNumerator"),In("tradeFeeDenominator"),In("ownerTradeFeeNumerator"),In("ownerTradeFeeDenominator"),In("ownerWithdrawFeeNumerator"),In("ownerWithdrawFeeDenominator"),G("curveType"),H(32,"curveParameters"),G("poolNonce")]);var wo;!function(e){e[e.ConstantProduct=0]="ConstantProduct",e[e.Stable=2]="Stable"}(wo||(wo={}));class Po{constructor(t,n,i){if(this.label=void 0,this.id=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenSwapState=void 0,this.curveType=void 0,this.feePct=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.label=i,this.id=t.toBase58(),this.tokenSwapState=function(t,n){const i=n.owner,o=i.equals(Jt)?yo.decode(n.data):Ao.decode(n.data);if(!o.isInitialized)throw new Error("Invalid token swap state");const s=Ln([t.toBuffer(),Buffer.from([o.bumpSeed])],i),a=new e(o.tokenPool),r=new e(o.feeAccount),u=new e(o.tokenAccountA),c=new e(o.tokenAccountB),m=new e(o.mintA),d=new e(o.mintB);return{address:t,programId:i,tokenProgramId:new e(o.tokenProgramId),poolToken:a,feeAccount:r,authority:s,tokenAccountA:u,tokenAccountB:c,mintA:m,mintB:d,tradeFeeNumerator:o.tradeFeeNumerator,tradeFeeDenominator:o.tradeFeeDenominator,ownerTradeFeeNumerator:o.ownerTradeFeeNumerator,ownerTradeFeeDenominator:o.ownerTradeFeeDenominator,ownerWithdrawFeeNumerator:o.ownerWithdrawFeeNumerator,ownerWithdrawFeeDenominator:o.ownerWithdrawFeeDenominator,curveType:o.curveType,curveParameters:o.curveParameters,poolNonce:"poolNonce"in o?o.poolNonce:void 0}}(t,n),this.curveType=this.tokenSwapState.curveType,!(this.curveType in wo))throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);const o=Po.getFeeFraction(this.tokenSwapState.tradeFeeNumerator,this.tokenSwapState.tradeFeeDenominator),s=Po.getFeeFraction(this.tokenSwapState.ownerTradeFeeNumerator,this.tokenSwapState.ownerTradeFeeDenominator);this.calculator=this.tokenSwapState.curveType===wo.ConstantProduct?new A(o,s):new f(B.BigInt(this.tokenSwapState.curveParameters[0]),o,s),this.feePct=Po.getFeeDecimal(this.tokenSwapState.tradeFeeNumerator,this.tokenSwapState.tradeFeeDenominator).add(Po.getFeeDecimal(this.tokenSwapState.ownerTradeFeeNumerator,this.tokenSwapState.ownerTradeFeeDenominator)).toNumber()}static getFeeFraction(e,t){return new M(B.BigInt(e.toString()),B.BigInt(t.toString()))}static getFeeDecimal(e,t){return e.eq(new X(0))?new ne(0):new ne(e.toString()).div(t.toString())}getAccountsForUpdate(){return[this.tokenSwapState.tokenAccountA,this.tokenSwapState.tokenAccountB]}update(e){const t=ft(e,this.getAccountsForUpdate());this.tokenReserveAmounts=Mt(t)}getQuote({sourceMint:e,amount:t}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const n=this.reserveTokenMints[0].equals(e)?1:0,i=this.calculator.exchange(this.tokenReserveAmounts,t,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({tokenSwapState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,isStep:s}){const[a,r]=t.equals(e.mintA)?[e.tokenAccountA,e.tokenAccountB]:[e.tokenAccountB,e.tokenAccountA];return[zn(s?{step:{}}:{tokenSwap:{}}),(s?ti.instruction.stepSwap:ti.instruction.tokenSwap)({accounts:{tokenSwapProgram:e.programId,tokenProgram:W,swap:e.address,authority:e.authority,userTransferAuthority:o,source:n,swapSource:a,swapDestination:r,destination:i,poolMint:e.poolToken,poolFee:e.feeAccount}}).keys]}({tokenSwapState:this.tokenSwapState,...e,isStep:this.tokenSwapState.programId.equals(Jt)})}get reserveTokenMints(){return[this.tokenSwapState.mintA,this.tokenSwapState.mintB]}}function To(e){return e.reduce(((t,n)=>(e.forEach((e=>{n!==e&&t.push([n,e])})),t)),new Array)}const vo=B.BigInt(100);class bo{constructor(e,t,n){this.firstAmm=void 0,this.secondAmm=void 0,this.reserveTokenMints=void 0,this.market=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.portion1=0,this.portion2=0,this.firstAmm=e,this.secondAmm=t,this.reserveTokenMints=n,this.market=e instanceof Mo?e.market:t instanceof Mo?t.market:null}static getAmmIdsFromSplitTradeAmmId(e){const t=e.split("-");return t.length>1?t:[]}static create(e,t){if(!function(e,t){return!gt(mt,e.label,t.label)}(e,t))return;const n=To(e.reserveTokenMints),i=To(t.reserveTokenMints);for(const o of n)for(const n of i)if(o.every(((e,t)=>e.equals(n[t]))))return new bo(e,t,o)}setPortions(e,t){if(e+t!==100)throw new Error("Split trade portions must sum to 100");this.portion1=e,this.portion2=t}get id(){return`${this.firstAmm.id}-${this.secondAmm.id}`}get label(){return[{label:this.firstAmm.label,portion:this.portion1},{label:this.secondAmm.label,portion:this.portion2}].sort(((e,t)=>t.portion-e.portion)).map((({label:e,portion:t})=>`${e} (${t}%)`)).join(" + ")}getAccountsForUpdate(){return[]}update(e){}getQuote(e){const t=e.sourceMint.toBase58(),n=e.amount;let i={outAmount:T,portion:0,firstQuote:void 0,secondQuote:void 0};for(let t=100;t-=5;t>0){const o=B.divide(B.multiply(n,B.BigInt(t)),vo),s=B.subtract(n,o),a=this.firstAmm.getQuote({...e,amount:o}),r=this.secondAmm.getQuote({...e,amount:s}),u=B.add(a.outAmount,r.outAmount);if(B.lessThan(u,i.outAmount))break;i={outAmount:u,portion:t,firstQuote:a,secondQuote:r}}if(!i.firstQuote||!i.secondQuote)throw new Error("Unreachable: There was no better solution than getting 0 outAmount");const{outAmount:o,portion:s,firstQuote:a,secondQuote:r}=i,u=s,c=100-u;this.portion1=u,this.portion2=c;let m={amount:a.feeAmount,mint:a.feeMint},d={amount:r.feeAmount,mint:r.feeMint};m.mint!==d.mint&&(m.mint!==t&&(m={amount:B.divide(B.divide(B.multiply(m.amount,B.multiply(n,B.BigInt(u))),vo),i.outAmount),mint:t}),d.mint!==t&&(d={amount:B.divide(B.divide(B.multiply(B.multiply(d.amount,n),B.BigInt(c)),vo),i.outAmount),mint:t}));const p=(u*a.feePct+c*r.feePct)/100,l=(u*a.priceImpactPct+c*r.priceImpactPct)/100;return{notEnoughLiquidity:!1,inAmount:e.amount,outAmount:o,feeAmount:B.add(m.amount,d.amount),feeMint:m.mint,feePct:p,priceImpactPct:l}}getSwapLegAndAccounts(e){let[t,n]=this.firstAmm.getSwapLegAndAccounts(e),[i,o]=this.secondAmm.getSwapLegAndAccounts(e),s=[Hn(this.portion1,t),Hn(this.portion2,i)],a=[...n,...o];return[Qn(s),a]}}function Bo(e,t){const n=tt.parse(t);if(!n)throw new Error(`Failed to parse whirlpool ${e.toBase58()}`);return n}function Io(e,t){const n=nt.parse(t);if(!n)throw new Error(`Failed to parse tick array ${e.toBase58()}`);return n}class Fo{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Orca (Whirlpools)",this.shouldPrefetch=!0,this.exactOutputSupported=!0,this.hasDynamicAccounts=!0,this.whirlpoolData=void 0,this.tickArrays={aToB:[],bToA:[]},this.tickPks=void 0,this.oracle=void 0,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.whirlpoolData=Bo(e,t.data),this.oracle=U([Buffer.from("oracle"),e.toBuffer()],Kt)[0],this.feePct=new ne(this.whirlpoolData.feeRate).div(1e6),this.tickPks=this.getTickArrayPks()}getTickArrayPks(){const e={aToB:[],bToA:[]};return[!0,!1].forEach((t=>{e[t?"aToB":"bToA"].push(...Ze.getTickArrayPublicKeys(this.whirlpoolData.tickCurrentIndex,this.whirlpoolData.tickSpacing,t,Kt,this.address))})),e}getAccountsForUpdate(){return[this.address,...this.tickPks.aToB,...this.tickPks.bToA]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing ${this.address.toBase58()}`);this.whirlpoolData=Bo(this.address,t.data),this.tickPks=this.getTickArrayPks();const n={aToB:[],bToA:[]};[!0,!1].forEach((t=>{const i=t?"aToB":"bToA";for(const t of this.tickPks[i]){const o=t.toBase58(),s=e.get(o);if(!s)continue;const a=Io(t,s.data);n[i].push({address:t,data:a})}})),this.tickArrays=n}getQuote({sourceMint:e,amount:t,swapMode:n}){const i=!!e.equals(this.whirlpoolData.tokenMintA),o=n===kt.ExactIn,s=et({amountSpecifiedIsInput:o,aToB:i,otherAmountThreshold:Ze.getDefaultOtherAmountThreshold(o),sqrtPriceLimit:Ze.getDefaultSqrtPriceLimit(i),tickArrays:this.tickArrays[i?"aToB":"bToA"],tokenAmount:new ee(t.toString()),whirlpoolData:this.whirlpoolData}),a=B.BigInt(s.estimatedAmountIn.toString()),r=B.BigInt(s.estimatedAmountOut.toString()),u=B.BigInt(this.feePct.mul(a.toString()).floor().toString()),c=s.aToB?new ne(s.estimatedAmountOut.toString()).div(s.estimatedAmountIn.toString()):new ne(s.estimatedAmountIn.toString()).div(s.estimatedAmountOut.toString()),m=(d=this.whirlpoolData.sqrtPrice,new ne(d.toString()).mul(ne.pow(2,-64))).pow(2);var d;const p=m.minus(c).div(m).abs().toNumber();return{notEnoughLiquidity:!1,inAmount:a,outAmount:r,feeAmount:u,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:Number(p)}}getSwapLegAndAccounts(e){const t=e.sourceMint.equals(this.whirlpoolData.tokenMintA),n=e.swapMode===kt.ExactIn,{tickArray0:i,tickArray1:o,tickArray2:s}=et({amountSpecifiedIsInput:n,aToB:t,otherAmountThreshold:Ze.getDefaultOtherAmountThreshold(n),sqrtPriceLimit:Ze.getDefaultSqrtPriceLimit(t),tickArrays:this.tickArrays[t?"aToB":"bToA"],tokenAmount:new ee(e.amount.toString()),whirlpoolData:this.whirlpoolData});return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const[o,s]=e.aToB?[t,n]:[n,t];return[zn(Un(e.aToB)),ti.instruction.whirlpoolSwap({accounts:{swapProgram:Kt,tokenProgram:W,tokenAuthority:i,whirlpool:e.whirlpool,tokenOwnerAccountA:o,tokenVaultA:e.tokenVaultA,tokenOwnerAccountB:s,tokenVaultB:e.tokenVaultB,tickArray0:e.tickArray0,tickArray1:e.tickArray1,tickArray2:e.tickArray2,oracle:e.oracle}}).keys]}({additionalArgs:{aToB:t,whirlpool:this.address,tickArray0:i,tickArray1:o,tickArray2:s,oracle:this.oracle,...this.whirlpoolData},...e})}createExactOutSwapInstruction(e){const t=e.sourceMint.equals(this.whirlpoolData.tokenMintA),n=e.swapMode===kt.ExactIn,{tickArray0:i,tickArray1:o,tickArray2:s}=et({amountSpecifiedIsInput:n,aToB:t,otherAmountThreshold:Ze.getDefaultOtherAmountThreshold(n),sqrtPriceLimit:Ze.getDefaultSqrtPriceLimit(t),tickArrays:this.tickArrays[t?"aToB":"bToA"],tokenAmount:new ee(e.amount.toString()),whirlpoolData:this.whirlpoolData});return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i,outAmount:o,inAmount:s,slippageBps:a,platformFee:r,overflowFeeAccount:u}){var c;const[m,d]=e.aToB?[t,n]:[n,t];return ti.instruction.whirlpoolSwapExactOutput(o,{amount:s,slippageBps:a},e.aToB,null!==(c=null==r?void 0:r.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:Kt,tokenProgram:W,tokenAuthority:i,whirlpool:e.whirlpool,tokenOwnerAccountA:m,tokenVaultA:e.tokenVaultA,tokenOwnerAccountB:d,tokenVaultB:e.tokenVaultB,tickArray0:e.tickArray0,tickArray1:e.tickArray1,tickArray2:e.tickArray2,oracle:e.oracle},remainingAccounts:ci(null==r?void 0:r.feeAccount,u)})}({additionalArgs:{aToB:t,whirlpool:this.address,tickArray0:i,tickArray1:o,tickArray2:s,oracle:this.oracle,...this.whirlpoolData},...e,outAmount:new ee(e.amount.toString()),inAmount:new ee(e.inAmount.toString()),slippageBps:e.slippageBps,platformFee:e.platformFee,overflowFeeAccount:e.overflowFeeAccount})}get reserveTokenMints(){return[this.whirlpoolData.tokenMintA,this.whirlpoolData.tokenMintB]}}class Lo{constructor(t,n,i){this.address=void 0,this.id=void 0,this.label="Dradex",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.state=void 0,this.orderBookState=void 0,this.quoteCalculator=void 0,this.marketUser=void 0,this.address=t,this.id=t.toBase58(),this.state=it.accounts.decode("market",n.data),this.marketUser=new e(i.marketUser)}getAccountsForUpdate(){return[this.address,...this.reserveTokenMints,this.state.orderBook.bids,this.state.orderBook.asks]}update(e){const t=e.get(this.id),n=e.get(this.state.orderBook.bids.toString()),i=e.get(this.state.orderBook.asks.toString()),o=this.reserveTokenMints.map((t=>e.get(t.toString())));if(!t||!n||!i||o.find((e=>!e)))throw new Error(`One of the required accounts is missing: ${this.address.toBase58()}`);if(o.length!==this.reserveTokenMints.length)throw new Error(`Missing mint info: ${this.address.toBase58()}`);this.state=it.accounts.decode("market",t.data);const s=this.reserveTokenMints.map(((e,t)=>L(o[t].data,e)));this.orderBookState={bids:st.decode(n.data).items,asks:st.decode(i.data).items},this.quoteCalculator=new ot(this.state,this.orderBookState,s)}getQuote(e){if(!this.quoteCalculator)throw new Error(`Quote calculator is not initialized: ${this.address.toBase58()}`);const t=this.quoteCalculator.getQuote(e);return{...t,priceImpactPct:t.priceImpactPct/100}}getSwapLegAndAccounts(e){var t;return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o,sourceMint:s}){const{side:a,t0User:r,t1User:u}=s.equals(e.t0)?{side:On.Ask,t0User:t,t1User:n}:{side:On.Bid,t0User:n,t1User:t};return[zn(Xn(a)),ti.instruction.dradexSwap({accounts:{swapProgram:un,pair:e.pair,market:e.market,eventQueue:e.eventQueue,dexUser:pn,marketUser:e.marketUser,bids:e.bids,asks:e.asks,t0Vault:e.t0Vault,t1Vault:e.t1Vault,t0User:r,t1User:u,master:mn,signer:o,systemProgram:i.programId,tokenProgram:W,logger:cn},remainingAccounts:e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[ni]}).keys]}({additionalArgs:{pair:this.state.pair,market:this.address,eventQueue:this.state.eventQueue,marketUser:this.marketUser,bids:this.state.orderBook.bids,asks:this.state.orderBook.asks,t0:this.state.t0,t1:this.state.t1,t0Vault:this.state.t0Vault,t1Vault:this.state.t1Vault,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.destinationMint.toBase58())},...e})}get reserveTokenMints(){return[this.state.t0,this.state.t1]}}class Do{constructor(e,t){this.address=void 0,this.label="Raydium CLMM",this.id=void 0,this.reserveTokenMints=void 0,this.hasDynamicAccounts=!0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.programId=void 0,this.poolState=void 0,this.coder=void 0,this.tickArrayPks=void 0,this.tickArrayCache={},this.ammV3PoolInfo=void 0,this.address=e,this.id=e.toBase58(),this.address=e,this.coder=new V(at),this.poolState=this.coder.decode("poolState",t.data),this.reserveTokenMints=[this.poolState.tokenMint0,this.poolState.tokenMint1],this.programId=ln,this.tickArrayPks=rt.getTickArrayPks(this.address,this.poolState,this.programId)}getAccountsForUpdate(){return[this.address,this.poolState.ammConfig,...this.tickArrayPks]}update(e){const t=e.get(this.id);if(!t)throw new Error("Missing poolStateAccountInfo");const n=e.get(this.poolState.ammConfig.toBase58());if(!n)throw new Error("Missing ammConfigAccoutnInfo");this.poolState=this.coder.decode("poolState",t.data);const i=this.coder.decode("ammConfig",n.data);this.tickArrayPks=rt.getTickArrayPks(this.address,this.poolState,this.programId);const o={};for(const t of this.tickArrayPks){const n=e.get(t.toBase58());if(!n)continue;const i=this.coder.decode("tickArrayState",n.data);o[i.startTickIndex]={...i,address:t}}this.tickArrayCache=o,this.ammV3PoolInfo=rt.formatPoolInfo({address:this.address,poolState:this.poolState,ammConfig:i,programId:this.programId})}getQuote(e){if(e.swapMode!==kt.ExactIn)throw Error("ExactOut does not support");if(0!==this.poolState.status)throw new Error("Pool is not swapable");if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");const{amountOut:t,fee:n,priceImpact:i}=rt.computeAmountOut({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:e.sourceMint,amountIn:new ee(e.amount.toString()),slippage:0});return{notEnoughLiquidity:!1,inAmount:e.amount,outAmount:B.BigInt(t.toString()),feeAmount:B.BigInt(n.toString()),feeMint:e.sourceMint.toString(),feePct:this.ammV3PoolInfo.ammConfig.tradeFeeRate/10**6,priceImpactPct:i}}getSwapLegAndAccounts(e){if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");const{remainingAccounts:t}=rt.computeAmountOut({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:e.sourceMint,amountIn:new ee(e.amount.toString()),slippage:0}),[n,i]=e.sourceMint.equals(this.poolState.tokenMint0)?[this.poolState.tokenVault0,this.poolState.tokenVault1]:[this.poolState.tokenVault1,this.poolState.tokenVault0],o=t.shift();if(!o)throw new Error("Missing at least one tick array");return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=e.remainingAccounts.map((e=>({pubkey:e,isWritable:!0,isSigner:!1})));return o.push(ni),[zn({raydiumClmm:{}}),ti.instruction.raydiumClmmSwap({accounts:{swapProgram:ln,payer:i,ammConfig:e.ammConfig,poolState:e.poolState,inputTokenAccount:t,outputTokenAccount:n,inputVault:e.inputVault,outputVault:e.outputVault,observationState:e.observationState,tokenProgram:W,tickArray:e.tickArray},remainingAccounts:o}).keys]}({additionalArgs:{poolState:this.address,inputVault:n,outputVault:i,observationState:this.poolState.observationKey,tickArray:o,remainingAccounts:t,...this.poolState},...e})}}const qo=new O({version:"0.1.1",name:"marcopolo",instructions:[{name:"createPool",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!0},{name:"poolYAccount",isMut:!0,isSigner:!0},{name:"adminXAccount",isMut:!0,isSigner:!1},{name:"adminYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"projectOwner",isMut:!1,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"lpFee",type:{defined:"FixedPoint"}},{name:"buybackFee",type:{defined:"FixedPoint"}},{name:"projectFee",type:{defined:"FixedPoint"}},{name:"mercantiFee",type:{defined:"FixedPoint"}},{name:"initialTokenX",type:{defined:"Token"}},{name:"initialTokenY",type:{defined:"Token"}},{name:"bump",type:"u8"}]},{name:"createProvider",accounts:[{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"tokenXAmount",type:{defined:"Token"}},{name:"tokenYAmount",type:{defined:"Token"}},{name:"bump",type:"u8"}]},{name:"createState",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"nonce",type:"u8"}]},{name:"addTokens",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"deltaX",type:{defined:"Token"}},{name:"deltaY",type:{defined:"Token"}}]},{name:"withdrawBuyback",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"buybackXAccount",isMut:!0,isSigner:!1},{name:"buybackYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"swap",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"swapperXAccount",isMut:!0,isSigner:!1},{name:"swapperYAccount",isMut:!0,isSigner:!1},{name:"swapper",isMut:!0,isSigner:!0},{name:"referrerXAccount",isMut:!0,isSigner:!1},{name:"referrerYAccount",isMut:!0,isSigner:!1},{name:"referrer",isMut:!0,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"deltaIn",type:{defined:"Token"}},{name:"priceLimit",type:{defined:"FixedPoint"}},{name:"xToY",type:"bool"}]},{name:"withdrawShares",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"shares",type:{defined:"Token"}}]},{name:"withdrawLpFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"withdrawProjectFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"projectOwnerXAccount",isMut:!0,isSigner:!1},{name:"projectOwnerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"projectOwner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"createFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supply",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"createDualFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenProjectFirst",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"createTripleFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenProjectFirst",isMut:!1,isSigner:!1},{name:"tokenProjectSecond",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!0},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"supplyProjectSecond",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"withdrawRewards",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"closePool",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"buybackXAccount",isMut:!0,isSigner:!1},{name:"buybackYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"withdrawMercantiFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"mercantiXAccount",isMut:!0,isSigner:!1},{name:"mercantiYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"addSupply",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"supplyProjectSecond",type:{defined:"Token"}},{name:"duration",type:"u64"}]},{name:"updateFees",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1}],args:[{name:"newBuybackFee",type:{defined:"FixedPoint"}},{name:"newProjectFee",type:{defined:"FixedPoint"}},{name:"newProviderFee",type:{defined:"FixedPoint"}},{name:"newMercantiFee",type:{defined:"FixedPoint"}}]},{name:"resetFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]}],accounts:[{name:"farm",type:{kind:"struct",fields:[{name:"pool",type:"publicKey"},{name:"tokens",type:{array:["publicKey",3]}},{name:"tokenAccounts",type:{array:["publicKey",3]}},{name:"supply",type:{array:[{defined:"Token"},3]}},{name:"supplyLeft",type:{array:[{defined:"Token"},3]}},{name:"accumulatedSecondsPerShare",type:{defined:"FixedPoint"}},{name:"offsetSecondsPerShare",type:{defined:"FixedPoint"}},{name:"startTime",type:"u64"},{name:"endTime",type:"u64"},{name:"lastUpdate",type:"u64"},{name:"bump",type:"u8"},{name:"farmType",type:{defined:"FarmType"}}]}},{name:"pool",type:{kind:"struct",fields:[{name:"tokenX",type:"publicKey"},{name:"tokenY",type:"publicKey"},{name:"poolXAccount",type:"publicKey"},{name:"poolYAccount",type:"publicKey"},{name:"admin",type:"publicKey"},{name:"projectOwner",type:"publicKey"},{name:"tokenXReserve",type:{defined:"Token"}},{name:"tokenYReserve",type:{defined:"Token"}},{name:"selfShares",type:{defined:"Token"}},{name:"allShares",type:{defined:"Token"}},{name:"buybackAmountX",type:{defined:"Token"}},{name:"buybackAmountY",type:{defined:"Token"}},{name:"projectAmountX",type:{defined:"Token"}},{name:"projectAmountY",type:{defined:"Token"}},{name:"mercantiAmountX",type:{defined:"Token"}},{name:"mercantiAmountY",type:{defined:"Token"}},{name:"lpAccumulatorX",type:{defined:"FixedPoint"}},{name:"lpAccumulatorY",type:{defined:"FixedPoint"}},{name:"constK",type:{defined:"Product"}},{name:"price",type:{defined:"FixedPoint"}},{name:"lpFee",type:{defined:"FixedPoint"}},{name:"buybackFee",type:{defined:"FixedPoint"}},{name:"projectFee",type:{defined:"FixedPoint"}},{name:"mercantiFee",type:{defined:"FixedPoint"}},{name:"farmCount",type:"u64"},{name:"bump",type:"u8"}]}},{name:"provider",type:{kind:"struct",fields:[{name:"tokenX",type:"publicKey"},{name:"tokenY",type:"publicKey"},{name:"owner",type:"publicKey"},{name:"shares",type:{defined:"Token"}},{name:"lastFeeAccumulatorX",type:{defined:"FixedPoint"}},{name:"lastFeeAccumulatorY",type:{defined:"FixedPoint"}},{name:"lastSecondsPerShare",type:{defined:"FixedPoint"}},{name:"lastWithdrawTime",type:"u64"},{name:"tokensOwedX",type:{defined:"Token"}},{name:"tokensOwedY",type:{defined:"Token"}},{name:"currentFarmCount",type:"u64"},{name:"bump",type:"u8"}]}},{name:"state",type:{kind:"struct",fields:[{name:"admin",type:"publicKey"},{name:"programAuthority",type:"publicKey"},{name:"bump",type:"u8"},{name:"nonce",type:"u8"}]}}],types:[{name:"FixedPoint",type:{kind:"struct",fields:[{name:"v",type:"u128"}]}},{name:"Token",type:{kind:"struct",fields:[{name:"v",type:"u64"}]}},{name:"Product",type:{kind:"struct",fields:[{name:"v",type:"u128"}]}},{name:"FarmType",type:{kind:"enum",variants:[{name:"Single"},{name:"Dual"},{name:"Triple"}]}}],errors:[{code:6e3,name:"DeltaTooBig",msg:"Delta greater than provider's tokens"},{code:6001,name:"TokenUnderflow",msg:"Token amount underflow"},{code:6002,name:"WrongRatio",msg:"Wrong tokens ratio"},{code:6003,name:"TooMuchShares",msg:"Too much shares provided"},{code:6004,name:"SwapToBig",msg:"Swap too big"},{code:6005,name:"FeeExceeded",msg:"Fee exceeded 100%"},{code:6007,name:"ScalesNotEqual",msg:"Scales have to be equal"},{code:6008,name:"FeeExceededDeltaOut",msg:"Fees exceeded delta_out"},{code:6009,name:"PriceLimitExceeded",msg:"Price limit exceeded"},{code:6010,name:"MintMismatch",msg:"Mint mismatch"},{code:6011,name:"TokensAreTheSame",msg:"Tokens are the same"},{code:6012,name:"WrongFarm",msg:"Cannot add supply to wrong farm"},{code:6013,name:"RewardsExceedingSupply",msg:"Cannot withdraw rewards exceeding supply left"},{code:6014,name:"FarmNotEnded",msg:"Farm has not ended, cannot add additional rewards"},{code:6015,name:"ZeroAmount",msg:"Must provide a nonzero amount"},{code:6016,name:"InvariantChanged",msg:"Invariant has changed"}],metadata:{address:"9tKE7Mbmj4mxDjWatikzGAtkoWosiiZX9y6J4Hfm2R8H"}},hn,Tn),xo=new ne(10).pow(12);class Eo{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Marco Polo",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.pool=void 0,this.calculator=void 0,this.feePct=void 0,this.tokenReserveAmounts=void 0,this.address=e,this.id=e.toBase58(),this.pool=this.decodePoolState(t);const n=this.pool.lpFee.v.add(this.pool.buybackFee.v).add(this.pool.mercantiFee.v).add(this.pool.projectFee.v);this.feePct=new ne(n.toString()).div(xo),this.calculator=new A(new M(B.BigInt(n),B.BigInt(xo)),P,!1)}decodePoolState(e){return qo.coder.accounts.decode("pool",e.data)}getAccountsForUpdate(){return[this.address]}update(e){const t=e.get(this.id);if(!t)throw new Error(`Pool account info is not found: ${this.id}`);const n=this.decodePoolState(t);this.pool=n,this.tokenReserveAmounts=[B.BigInt(n.tokenXReserve.v),B.BigInt(n.tokenYReserve.v)]}getQuote({destinationMint:e,amount:t}){const{tokenX:n}=this.pool;if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const i=e.equals(n)?0:1,o=this.calculator.exchange(this.tokenReserveAmounts,t,i);return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){var t,n;return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o,sourceMint:a}){const r=a.equals(e.tokenX),{swapperXAccount:u,swapperYAccount:c}=r?{swapperXAccount:t,swapperYAccount:n}:{swapperXAccount:n,swapperYAccount:t};return[zn(Wn(r)),ti.instruction.marcoPoloSwap({accounts:{swapProgram:hn,state:Sn,pool:e.pool,tokenX:e.tokenX,tokenY:e.tokenY,poolXAccount:e.poolXAccount,poolYAccount:e.poolYAccount,swapperXAccount:u,swapperYAccount:c,swapper:o,referrerXAccount:e.referrerXAccount,referrerYAccount:e.referrerYAccount,referrer:Ft,programAuthority:kn,systemProgram:i.programId,tokenProgram:W,associatedTokenProgram:Y,rent:s}}).keys]}({additionalArgs:{pool:this.address,tokenX:this.pool.tokenX,tokenY:this.pool.tokenY,poolXAccount:this.pool.poolXAccount,poolYAccount:this.pool.poolYAccount,referrerXAccount:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(this.pool.tokenX.toBase58()),referrerYAccount:null===(n=e.quoteMintToReferrer)||void 0===n?void 0:n.get(this.pool.tokenY.toBase58())},...e})}get reserveTokenMints(){return[this.pool.tokenX,this.pool.tokenY]}}Eo.getProgram=()=>qo;const Oo=({amms:e,asLegacyTransaction:t,isSplit:n})=>{if(t){if(e.length>2)return!1;const[t,i]=e;return n?!gt(dt,t.label,i.label):!gt(pt,t.label,i.label)}return!0},Vo=new Map([[_t.toString(),"Orca"],[Gt.toString(),"Orca"],[Jt.toString(),"Step"],[$t.toString(),"Penguin"],[Zt.toString(),"Saros"],[Ht.toString(),"Stepn"]]);function Co(t,n,i){const o=new e(n.owner);if(o.equals(Pt)||o.equals(Tt)||o.equals(gn)){const e=p.getLayout(o).decode(n.data);if(!e.accountFlags.initialized||!e.accountFlags.market)throw new Error("Invalid market");const t=new p(e,0,0,{},o);return new Mo(t)}if(o.equals(Lt))return new uo(t,n,i);if(o.equals(Ut))return new to(t,n,i);if(o.equals(S)){const e=n.data.slice(2,3),i=k.loadWithData(t,n.data,Ln([t.toBuffer(),e],S));if(!i.state.isInitialized)return;return new po(i)}if(o.equals(xt))return new mo(t,n);if(o.equals(Ct))return new vi(t,n,i);if(o.equals(Dt)||o.equals(qt))return new fi(t,n,i);if([...Vo.keys()].includes(o.toBase58())){var s;const e=null!==(s=Vo.get(n.owner.toBase58()))&&void 0!==s?s:"Unknown";return new Po(t,n,e)}return o.equals(Et)?new bi(t,n,i):o.equals(Ot)?new go(t,n):o.equals(Vt)?new Ki(t,n):o.equals(dn)?new Xi(t,n):o.equals(Kt)?new Fo(t,n):o.equals(Yt)?new Li(t,n):o.equals(zt)?new _i(t,n):o.equals(en)?new ao(t,n,i):o.equals(sn)?new Ci(t,n):o.equals(Xt)?new Ui(t,n):o.equals(un)?new Lo(t,n,i):o.equals(rn)?new Pi(t,n):o.equals(ln)?new Do(t,n):o.equals(hn)?new Eo(t,n):void 0}class Ro{constructor(e,t){this.connection=void 0,this.ammIdToAddressLookupTable=void 0,this.ammIdToAddressLookupTableAccount=new Map,this.connection=e,this.ammIdToAddressLookupTable=t}async getAdressLookupTableAccounts(t){const n=new Map,i=[...t.reduce(((e,t)=>{const i=this.ammIdToAddressLookupTableAccount.get(t);if(i){const e=i.key.toBase58();n.has(e)||n.set(e,t)}else{const i=this.ammIdToAddressLookupTable.get(t);i&&(e.add(i),n.set(t,i))}return e}),new Set)];return(await St(this.connection,i)).reduce(((t,o,s)=>{const a=i[s];if(o){const i=new r({key:new e(a),state:r.deserialize(o.data)});t.push(i);const s=n.get(a);s&&this.ammIdToAddressLookupTableAccount.set(s,i)}return t}),new Array)}}class No{constructor(e){this.ammIdToAddressLookupTableAccount=void 0,this.ammIdToAddressLookupTableAccount=e}static async load(t,n){const i=[...n.entries()],o=await St(t,i.map((([e,t])=>t))),s=new Map;for(const[t,n]of o.entries()){const[o,a]=i[t];n&&s.set(o,new r({key:new e(a),state:r.deserialize(n.data)}))}return new No(s)}getAdressLookupTableAccounts(e){const t=new Set,n=e.reduce(((e,n)=>{const i=this.ammIdToAddressLookupTableAccount.get(n);if(i){const n=i.key.toBase58();t.has(n)||(e.push(i),t.add(n))}return e}),new Array);return Promise.resolve(n)}}async function Uo(e,t,n){const i=t.reduce(((e,t)=>{var n;const i=null==t||null===(n=t.params)||void 0===n?void 0:n.addressLookupTableAddress;return i&&e.set(t.pubkey,i),e}),new Map);return n?await No.load(e,i):new Ro(e,i)}const Ko={};function Xo(e){const t=e._bn.toString(),n=Ko[t];if(n)return n;{const n=e.toBase58();return Ko[t]=n,n}}function jo(e){const t=new Map;return e.forEach((e=>{To(e.reserveTokenMints).forEach((([n,i])=>{!function(e,t,n,i){let o=i.get(e);o||(o=new Map([[t,[]]]),i.set(e,o));let s=o.get(t);s||(s=[],o.set(t,s)),s.push(n)}(Xo(n),Xo(i),e,t)}))})),t}function Wo(e,t,n){return Boolean(e&&t>100&&!e.has(n))}function Yo(e,t){if(e===kt.ExactOut)return!1;if(t.length>1){const[e,n]=t;if(e instanceof uo&&n instanceof uo)return!1}return!0}function Qo(e){return e.marketInfos.map((e=>`${e.amm.id}-${e.inputMint}`)).join("-")}async function zo({connection:t,marketInfos:n,owner:i,unwrapSOL:o}){const s=await Promise.all(n.map((({outputMint:n})=>async function({connection:t,payer:n,owner:{publicKey:i},mintAddress:o,unwrapSOL:s}){const a="string"==typeof o?new e(o):o,r=Zn({tokenMintAddress:a,walletAddress:i}),u={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},c=await t.getAccountInfo(r);if(null===c)u.setupInstructions.push($n(n,r,i,a));else{const e=F(c.data);if(e&&!e.owner.equals(i))throw new Error(`/! ATA ${r.toBase58()} is not owned by ${i.toBase58()}`)}return a.equals(wt)&&s&&u.cleanupInstructions.push(j.createCloseAccountInstruction(W,r,i,i,[])),{address:r,...u}}({connection:t,payer:i.publicKey,owner:i,mintAddress:n,unwrapSOL:o})))),[a]=s.splice(s.length-1,1);return{userIntermediaryTokenAccountResults:s,userDestinationTokenAccountResult:a}}async function Ho(e,t,n,o){const a={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},r=n.address.toString();if(o){let t=o.get(r);if(t){let n=null;if(n=await e.getAccountInfo(t,"confirmed"),n)return{...a,address:t}}}const[u,c]=function(e,t){const[n]=U([Buffer.from("open_orders"),e.publicKey.toBuffer(),t.toBuffer()],ei);return[n,ti.instruction.createOpenOrders({accounts:{openOrders:n,payer:t,dexProgram:e.programId,systemProgram:i.programId,rent:s,market:e.publicKey}})]}(n,t);return await e.getAccountInfo(u)||(a.setupInstructions=[c]),null==o||o.set(n.address.toString(),u),{...a,address:u}}function _o(e){return e.reduce(((e,t)=>t+e),0)}const Go={feeBps:0,feeAccounts:new Map};async function Jo(e,t){return(await e.getTokenAccountsByOwner(t,{programId:W})).value.reduce(((e,t)=>{const n=F(t.account.data);return n&&e.set(n.mint.toBase58(),t.pubkey),e}),new Map)}const $o=e=>new Promise((t=>setTimeout(t,e)));function Zo(e,t,n){if(!e)return;const i=t.get(n.toBase58());return void 0!==i?function(e,t){var n,i,o,s;const a=null===(n=t.postTokenBalances)||void 0===n||null===(i=n.find((t=>t.accountIndex===e)))||void 0===i?void 0:i.uiTokenAmount.amount,r=null===(o=t.preTokenBalances)||void 0===o||null===(s=o.find((t=>t.accountIndex===e)))||void 0===s?void 0:s.uiTokenAmount.amount;if(a)return Math.abs(parseInt(a)-(void 0!==r?parseInt(r):0))}(i,e):void 0}function es(e,t,n){const i=t.get(n.toBase58());return void 0!==i?Math.abs(e.postBalances[i]-e.preBalances[i]):0}function ts(){return(new Date).getTime()}const ns={skipPreflight:!0,maxRetries:2};async function is(e,t,n=12e4,i=500,o=2e3,s=40){const a=t.serialize(),r=await e.sendRawTransaction(a,ns),u=ts();let c=ts(),m=0;for(;ts()-u<n;){const t=ts();m<s&&t-c>o&&(c=t,m+=1,await e.sendRawTransaction(a,ns));const n=await Promise.any([e.getTransaction(r,{commitment:"confirmed",maxSupportedTransactionVersion:0}),$o(5e3)]);if(n)return{txid:r,transactionResponse:n};await $o(i)}return{txid:r,transactionResponse:null}}function os(e){const t="signature"in e?e.signature:e.signatures[0];if(!t)throw new Error("Transaction has no signature");return ct.encode(t)}function ss(e,t){return"message"in e?e.sign(t):e.sign(...t),os(e)}class as{constructor(e,t,n){this.connection=void 0,this.feePayer=void 0,this.instructions=void 0,this.owner=void 0,this.connection=e,this.feePayer=t,this.instructions=[],this.owner=n}addInstruction(e){return this.instructions.push(e),this}async build(e,t,n){let i=[],o=[],s=[],a=[];this.instructions.forEach((e=>{o=o.concat(e.setupInstructions),i=i.concat(e.instructions),s=s.concat(e.cleanupInstructions),a=a.concat(e.signers)}));const r=o.concat(i).concat(s),c=n?this.buildLegacyTransaction({transactionInstructions:r,blockhashWithExpiryBlockHeight:e}):this.buildVersionedTransaction({transactionInstructions:r,blockhashWithExpiryBlockHeight:e,addressLookupTables:t});return{transaction:c,signers:a,execute:this.owner.isKeyPair?()=>{const t=ss(c,[this.owner.signer,...a]),n=c.serialize();return u(this.connection,Buffer.from(n),{signature:t,...e})}:async()=>{throw new Error("Please use a Keypair for the owner parameter to enable the execute function")}}}buildLegacyTransaction({transactionInstructions:e,blockhashWithExpiryBlockHeight:t}){return new c({feePayer:this.feePayer,...t}).add(...e)}buildVersionedTransaction({transactionInstructions:e,blockhashWithExpiryBlockHeight:t,addressLookupTables:n}){const i=new m({payerKey:this.feePayer,instructions:e,recentBlockhash:t.blockhash}).compileToV0Message(n);return new d(i)}}class rs{constructor(e){this._owner=void 0,this._owner=e}get publicKey(){return rs.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return rs.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return rs.isKeyPair(this._owner)}get isPublicKey(){return rs.isPublicKey(this._owner)}static isKeyPair(e){return void 0!==e.secretKey}static isPublicKey(e){return!rs.isKeyPair(e)}}const us=function(e){if(!Array.isArray(e))throw new TypeError(`Argument must be an array: ${e}`)},cs=function(e,t){return e*t.length},ms={},ds=function(e,t){return String(t)},ps=B.BigInt(1e4);function ls({inputMint:e,outputMint:t}){return`${e}-${t}`}function gs({ammId:e,amount:t}){return`${e}-${t.toString()}`}async function hs({inputRouteSegment:t,inputMint:n,outputMint:i,amount:o,getDepositAndFeeForRoute:s,platformFeeBps:a,slippageBps:r,filterTopNResult:u=1,onlyDirectRoutes:c,swapMode:m,asLegacyTransaction:d}){const p=n.toBase58(),l=i.toBase58();if(!t.get(p))throw new Error("No routes found for the input and output mints");const g=c?1:d?2:3,h=new Map,S=[],k=new Map;return function o({startMint:s,amount:a,level:r=1,walked:p=[s]}){const f=t.get(s);f&&f.forEach(((M,A)=>{const y=ls({inputMint:s,outputMint:A}),w=function({amms:t,inputMint:n,outputMint:i,amount:o,swapMode:s}){return t.map((t=>{try{return{quote:t.getQuote({amount:o,sourceMint:new e(n),destinationMint:new e(i),swapMode:s}),amm:t}}catch(e){return}})).filter(Boolean).sort(((e,t)=>B.greaterThanOrEqual((null==t?void 0:t.quote.outAmount)||T,(null==e?void 0:e.quote.outAmount)||T)?1:-1))}({amms:M,inputMint:s,outputMint:A,amount:a,swapMode:m}),{filteredAmms:P,quoteMap:v}=w.reduce(((e,t)=>(e.filteredAmms.length<u&&e.filteredAmms.push(t.amm),e.quoteMap.set(gs({ammId:t.amm.id,amount:a}),t.quote),e)),{filteredAmms:[],quoteMap:new Map});if(1===r&&A===l&&!c){let e=!1;!function(e,t){for(let n=0;n<e.length;n++)for(let i=n+1;i<e.length;i++)e[n].label!==e[i].label&&t(e[n],e[i])}(w.slice(0,Math.max(d?3:2,u)).map((({amm:e})=>e)),((t,o)=>{if(wn&&e)return;const s=(()=>{if(Oo({amms:[t,o],asLegacyTransaction:d,isSplit:!0}))return bo.create(t,o)})();s&&(e=!0,S.push({amms:[s],mints:[n,i]}))}))}if(f.set(A,P),h.set(y,v),A!==l&&v.size&&!p.includes(A)&&r<g){var b;const e=v.values().next().value.outAmount,t=null!==(b=k.get(A))&&void 0!==b?b:T;(yn||B.greaterThan(e,t))&&(k.set(A,e),o({startMint:A,amount:e,level:r+1,walked:p.concat(A)}))}else if(A===l){1===r&&f.set(A,M);const n=p.concat(A),i=n.map((t=>new e(t))),o=n.reduce(((e,i,o)=>{var s;return o<n.length-1&&e.push(null===(s=t.get(n[o]))||void 0===s?void 0:s.get(n[o+1])),e}),[]),s=function(e){if(function(e){if(!Array.isArray(e))throw new TypeError("Argument must be an array of arrays");e.forEach(us),function({length:e}){if(e>=100)throw new TypeError(`Too many arrays (${e}): please use the 'big-cartesian' library instead of 'fast-cartesian'`)}(e),function(e){const t=e.reduce(cs,1);if(t>=4294967296){const e=Number.isFinite(t)?` (${t.toExponential(0)})`:"";throw new TypeError(`Too many combinations${e}: please use the 'big-cartesian' library instead of 'fast-cartesian'`)}}(e)}(e),0===e.length)return[];const t=[];return function(e){const t=ms[e];if(void 0!==t)return t;const n=function(e){const t=Array.from({length:e},ds),n=t.map((e=>`for (const value${e} of arrays[${e}]) {`)).join("\n"),i=t.map((e=>`value${e}`)).join(", "),o="}\n".repeat(e);return new Function("arrays","result",`${n}\nresult.push([${i}])\n${o}`)}(e);return ms[e]=n,n}(e.length)(e,t),t}(o);for(let e of s)(1===e.length||Oo({amms:e,asLegacyTransaction:d}))&&S.push({amms:e,mints:i})}}))}({startMint:p,amount:o}),S.map((e=>{const{amms:t,mints:n}=e;let i=[],u=o,c=T;const d=Yo(m,t),p=n,l=t.length;for(const[e,n]of t.entries())try{var g;const t=p[e],s=p[e+1],S=ls({inputMint:t.toBase58(),outputMint:s.toBase58()}),k=null===(g=h.get(S))||void 0===g?void 0:g.get(gs({ammId:n.id,amount:u}));if(B.equal(u,T))return;const f=k||n.getQuote({sourceMint:t,destinationMint:s,amount:u,swapMode:m}),M=l-1===e&&d?{amount:B.divide(B.multiply(f.outAmount,B.BigInt(a)),ps),mint:s.toBase58(),pct:a/100}:{amount:T,mint:s.toBase58(),pct:0},A=m===kt.ExactIn?f.outAmount:f.inAmount;let y=m===kt.ExactIn?B.subtract(A,M.amount):B.add(A,M.amount);B.lessThan(y,T)&&(y=T);const w=B.BigInt(m===kt.ExactIn?new ne(y.toString()).mul(1-r/B.toNumber(ps)).ceil():new ne(y.toString()).mul(1+r/B.toNumber(ps)).floor()),[P,v]=m===kt.ExactIn?[f.inAmount,y]:[y,u];i.push({amm:n,inputMint:t,outputMint:s,notEnoughLiquidity:f.notEnoughLiquidity,minInAmount:f.minInAmount,minOutAmount:f.minOutAmount,inAmount:P,outAmount:v,priceImpactPct:f.priceImpactPct,lpFee:{amount:f.feeAmount,mint:f.feeMint,pct:f.feePct},platformFee:M}),u=m===kt.ExactIn?y:o,c=w}catch(e){return}return{marketInfos:i,getDepositAndFee:()=>s({marketInfos:i}),inAmount:i[0].inAmount,outAmount:u,amount:o,otherAmountThreshold:c,swapMode:m,slippageBps:r,priceImpactPct:1-i.reduce(((e,t)=>e*(1-t.priceImpactPct)),1)}})).filter((e=>void 0!==e)).sort(((e,t)=>B.greaterThanOrEqual(t.outAmount,e.outAmount)?1:-1))}const Ss=Object.values(Mn).reduce(((e,t)=>(e[t.code]=t,e)),{});function ks(e,t){let n=t.get(e);return void 0===n&&(n=t.size,t.set(e,n)),n}function fs(e){const{mintToIndexMap:t,indexedRouteMap:n}=Array.from(e).reduce((({mintToIndexMap:e,indexedRouteMap:t},[n,i])=>{const o=ks(n,e),s=[];for(const t of i){const n=ks(t,e);s.push(n)}return t[o]=s,{mintToIndexMap:e,indexedRouteMap:t}}),{mintToIndexMap:new Map,indexedRouteMap:{}});return{mintKeys:[...t.keys()],indexedRouteMap:n}}function Ms(e){const t=t=>e.mintKeys[t],n=new Map;return Object.keys(e.indexedRouteMap).forEach((i=>{n.set(t(i),e.indexedRouteMap[i].map((e=>t(e))))})),n}async function As({onlyDirectRoutes:e,restrictIntermediateTokens:t,asLegacyTransaction:n},i){let o=i||"https://cache.jup.ag/indexed-route-maps-v2";return e?o=o.concat("?onlyDirectRoutes=true"):t&&(o=o.concat("?restrictIntermediateTokens=true")),n&&(o=o.concat("?asLegacyTransaction=true")),Ms(await(await fetch(o)).json())}class ys{constructor(e,t,n,i,o,s,a=0,r=!0,u,c,m){this.connection=void 0,this.cluster=void 0,this.tokenRouteSegments=void 0,this.feeCalculator=void 0,this.platformFeeAndAccounts=void 0,this.quoteMintToReferrer=void 0,this.routeCacheDuration=void 0,this.wrapUnwrapSOL=void 0,this.intermediateTokens=void 0,this.shouldLoadSerumOpenOrders=void 0,this.addressLookupTableProvider=void 0,this.serumOpenOrdersPromise=void 0,this.user=void 0,this.routeCache=new Map,this.routeSegmentCache=new Map,this.getDepositAndFees=async({marketInfos:e,userPublicKey:t,serumOpenOrdersPromise:n=Promise.resolve(new Map)})=>(async({connection:e,owner:t,inputMint:n,marketInfos:i,feeCalculator:o,serumOpenOrdersPromise:s,wrapUnwrapSOL:a})=>{const r=await Promise.all(i.map((async n=>{const i=n.amm;if(i instanceof Mo||i instanceof bo){if(!i.market)return;return await Ho(e,t.publicKey,i.market,await s)}}))),{userIntermediaryTokenAccountResults:u,userDestinationTokenAccountResult:c}=await zo({connection:e,marketInfos:i,owner:t,unwrapSOL:a});return(({intermediates:e,destination:t,openOrders:n,hasWrapUnwrapSOL:i,feeCalculator:o})=>{const s=n.filter((e=>e&&e.setupInstructions.length>0)).map((()=>23352760)),a=[...e,t].filter((e=>(null==e?void 0:e.setupInstructions.length)&&0===e.cleanupInstructions.length)).map((()=>2039280)),r=o.lamportsPerSignature;return{signatureFee:r,openOrdersDeposits:s,ataDeposits:a,totalFeeAndDeposits:_o([r,...s,...a]),minimumSOLForTransaction:_o([r,...s,...a,i?2039280:0])}})({intermediates:u,destination:c,openOrders:r,hasWrapUnwrapSOL:!!a&&[n,...i.map((e=>e.outputMint))].some((e=>e.equals(wt))),feeCalculator:o})})({connection:this.connection,feeCalculator:this.feeCalculator,inputMint:e[0].inputMint,marketInfos:e,serumOpenOrdersPromise:n,owner:new rs(t),wrapUnwrapSOL:this.wrapUnwrapSOL}),this.getDepositAndFeesForUser=({marketInfos:e})=>{if(this.user&&this.serumOpenOrdersPromise){const t=new rs(this.user);return this.getDepositAndFees({marketInfos:e,userPublicKey:t.publicKey,serumOpenOrdersPromise:this.serumOpenOrdersPromise})}return Promise.resolve(void 0)},this.exchange=async({routeInfo:e,userPublicKey:t,feeAccount:n,wrapUnwrapSOL:i,blockhashWithExpiryBlockHeight:o,asLegacyTransaction:s})=>{var a;const{connection:r,serumOpenOrdersPromise:u}=this,c=t||this.user;if(!c)throw new Error("user not found");const m=new rs(c),d=e.marketInfos.length-1,p=e.marketInfos[0].inputMint,l=e.marketInfos[d].outputMint,g=null!=i?i:this.wrapUnwrapSOL,[h,S,k]=await Promise.all([p.equals(wt)&&g?Jn({connection:r,owner:m,amount:e.swapMode===kt.ExactIn?e.amount:e.otherAmountThreshold}):{setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[],address:Zn({tokenMintAddress:p,walletAddress:m.publicKey})},zo({connection:r,marketInfos:e.marketInfos,owner:m,unwrapSOL:g}),Promise.all(e.marketInfos.map((async({amm:e})=>{if(e instanceof Mo||e instanceof bo){if(!e.market)return;return await Ho(r,m.publicKey,e.market,await u)}})))]),f={intermediates:S.userIntermediaryTokenAccountResults,destination:S.userDestinationTokenAccountResult,openOrders:k},M=f.openOrders.filter(Boolean).length>0,A=(n=null!==(a=n)&&void 0!==a?a:this.platformFeeAndAccounts.feeAccounts.get(e.swapMode===kt.ExactIn?l.toBase58():p.toBase58()))?{feeBps:this.platformFeeAndAccounts.feeBps||Math.floor(100*e.marketInfos[d].platformFee.pct),feeAccount:n}:void 0,{instruction:y}=await async function({user:e,openOrdersAddresses:t,userSourceTokenAccountAddress:n,userIntermediateTokenAccountAddresses:i,userDestinationTokenAccountAddress:o,routeInfo:s,platformFee:a,quoteMintToReferrer:r}){if(s.marketInfos.length-1!==i.length)throw new Error("Missing intermediary token account address");const u=[n,...i,o],c=!!a&&a.feeBps>0&&Yo(s.swapMode,s.marketInfos.map((e=>e.amm))),m=e.publicKey,d=[Gn(14e5)],p=[];if(s.swapMode===kt.ExactIn){const e=function(e,t,n,i,o,s,a,r){const u=[],c=[];for(const[t,i]of e.marketInfos.entries()){const r=i.amm,[m,d]=o.slice(t),[p,l]=r.getSwapLegAndAccounts({sourceMint:i.inputMint,destinationMint:i.outputMint,userSourceTokenAccount:m,userDestinationTokenAccount:d,userTransferAuthority:n,openOrdersAddress:s[t],quoteMintToReferrer:a,swapMode:e.swapMode,amount:i.inAmount});u.push(p),c.push(...l)}return t&&r&&c.push({pubkey:r.feeAccount,isWritable:!0,isSigner:!1}),{swapInstruction:ii(n,i,Yn(u),c,new te(e.amount.toString()),new te(e.outAmount.toString()),e.slippageBps,t&&r?r.feeBps:0)}}(s,c,m,o,u,t,r,a),{swapInstruction:n}=e;p.push(n)}else if(s.swapMode===kt.ExactOut){const{swapInstruction:e}=function(e,t,n,i,o,s){const a=e.marketInfos[0],r=a.amm;if(r.createExactOutSwapInstruction)return{swapInstruction:r.createExactOutSwapInstruction({sourceMint:a.inputMint,destinationMint:a.outputMint,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:t,quoteMintToReferrer:o,swapMode:e.swapMode,amount:e.amount,slippageBps:e.slippageBps,inAmount:e.inAmount,platformFee:s,overflowFeeAccount:null==o?void 0:o.get(a.inputMint.toBase58())})};throw new Error(`ExactOutInstruction missing for ${r.label}.`)}(s,m,n,o,r,a);p.push(e)}const{signers:l,cleanupInstructions:g}={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]};return e.isKeyPair&&e.signer&&l.push(e.signer),{instruction:{setupInstructions:d,signers:l,cleanupInstructions:g,instructions:p}}}({user:m,openOrdersAddresses:f.openOrders.map((e=>null==e?void 0:e.address)),userSourceTokenAccountAddress:h.address,userIntermediateTokenAccountAddresses:f.intermediates.map((({address:e})=>e)),userDestinationTokenAccountAddress:f.destination.address,routeInfo:e,platformFee:A,quoteMintToReferrer:this.quoteMintToReferrer,asLegacyTransaction:s}),w=new as(r,m.publicKey,m),P=[...f.intermediates,h,!f.destination.address.equals(h.address)&&f.destination];w.addInstruction(y),M&&f.openOrders.forEach((e=>{e&&w.addInstruction(e)})),P.forEach((e=>{e&&w.addInstruction(e)})),o=o||await this.connection.getLatestBlockhash("confirmed");const T=await this.addressLookupTableProvider.getAdressLookupTableAccounts(e.marketInfos.map((e=>e.amm.id))),{transaction:v}=await w.build(o,T,s),b=f;return{swapTransaction:v,addressLookupTableAccounts:T,execute:({wallet:e,onTransaction:t}={})=>ws({connection:this.connection,wallet:e,onTransaction:t,inputMint:p,outputMint:l,sourceAddress:h.address,destinationAddress:b.destination.address,swapTransaction:v,wrapUnwrapSOL:g,owner:m}).finally((()=>{this.routeCache.clear()}))}},this.connection=e,this.cluster=t,this.tokenRouteSegments=n,this.feeCalculator=i,this.platformFeeAndAccounts=o,this.quoteMintToReferrer=s,this.routeCacheDuration=a,this.wrapUnwrapSOL=r,this.intermediateTokens=u,this.shouldLoadSerumOpenOrders=c,this.addressLookupTableProvider=m}static async load({connection:t,cluster:n,user:i,platformFeeAndAccounts:o=Go,quoteMintToReferrer:s,routeCacheDuration:a=0,wrapUnwrapSOL:r=!0,marketUrl:u,restrictIntermediateTokens:c=!1,shouldLoadSerumOpenOrders:m=!0,ammsToExclude:d={GooseFX:!0,Serum:!0},usePreloadedAddressLookupTableCache:p=!1}){const[{tokenRouteSegments:l,addressLookupTableProvider:g,saberWrapperMints:h},{value:{feeCalculator:S}},k]=await Promise.all([ys.fetchAmms(t,n,d,u,p).then((({amms:e,saberWrapperMints:t,addressLookupTableProvider:n})=>({tokenRouteSegments:jo(e),addressLookupTableProvider:n,saberWrapperMints:t}))),t.getRecentBlockhashAndContext("processed"),null!=s?s:Jo(t,new e(Nt))]),f=c?await ys.getIntermediateTokens(h):void 0,M=new ys(t,n,l,S,o,k,a,r,f?new Set(f):void 0,m,g);return i&&M.setUserPublicKey(i),M}getAccountToAmmIdsMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{t.getAccountsForUpdate().forEach((n=>{const i=e.get(n.toBase58())||new Set;i.add(t.id),e.set(n.toBase58(),i)}))}))}))})),e}getAmmIdToAmmMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{e.set(t.id,t)}))}))})),e}async computeRoutes({inputMint:e,outputMint:t,amount:n,slippageBps:i,feeBps:o=0,forceFetch:s,onlyDirectRoutes:a,swapMode:r=kt.ExactIn,filterTopNResult:u,asLegacyTransaction:c}){const m=e.toBase58(),d=t.toBase58(),p=o||(this.platformFeeAndAccounts.feeAccounts.get(d)?this.platformFeeAndAccounts.feeBps:0),l=(new Date).getTime(),g=[m,d].sort(((e,t)=>e.localeCompare(t))).join()+a+r+c,h=this.routeCache.get(g);let S=this.routeSegmentCache.get(g);S||(S=function({inputMint:e,outputMint:t,tokenRouteSegments:n,swapMode:i,intermediateTokens:o,onlyDirectRoutes:s,asLegacyTransaction:a}){const r=new Map,u=n.get(e),c=n.get(t);if(u&&c){const d=Math.min(u.size,c.size),p=new Map,l=new Map,[g,h,S,k]=[u,c,e,t];for(let[e,t]of g.entries()){if(t=i===kt.ExactIn?t.slice():t.filter((e=>e.exactOutputSupported)),e===k){const e=t;p.set(k,e),l.set(S,e);continue}if(s||i===kt.ExactOut||Wo(o,d,e))continue;let u=n.get(e)||new Map;for(let[n,i]of u){if(i=i.slice(),n===k){const n=i;if(r.set(e,new Map([[S,t],[k,n]])),p.set(e,t),l.set(e,n),a)break}if(!a){var m;if(Wo(o,d,n))continue;const s=null===(m=h.get(n))||void 0===m?void 0:m.slice();if(s){p.set(e,t);const o=r.get(e)||new Map;o.set(n,i),r.set(e,o);const a=r.get(n)||new Map;a.set(k,s),r.set(n,a)}}}}r.set(S,p),r.set(k,l)}return r}({inputMint:m,outputMint:d,tokenRouteSegments:this.tokenRouteSegments,intermediateTokens:this.intermediateTokens,onlyDirectRoutes:a,swapMode:r,asLegacyTransaction:c}),this.routeSegmentCache.set(g,S));let k=!1;if(-1===this.routeCacheDuration)k=!1;else if(0===this.routeCacheDuration)k=!0;else if(h){const{fetchTimestamp:e}=h;l-e>this.routeCacheDuration&&(k=!0)}else k=!0;(s||k)&&(await async function(e,t){const n=new Map,i=new Set,o=new Map;t.forEach((e=>{e.forEach((e=>{e.forEach((e=>{o.set(e.id,e),e.getAccountsForUpdate().forEach((e=>{i.add(e.toBase58())}))}))}))}));const s=Array.from(i);s.length>0&&((await St(e,s)).forEach(((e,t)=>{e&&n.set(s[t],e)})),o.forEach((e=>{e.update(n)})))}(this.connection,S),this.routeCache.set(g,{fetchTimestamp:(new Date).getTime()}));try{return{routesInfos:await hs({inputRouteSegment:S,inputMint:e,outputMint:t,amount:n,getDepositAndFeeForRoute:this.getDepositAndFeesForUser,onlyDirectRoutes:a,slippageBps:i,platformFeeBps:p,filterTopNResult:u,swapMode:r,asLegacyTransaction:c}),cached:!(s||k)}}catch(e){throw e}finally{this.routeCache.forEach((({fetchTimestamp:e},t)=>{e-l>this.routeCacheDuration&&this.routeCache.delete(t)}))}}setUserPublicKey(e){this.user=e;const t=new rs(this.user);this.serumOpenOrdersPromise=this.shouldLoadSerumOpenOrders?ys.findSerumOpenOrdersForOwner({connection:this.connection,cluster:this.cluster,userPublicKey:t.publicKey}):Promise.resolve(new Map)}static async fetchAmms(t,n,i,o,s=!1){return async function(t,n,i={},o){const s=(t=>t.map((t=>{const{data:[n,i],pubkey:o,...s}=t;return{...s,pubkey:new e(o),data:Buffer.from(n,i),owner:new e(s.owner)}})))(n);if(An){const e=[];if(e.length){const n=await async function(e,t){return await Promise.all((await St(e,t.map((e=>e.toBase58())))).map((async(e,n)=>{const i=t[n];if(!e)throw new Error(`Failed to fetch pool ${i.toBase58()}`);return{pubkey:i,...e}})))}(t,e);s.push(...n)}}const a=[],r=[],u=s.reduce(((e,t)=>{const n=Co(t.pubkey,t,t.params);if(n){if(gt(i,n.label))return e;e.push(n),n.shouldPrefetch&&a.push(n),n instanceof mo&&r.push(n.wrapperMint.toBase58())}return e}),new Array),[c,m,d]=await Promise.all([At(a,t),De(),await Uo(t,n,o)]);return{amms:u,saberWrapperMints:r,addressLookupTableProvider:d}}(t,await(async e=>await(await ut(e)).json())(o||vt[n]),i,s)}getRouteMap(e,t){return function(e,t,n,i){const o=new Map,s=new Set(e.keys());s.forEach((e=>{o.set(e,new Set)}));for(const[S,k]of e){const f=new Set(s);for(let e of k.keys()){var a,r;null===(a=o.get(S))||void 0===a||a.add(e),null===(r=o.get(e))||void 0===r||r.add(S),f.delete(e)}if(!n)for(let s of f){var u;let a=null===(u=o.get(S))||void 0===u?void 0:u.has(s);if(a)continue;const r=e.get(S),k=e.get(s);if(r&&k){const u=Math.min(r.size,k.size);let[f,M,A,y]=[r,k,S,s];for(let[r,k]of f.entries()){if(n||Wo(t,u,r))continue;let f=e.get(r)||new Map;for(let[e,n]of f){if(e===y){if(!i){var c,m;null===(c=o.get(S))||void 0===c||c.add(s),null===(m=o.get(s))||void 0===m||m.add(S),a=!0;break}for(let e of k){for(let t of n)if(Oo({amms:[e,t],asLegacyTransaction:i})){var d,p;null===(d=o.get(S))||void 0===d||d.add(s),null===(p=o.get(s))||void 0===p||p.add(S),a=!0;break}if(a)break}}if(!i){var l;if(Wo(t,u,e))continue;if(null===(l=M.get(e))||void 0===l?void 0:l.slice()){var g,h;null===(g=o.get(S))||void 0===g||g.add(s),null===(h=o.get(s))||void 0===h||h.add(S),a=!0;break}}}if(a)break}}}}return Array.from(o.entries()).reduce(((e,[t,n])=>(e.set(t,[...n]),e)),new Map)}(this.tokenRouteSegments,this.intermediateTokens,e,t)}static async getIntermediateTokens(e){const t=await async function(){const e=await(await ut("https://cache.jup.ag/top-tokens")).json();return new Set(e.filter(((e,t)=>t<60)))}();for(const e of fn)t.add(e);return e.forEach((e=>t.add(e))),Array.from(t)}}ys.getRemoteRouteMap=As,ys.findSerumOpenOrdersForOwner=async({userPublicKey:e,cluster:t,connection:n})=>{const i=new Map;if(e){const o="mainnet-beta"===t?Pt:Tt;(await l.findForOwner(n,e,o)).forEach((e=>{i.set(e.market.toString(),e.address)}))}return i};const ws=async({connection:e,wallet:t,onTransaction:n,inputMint:i,outputMint:o,sourceAddress:s,destinationAddress:a,swapTransaction:r,owner:u,wrapUnwrapSOL:c})=>{let m,d;try{if(u.signer)ss(r,[u.signer]);else{if(!t)throw new Error("Signer wallet not found");r=await t.signTransaction(r)}const p=os(r);try{const t=async()=>await async function({txid:e,transactionResponse:t}){var n;if(!t)return new D("Transaction was not confirmed",e);if(null!=t&&null!==(n=t.meta)&&void 0!==n&&n.err){let{message:n,programId:o,code:s}=q(t);var i;return o===ei.toBase58()&&s&&(n=null===(i=Ss[s])||void 0===i?void 0:i.msg),n||(n=x),new D(n||"Something went wrong",e,s)}return t}(await is(e,r)),m=t();null==n||n(p,1,"SWAP",m);const l=await m;if(l instanceof Error)throw l;const[g,h]=await async function({txid:e,inputMint:t,outputMint:n,user:i,sourceAddress:o,destinationAddress:s,transactionResponse:a,hasWrappedSOL:r}){let u,c;if(a){let{meta:e,transaction:m}=a;if(e){const a=m.message.getAccountKeys({accountKeysFromLookups:e.loadedAddresses}).keySegments().flat().reduce(((e,t,n)=>(e.set(t.toBase58(),n),e)),new Map);u=t.equals(wt)&&!r?es(e,a,i):Zo(e,a,o),c=n.equals(wt)&&!r?es(e,a,i):Zo(e,a,s)}}if(!u||!c)throw new D("Cannot find source or destination token account balance change",e,Mn.BalancesNotExtractedProperly.code);return[u,c]}({txid:p,inputMint:i,outputMint:o,user:u.publicKey,sourceAddress:s,destinationAddress:a,transactionResponse:l,hasWrappedSOL:!c});d={txid:p,inputAddress:s,outputAddress:a,inputAmount:g,outputAmount:h}}catch(e){m=e}if(m||!d)throw m||new Error("Swap failed");return d}catch(e){return{error:e}}};export{Dt as ALDRIN_SWAP_PROGRAM_ID,qt as ALDRIN_SWAP_V2_PROGRAM_ID,fi as AldrinAmm,rn as BALANSOL_PROGRAM_ID,Pi as BalansolAmm,Rt as CREMA_PARTNER_ACCOUNT,Ct as CREMA_PROGRAM_ID,Et as CROPPER_PROGRAM_ID,Qt as CYKURA_FACTORY_STATE_ADDRESS,Yt as CYKURA_PROGRAM_ID,vi as CremaAmm,bi as CropperAmm,Li as CykuraAmm,nn as DELTA_FI_PROGRAM_ID,on as DELTA_FI_USER_ID,Tt as DEVNET_SERUM_DEX_PROGRAM,pn as DRADEX_DEX_USER,cn as DRADEX_LOGGER_PROGRAM_ID,mn as DRADEX_MASTER_ID,un as DRADEX_PROGRAM_ID,xi as DeltaFiAmm,Lo as DradexAmm,Tn as FAKE_PROVIDER,an as GOOSE_FX_CONTROLLER_ID,sn as GOOSE_FX_PROGRAM_ID,Ci as GooseFXAmm,bt as INDEXED_ROUTE_MAP_URL,Wt as INVARIANT_PROGRAM_AUTHORITY_ID,Xt as INVARIANT_PROGRAM_ID,jt as INVARIANT_STATE_ID,An as IS_DEV,wn as IS_PROD,yn as IS_TEST,Ui as InvariantAmm,Mn as JUPITER_ERRORS,Ft as JUPITER_FEE_OWNER,Nt as JUPITER_WALLET,ys as Jupiter,It as LAMPORTS_PER_SIGNATURE,Vt as LIFINITY_PROGRAM_ID,dn as LIFINITY_V2_PROGRAM_ID,Ki as LifinityAmm,Xi as LifinityV2Amm,Pt as MAINNET_SERUM_DEX_PROGRAM,kn as MARCO_POLO_PROGRAM_AUTHORITY,hn as MARCO_POLO_PROGRAM_ID,Sn as MARCO_POLO_STATE_ID,zt as MARINADE_PROGRAM_ID,vt as MARKETS_URL,Ut as MERCURIAL_SWAP_PROGRAM_ID,en as METEORA_PROGRAM_ID,tn as METEORA_VAULT_PROGRAM_ID,Pn as MIN_SEGMENT_SIZE_FOR_INTERMEDIATE_MINTS,Eo as MarcoPoloAmm,_i as MarinadeAmm,to as MercurialAmm,ao as MeteoraAmm,gn as OPENBOOK_PROGRAM_ID,_t as ORCA_V1_PROGRAM_ID,Gt as ORCA_V2_PROGRAM_ID,rs as Owner,$t as PENGUIN_PROGRAM_ID,Lt as RAYDIUM_AMM_V4_PROGRAM_ID,ln as RAYDIUM_CLMM_PROGRAM_ID,uo as RaydiumAmm,Do as RaydiumClmm,xt as SABER_ADD_DECIMALS_PROGRAM_ID,Zt as SAROS_PROGRAM_ID,Ot as SENCHA_PROGRAM_ID,Ht as STEPN_PROGRAM_ID,Jt as STEP_TOKEN_SWAP_PROGRAM_ID,fn as SWAP_PROTOCOL_TOKENS,mo as SaberAddDecimalsAmm,po as SaberAmm,go as SenchaAmm,Mo as SerumAmm,Po as SplTokenSwapAmm,bo as SplitTradeAmm,kt as SwapMode,Bt as TOKEN_LIST_URL,as as TransactionBuilder,Kt as WHIRLPOOL_PROGRAM_ID,wt as WRAPPED_SOL_MINT,Fo as WhirlpoolAmm,Co as ammFactory,ws as executeTransactions,Gn as getComputeUnitLimitInstruction,_n as getEmptyInstruction,Jo as getPlatformFeeAccounts,As as getRemoteRouteMap,Qo as getRouteInfoUniqueId,Ms as indexedRouteMapToRouteMap,fs as routeMapToIndexedRouteMap,is as transactionSenderAndConfirmationWaiter};
//# sourceMappingURL=core.esm.min.js.map
