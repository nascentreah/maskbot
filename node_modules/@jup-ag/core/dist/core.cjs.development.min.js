"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@solana/web3.js"),t=require("@project-serum/serum"),n=require("@saberhq/stableswap-sdk"),i=require("@jup-ag/math"),o=require("jsbi"),s=require("fzstd"),a=require("@mercurial-finance/optimist"),r=require("@project-serum/anchor"),u=require("@project-serum/anchor/dist/cjs/utils/pubkey"),c=require("@solana/spl-token"),m=require("@solana/buffer-layout"),d=require("@noble/hashes/sha256"),l=require("bn.js"),p=require("decimal.js"),g=require("@jup-ag/crema-sdk-v2"),h=require("@jup-ag/cykura-sdk"),S=require("@jup-ag/cykura-sdk-core"),f=require("@jup-ag/deltafi-sdk"),A=require("@pythnetwork/client"),M=require("bignumber.js"),k=require("@jup-ag/goosefx-ssl-sdk"),y=require("@jup-ag/invariant"),w=require("@jup-ag/lifinity-sdk"),P=require("@jup-ag/lifinity-sdk-v2"),T=require("@mercurial-finance/dynamic-amm-sdk"),b=require("@jup-ag/whirlpools-sdk"),v=require("@jup-ag/dradex-sdk"),I=require("@jup-ag/dradex-idl"),B=require("@jup-ag/raydium-clmm-sdk"),D=require("cross-fetch"),R=require("@project-serum/anchor/dist/cjs/utils/bytes");function O(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function L(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var i=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,i.get?i:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,t}var F=O(o),E=L(s),x=O(l),q=O(p),_=O(D);const K={Raydium:{Openbook:!0}},N={Openbook:!0,Cykura:!0,Meteora:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0,"Marco Polo":!0},Crema:{Balansol:!0,Raydium:!0,Lifinity:!0,"Lifinity V2":!0},"Marco Polo":{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Dradex:!0,Raydium:!0},Dradex:{Lifinity:!0,"Lifinity V2":!0,Balansol:!0,Crema:!0,Raydium:!0},Balansol:{Raydium:!0},Lifinity:{Raydium:!0},"Lifinity V2":{Raydium:!0}},C={Raydium:!0,GooseFX:!0,Meteora:!0,Serum:!0,Openbook:!0,Dradex:!0,Crema:!0,Lifinity:!0,"Lifinity V2":!0},V=(e,t,n)=>{const i=e[t];if(i){if(!0===i||!0===i["*"])return!0;if(n)return!0===i[n]}return!1},U=(e,t,n)=>V(e,t,n)||!!n&&V(e,n,t);function W(e,t){return Array.apply(0,new Array(Math.ceil(e.length/t))).map(((n,i)=>e.slice(i*t,(i+1)*t)))}async function X(t,n,i=1e3,o=100){return(await Promise.all(W(n,i).map((async n=>{const i=W(n,o).map((e=>({methodName:"getMultipleAccounts",args:t._buildArgs([e],t.commitment,"base64+zstd")})));return t._rpcBatchRequest(i).then((t=>t.reduce(((t,n)=>(n.result.value.forEach((n=>{if(n){const i=n;i.data=Buffer.from(E.decompress(Buffer.from(n.data[0],"base64"))),i.owner=new e.PublicKey(n.owner),t.push(i)}else t.push(null)})),t)),[]))).catch((e=>n.map((()=>null))))})))).flat()}var Y;exports.SwapMode=void 0,(Y=exports.SwapMode||(exports.SwapMode={})).ExactIn="ExactIn",Y.ExactOut="ExactOut";const j=(e,t)=>t.map((t=>{const n=e.get(t.toString());if(!n)throw new Error(`Account info ${t.toBase58()} missing`);return n})),G=e=>e.map((e=>{const t=a.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account");return t})).map((e=>F.default.BigInt(e.amount))),Q=async(e,t)=>{const n=e.map((e=>e.getAccountsForUpdate().map((e=>e.toBase58())))).flat(),i=new Map;(await X(t,n)).forEach(((e,t)=>{e&&i.set(n[t],e)}));for(let t of e)t.update(i)},z={version:"0.1.0",name:"jupiter",instructions:[{name:"route",accounts:[{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"destinationTokenAccount",isMut:!1,isSigner:!1}],args:[{name:"swapLeg",type:{defined:"SwapLeg"}},{name:"inAmount",type:"u64"},{name:"quotedOutAmount",type:"u64"},{name:"slippageBps",type:"u16"},{name:"platformFeeBps",type:"u8"}]},{name:"whirlpoolSwapExactOutput",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[{name:"outAmount",type:"u64"},{name:"inAmountWithSlippage",type:{defined:"AmountWithSlippage"}},{name:"aToB",type:"bool"},{name:"platformFeeBps",type:"u8"}]},{name:"createOpenOrders",accounts:[{name:"openOrders",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"market",isMut:!1,isSigner:!1}],args:[]},{name:"mercurialSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"poolAuthority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceTokenAccount",isMut:!0,isSigner:!1},{name:"destinationTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"cykuraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"signer",isMut:!1,isSigner:!0},{name:"factoryState",isMut:!1,isSigner:!1},{name:"poolState",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"inputVault",isMut:!0,isSigner:!1},{name:"outputVault",isMut:!0,isSigner:!1},{name:"lastObservationState",isMut:!0,isSigner:!1},{name:"coreProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"serumSwap",accounts:[{name:"market",accounts:[{name:"market",isMut:!0,isSigner:!1},{name:"openOrders",isMut:!0,isSigner:!1},{name:"requestQueue",isMut:!0,isSigner:!1},{name:"eventQueue",isMut:!0,isSigner:!1},{name:"bids",isMut:!0,isSigner:!1},{name:"asks",isMut:!0,isSigner:!1},{name:"coinVault",isMut:!0,isSigner:!1},{name:"pcVault",isMut:!0,isSigner:!1},{name:"vaultSigner",isMut:!1,isSigner:!1}]},{name:"authority",isMut:!1,isSigner:!0},{name:"orderPayerTokenAccount",isMut:!0,isSigner:!1},{name:"coinWallet",isMut:!0,isSigner:!1},{name:"pcWallet",isMut:!0,isSigner:!1},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"saberSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapAuthority",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"feesTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"saberAddDecimals",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"tokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"senchaSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!0,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"inputFeesAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"outputFeesAccount",isMut:!0,isSigner:!1}],args:[]},{name:"stepSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"cropperSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[]},{name:"raydiumSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[]},{name:"cremaSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"clmmConfig",isMut:!1,isSigner:!1},{name:"clmmpool",isMut:!0,isSigner:!1},{name:"tokenA",isMut:!1,isSigner:!1},{name:"tokenB",isMut:!1,isSigner:!1},{name:"accountA",isMut:!0,isSigner:!1},{name:"accountB",isMut:!0,isSigner:!1},{name:"tokenAVault",isMut:!0,isSigner:!1},{name:"tokenBVault",isMut:!0,isSigner:!1},{name:"tickArrayMap",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"partner",isMut:!1,isSigner:!1},{name:"partnerAtaA",isMut:!0,isSigner:!1},{name:"partnerAtaB",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"lifinitySwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"amm",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceInfo",isMut:!0,isSigner:!1},{name:"destinationInfo",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"feeAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"pythAccount",isMut:!1,isSigner:!1},{name:"pythPcAccount",isMut:!1,isSigner:!1},{name:"configAccount",isMut:!0,isSigner:!1}],args:[]},{name:"marinadeDeposit",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1},{name:"tempWsolTokenAccount",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!0,isSigner:!0},{name:"wsolMint",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"marinadeUnstake",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1}],args:[]},{name:"aldrinSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"aldrinV2Swap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"curve",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"whirlpoolSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[]},{name:"invariantSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tickmap",isMut:!0,isSigner:!1},{name:"accountX",isMut:!0,isSigner:!1},{name:"accountY",isMut:!0,isSigner:!1},{name:"reserveX",isMut:!0,isSigner:!1},{name:"reserveY",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"meteoraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"userSourceToken",isMut:!0,isSigner:!1},{name:"userDestinationToken",isMut:!0,isSigner:!1},{name:"aVault",isMut:!0,isSigner:!1},{name:"bVault",isMut:!0,isSigner:!1},{name:"aTokenVault",isMut:!0,isSigner:!1},{name:"bTokenVault",isMut:!0,isSigner:!1},{name:"aVaultLpMint",isMut:!0,isSigner:!1},{name:"bVaultLpMint",isMut:!0,isSigner:!1},{name:"aVaultLp",isMut:!0,isSigner:!1},{name:"bVaultLp",isMut:!0,isSigner:!1},{name:"adminTokenFee",isMut:!0,isSigner:!1},{name:"user",isMut:!1,isSigner:!0},{name:"vaultProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"goosefxSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"controller",isMut:!1,isSigner:!1},{name:"pair",isMut:!0,isSigner:!1},{name:"sslIn",isMut:!0,isSigner:!1},{name:"sslOut",isMut:!0,isSigner:!1},{name:"liabilityVaultIn",isMut:!0,isSigner:!1},{name:"swappedLiabilityVaultIn",isMut:!0,isSigner:!1},{name:"liabilityVaultOut",isMut:!0,isSigner:!1},{name:"swappedLiabilityVaultOut",isMut:!0,isSigner:!1},{name:"userInAta",isMut:!0,isSigner:!1},{name:"userOutAta",isMut:!0,isSigner:!1},{name:"feeCollectorAta",isMut:!0,isSigner:!1},{name:"userWallet",isMut:!1,isSigner:!0},{name:"feeCollector",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"deltafiSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"marketConfig",isMut:!1,isSigner:!1},{name:"swapInfo",isMut:!0,isSigner:!1},{name:"userSourceToken",isMut:!0,isSigner:!1},{name:"userDestinationToken",isMut:!0,isSigner:!1},{name:"swapSourceToken",isMut:!0,isSigner:!1},{name:"swapDestinationToken",isMut:!0,isSigner:!1},{name:"deltafiUser",isMut:!0,isSigner:!1},{name:"adminDestinationToken",isMut:!0,isSigner:!1},{name:"pythPriceBase",isMut:!1,isSigner:!1},{name:"pythPriceQuote",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"balansolSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!0,isSigner:!0},{name:"pool",isMut:!0,isSigner:!1},{name:"taxMan",isMut:!0,isSigner:!1},{name:"bidMint",isMut:!1,isSigner:!1},{name:"treasurer",isMut:!1,isSigner:!1},{name:"srcTreasury",isMut:!0,isSigner:!1},{name:"srcAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"askMint",isMut:!1,isSigner:!1},{name:"dstTreasury",isMut:!0,isSigner:!1},{name:"dstAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"dstTokenAccountTaxman",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"marcoPoloSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"swapperXAccount",isMut:!0,isSigner:!1},{name:"swapperYAccount",isMut:!0,isSigner:!1},{name:"swapper",isMut:!0,isSigner:!0},{name:"referrerXAccount",isMut:!0,isSigner:!1},{name:"referrerYAccount",isMut:!0,isSigner:!1},{name:"referrer",isMut:!0,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"dradexSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pair",isMut:!0,isSigner:!1},{name:"market",isMut:!0,isSigner:!1},{name:"eventQueue",isMut:!0,isSigner:!1},{name:"dexUser",isMut:!1,isSigner:!1},{name:"marketUser",isMut:!0,isSigner:!1},{name:"bids",isMut:!0,isSigner:!1},{name:"asks",isMut:!0,isSigner:!1},{name:"t0Vault",isMut:!0,isSigner:!1},{name:"t1Vault",isMut:!0,isSigner:!1},{name:"t0User",isMut:!0,isSigner:!1},{name:"t1User",isMut:!0,isSigner:!1},{name:"master",isMut:!1,isSigner:!1},{name:"signer",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"logger",isMut:!1,isSigner:!1}],args:[]},{name:"lifinityV2Swap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"amm",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceInfo",isMut:!0,isSigner:!1},{name:"destinationInfo",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"feeAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"oracleMainAccount",isMut:!1,isSigner:!1},{name:"oracleSubAccount",isMut:!1,isSigner:!1},{name:"oraclePcAccount",isMut:!1,isSigner:!1}],args:[]},{name:"raydiumClmmSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"payer",isMut:!1,isSigner:!0},{name:"ammConfig",isMut:!1,isSigner:!1},{name:"poolState",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"inputVault",isMut:!0,isSigner:!1},{name:"outputVault",isMut:!0,isSigner:!1},{name:"observationState",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tickArray",isMut:!0,isSigner:!1}],args:[]}],types:[{name:"AmountWithSlippage",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"slippageBps",type:"u16"}]}},{name:"SplitLegDeeper",type:{kind:"struct",fields:[{name:"percent",type:"u8"},{name:"swapLeg",type:{defined:"SwapLegSwap"}}]}},{name:"SplitLeg",type:{kind:"struct",fields:[{name:"percent",type:"u8"},{name:"swapLeg",type:{defined:"SwapLegDeeper"}}]}},{name:"SwapInstrution",type:{kind:"enum",variants:[{name:"Swap",fields:[{defined:"Swap"}]}]}},{name:"Side",type:{kind:"enum",variants:[{name:"Bid"},{name:"Ask"}]}},{name:"SwapLegSwap",type:{kind:"enum",variants:[{name:"PlaceholderOne"},{name:"PlaceholderTwo"},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"SwapLegDeeper",type:{kind:"enum",variants:[{name:"Chain",fields:[{name:"swap_legs",type:{vec:{defined:"SwapLegSwap"}}}]},{name:"Split",fields:[{name:"split_legs",type:{vec:{defined:"SplitLegDeeper"}}}]},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"SwapLeg",type:{kind:"enum",variants:[{name:"Chain",fields:[{name:"swap_legs",type:{vec:{defined:"SwapLegDeeper"}}}]},{name:"Split",fields:[{name:"split_legs",type:{vec:{defined:"SplitLeg"}}}]},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}},{name:"Swap",type:{kind:"enum",variants:[{name:"Saber"},{name:"SaberAddDecimalsDeposit"},{name:"SaberAddDecimalsWithdraw"},{name:"TokenSwap"},{name:"Sencha"},{name:"Step"},{name:"Cropper"},{name:"Raydium"},{name:"Crema",fields:[{name:"a_to_b",type:"bool"}]},{name:"Lifinity"},{name:"Mercurial"},{name:"Cykura"},{name:"Serum",fields:[{name:"side",type:{defined:"Side"}}]},{name:"MarinadeDeposit"},{name:"MarinadeUnstake"},{name:"Aldrin",fields:[{name:"side",type:{defined:"Side"}}]},{name:"AldrinV2",fields:[{name:"side",type:{defined:"Side"}}]},{name:"Whirlpool",fields:[{name:"a_to_b",type:"bool"}]},{name:"Invariant",fields:[{name:"x_to_y",type:"bool"}]},{name:"Meteora"},{name:"GooseFX"},{name:"DeltaFi",fields:[{name:"stable",type:"bool"}]},{name:"Balansol"},{name:"MarcoPolo",fields:[{name:"x_to_y",type:"bool"}]},{name:"Dradex",fields:[{name:"side",type:{defined:"Side"}}]},{name:"LifinityV2"},{name:"RaydiumClmm"},{name:"Openbook",fields:[{name:"side",type:{defined:"Side"}}]}]}},{name:"SwapAction",type:{kind:"enum",variants:[{name:"SetupSplit",fields:[{name:"percents",type:"bytes"}]},{name:"NextSplitLeg"},{name:"MergeSplit"},{name:"Swap",fields:[{name:"swap",type:{defined:"Swap"}}]}]}}],events:[{name:"Swap",fields:[{name:"amm",type:"publicKey",index:!1},{name:"inputMint",type:"publicKey",index:!1},{name:"inputAmount",type:"u64",index:!1},{name:"outputMint",type:"publicKey",index:!1},{name:"outputAmount",type:"u64",index:!1}]},{name:"Fee",fields:[{name:"account",type:"publicKey",index:!1},{name:"mint",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1}]}],errors:[{code:6e3,name:"EmptyRoute",msg:"Empty route"},{code:6001,name:"SlippageToleranceExceeded",msg:"Slippage tolerance exceeded"},{code:6002,name:"InvalidCalculation",msg:"Invalid calculation"},{code:6003,name:"MissingPlatformFeeAccount",msg:"Missing platform fee account"},{code:6004,name:"InvalidSlippage",msg:"Invalid slippage"},{code:6005,name:"NotEnoughPercent",msg:"Not enough percent to 100"},{code:6006,name:"InAmountsStackIsEmpty",msg:"In amounts stack is empty"},{code:6007,name:"OutAmountsStackIsEmpty",msg:"Out amounts stack is empty"},{code:6008,name:"NotEnoughAccountKeys",msg:"Not Enough Account keys"}]},Z=new e.PublicKey("So11111111111111111111111111111111111111112"),H=new e.PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),J=new e.PublicKey("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY"),$={devnet:"https://jupiter-devnet.zhen8558.workers.dev/markets?v=3","mainnet-beta":"https://cache.jup.ag/markets?v=3",testnet:"https://api.jup.ag/api/markets/cache/devnet"},ee=new e.PublicKey("BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9"),te=new e.PublicKey("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),ne=new e.PublicKey("AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6"),ie=new e.PublicKey("CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4"),oe=new e.PublicKey("DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB"),se=new e.PublicKey("CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh"),ae=new e.PublicKey("SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ"),re=new e.PublicKey("EewxydAPCCVuNEyrVN68PuSYdQ7wKn27V9Gjeoi8dy3S"),ue=new e.PublicKey("CLMM9tUoggJu2wagPkkqs9eFG4BWhVBZWkP1qv3Sp7tR"),ce=new e.PublicKey("FxYoB1VAx8TfLCwvmworJy16VH89v992qznUvBX5aR8K"),me=new e.PublicKey("BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9"),de=new e.PublicKey("MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky"),le=new e.PublicKey("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"),pe=new e.PublicKey("HyaB3W9q6XdA5xwpU4XnSZV94htfmbmqJXZcEbRaJutt"),ge=new e.PublicKey("8NsPwRFYqob3FzYvHYTjFK6WVFJADFN8Hn7yNQKcVNW1"),he=new e.PublicKey("J4uBbeoWpZE8fH58PM1Fp9n9K6f1aThyeVCyRdJbaXqt"),Se=new e.PublicKey("cysPXAjehMpVKUapzbMCCnpFxUFFryEWEaLgnb9NrR8"),fe=new e.PublicKey("DBsMwKfeoUHhxMi9x6wd2AsT12UwUCssjNbUzu1aKgqj"),Ae=new e.PublicKey("MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD"),Me=new e.PublicKey("Dooar9JkhdZ7J3LHN3A7YCuoGRUggXhQaG4kijfLGU2j"),ke=new e.PublicKey("DjVE6JNiYqPL2QXyCUUh8rNjHrbz9hXHNYt99MQ59qw1"),ye=new e.PublicKey("9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP"),we=new e.PublicKey("SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1"),Pe=new e.PublicKey("PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP"),Te=new e.PublicKey("SSwapUtytfBdBn1b9NUGG6foMVPtcWgpRU32HToDUZr"),be=new e.PublicKey("Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"),ve=new e.PublicKey("24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi"),Ie=new e.PublicKey("GNExJhNUhc9LN2DauuQAUJnXoy6DJ6zey3t9kT9A2PF3"),Be=new e.PublicKey("ziSPuDShwunW4xNrCfTnSHTPVT6FZDREtdofpf1BJwe"),De=new e.PublicKey("7WduLbRfYhTJktjLw5FDEyrqoEv61aTTCuGAetgLjzN5"),Re=new e.PublicKey("8CxKnuJeoeQXFwiG6XiGY2akBjvJA5k3bE52BfnuEmNQ"),Oe=new e.PublicKey("D3BBjqUdCYuP18fNvvMbPAZ8DpcRi4io2EsYHQawJDag"),Le=new e.PublicKey("dp2waEWSBy5yKmq65ergoU3G6qRLmqa6K7We4rZSKph"),Fe=new e.PublicKey("1gE3LGQze8DQ3KD2C4ZUCmRX5g4njhY5yLfYmnmcvJR"),Ee=new e.PublicKey("76ygWLcvJLR6nSzRUpiQqqtX4Pabkq4vpaTxwr3mDcXA"),xe=new e.PublicKey("2wT8Yq49kHgDzXuPxZSaeLaH1qbmGXtEyPy64bL7aD3c"),qe=new e.PublicKey("571oqNkJauZ2tccLwf8CUB56hpLPZkop9X1Px4DE9rnQ"),_e=new e.PublicKey("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Ke=new e.PublicKey("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Ne=new e.PublicKey("9tKE7Mbmj4mxDjWatikzGAtkoWosiiZX9y6J4Hfm2R8H"),Ce=new e.PublicKey("BE5YRQ6N6LCw7UL3JwzVp317EWa4mzJY6JKDaudcXu7A"),Ve=new e.PublicKey("JM78XNzeQRmZXDAP4DSq88ZdErbuSXSLE6fkRsVDKSu"),Ue=["StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT","DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz"],We=Object.freeze({AlreadyInUse:{code:1,name:"AlreadyInUsed",msg:"Account already In Used"},InsufficientSOL:{code:1,name:"InsufficientSOL",msg:"Insufficient SOL"},TransactionNotConfirmed:{code:7e3,name:"TransactionNotConfirmed",msg:"Transaction was not confirmed"},BalancesNotExtractedProperly:{code:7001,name:"BalancesNotExtractedProperly",msg:"Balances cannot be extracted properly"},...z.errors.reduce(((e,t)=>({...e,[t.name]:t})),{})}),Xe=new r.AnchorProvider(null,null,{skipPreflight:!1});class Ye extends m.Layout{constructor(e){const t=m.blob(32);super(t.span,e),this.layout=void 0,this.layout=t}getSpan(e,t){return this.layout.getSpan(e,t)}decode(t,n){return new e.PublicKey(this.layout.decode(t,n))}encode(e,t,n){return this.layout.encode(e.toBuffer(),t,n)}}const je=e=>new Ye(e);class Ge extends m.Layout{constructor(e=8,t){const n=m.blob(e);super(n.span,t),this.layout=void 0,this.layout=n}getSpan(e,t){return this.layout.getSpan(e,t)}decode(e,t){return new c.u64(this.layout.decode(e,t),10,"le")}encode(e,t,n){return this.layout.encode(e.toArrayLike(Buffer,"le",this.layout.span),t,n)}}const Qe=e=>new Ge(8,e),ze=e=>new Ge(16,e);function Ze(t,n){let i=Buffer.alloc(0);t.forEach((function(t){if(t.length>e.MAX_SEED_LENGTH)throw new TypeError("Max seed length exceeded");var n;i=Buffer.concat([i,(n=t,Buffer.isBuffer(n)?n:n instanceof Uint8Array?Buffer.from(n.buffer,n.byteOffset,n.byteLength):Buffer.from(n))])})),i=Buffer.concat([i,n.toBuffer(),Buffer.from("ProgramDerivedAddress")]);let o=d.sha256(new Uint8Array(i)),s=new x.default(o,16).toArray(void 0,32);return new e.PublicKey(s)}const He=m.struct([m.u8("version"),m.u8("isInitialized"),m.u8("nonce"),je("ammId"),je("serumProgramId"),je("serumMarket"),je("tokenProgramId"),je("tokenAAccount"),je("tokenBAccount"),je("poolMint"),je("mintA"),je("mintB")]),Je=m.struct([m.u8("isInitialized"),je("stateOwner"),je("feeOwner"),Qe("initialSupply"),Qe("returnFeeNumerator"),Qe("fixedFeeNumerator"),Qe("feeDenominator"),m.u8("curveType"),m.blob(32,"curveParameters")]),$e=new e.PublicKey("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),et=(e,t)=>{const n=t.owner,i=He.decode(t.data);return{programId:n,authority:Ze([e.toBuffer(),Buffer.from([i.nonce])],n),version:i.version,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:i.ammId,serumProgramId:i.serumProgramId,tokenProgramId:i.tokenProgramId,tokenAAccount:i.tokenAAccount,tokenBAccount:i.tokenBAccount,serumMarket:i.serumMarket,poolMint:i.poolMint,mintA:i.mintA,mintB:i.mintB}},tt={Bid:{bid:{}},Ask:{ask:{}}},nt=e=>({serum:{side:e}}),it=e=>({crema:{aToB:e}}),ot=e=>({aldrin:{side:e}}),st=e=>({aldrinV2:{side:e}}),at=e=>({whirlpool:{aToB:e}}),rt=e=>({invariant:{xToY:e}}),ut=e=>({dradex:{side:e}}),ct=e=>({openbook:{side:e}}),mt=e=>({marcoPolo:{xToY:e}}),dt=e=>({chain:{swapLegs:e}}),lt=e=>({split:{splitLegs:e}}),pt=e=>({swap:{swap:e}}),gt=(e,t)=>({percent:e,swapLeg:t}),ht=t=>e.ComputeBudgetProgram.setComputeUnitLimit({units:Math.min(t,14e5)});async function St({connection:t,amount:n,owner:{publicKey:i}}){const o={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},s=At({walletAddress:i,tokenMintAddress:Z});return null===await t.getAccountInfo(s)&&o.setupInstructions.push(ft(i,s,i,Z)),o.setupInstructions.push(e.SystemProgram.transfer({fromPubkey:i,toPubkey:s,lamports:F.default.toNumber(n)})),o.setupInstructions.push(c.Token.createSyncNativeInstruction(c.TOKEN_PROGRAM_ID,s)),o.cleanupInstructions=[c.Token.createCloseAccountInstruction(c.TOKEN_PROGRAM_ID,s,i,i,[])],{address:s,...o}}function ft(t,n,i,o,s=c.TOKEN_PROGRAM_ID,a=c.ASSOCIATED_TOKEN_PROGRAM_ID){return new e.TransactionInstruction({keys:[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:e.SystemProgram.programId,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}],programId:a,data:Buffer.alloc(0)})}const At=({walletAddress:t,tokenMintAddress:n})=>e.PublicKey.findProgramAddressSync([t.toBuffer(),c.TOKEN_PROGRAM_ID.toBuffer(),n.toBuffer()],c.ASSOCIATED_TOKEN_PROGRAM_ID)[0],Mt=new e.PublicKey("JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB"),kt=new r.Program(z,Mt,{}),yt={pubkey:Mt,isSigner:!1,isWritable:!1};function wt(e,t,n,i,o,s,a,r){return kt.instruction.route(n,o,s,a,r,{accounts:{tokenProgram:c.TOKEN_PROGRAM_ID,userTransferAuthority:e,destinationTokenAccount:t},remainingAccounts:i})}function Pt(e,t,n,i){return{swapProgram:de,swapState:e.ammId,tokenProgram:c.TOKEN_PROGRAM_ID,poolAuthority:e.authority,userTransferAuthority:i,sourceTokenAccount:t,destinationTokenAccount:n}}const[Tt]=u.findProgramAddressSync([new Uint8Array(Buffer.from("amm authority".replace("Â "," "),"utf-8"))],te);function bt(e,t,n,i){if(!e.serumMarketKeys)throw new Error("RaydiumAmm is missing serumMarketKeys");return{swapProgram:te,tokenProgram:c.TOKEN_PROGRAM_ID,ammId:e.ammId,ammAuthority:Tt,ammOpenOrders:e.ammOpenOrders,poolCoinTokenAccount:e.poolCoinTokenAccount,poolPcTokenAccount:e.poolPcTokenAccount,serumProgramId:e.serumProgramId,serumMarket:e.serumMarket,serumBids:e.serumMarketKeys.serumBids,serumAsks:e.serumMarketKeys.serumAsks,serumEventQueue:e.serumMarketKeys.serumEventQueue,serumCoinVaultAccount:e.serumMarketKeys.serumCoinVaultAccount,serumPcVaultAccount:e.serumMarketKeys.serumPcVaultAccount,serumVaultSigner:e.serumMarketKeys.serumVaultSigner,userSourceTokenAccount:t,userDestinationTokenAccount:n,userSourceOwner:i}}function vt(t,n,i,o,s,a){const r=u.createProgramAddressSync([t.address.toBuffer(),t.decoded.vaultSignerNonce.toArrayLike(Buffer,"le",8)],t.programId);return{market:{market:t.address,openOrders:n,requestQueue:t.decoded.requestQueue,eventQueue:t.decoded.eventQueue,bids:t.bidsAddress,asks:t.asksAddress,coinVault:t.decoded.baseVault,pcVault:t.decoded.quoteVault,vaultSigner:r},authority:a,orderPayerTokenAccount:i,coinWallet:o,pcWallet:s,dexProgram:t.programId,tokenProgram:c.TOKEN_PROGRAM_ID,rent:e.SYSVAR_RENT_PUBKEY}}function It(e,t,n,i,o){const s=t.equals(e.state.tokenA.mint)?e.state.tokenB.adminFeeAccount:e.state.tokenA.adminFeeAccount,[a,r]=t.equals(e.state.tokenA.mint)?[e.state.tokenA.reserve,e.state.tokenB.reserve]:[e.state.tokenB.reserve,e.state.tokenA.reserve];return{swapProgram:e.config.swapProgramID,tokenProgram:c.TOKEN_PROGRAM_ID,swap:e.config.swapAccount,swapAuthority:e.config.authority,userAuthority:o,inputUserAccount:n,inputTokenAccount:a,outputUserAccount:i,outputTokenAccount:r,feesTokenAccount:s}}function Bt(e,t){const n=[];return n.push(e?{pubkey:e,isSigner:!1,isWritable:!0}:t?{pubkey:t,isSigner:!1,isWritable:!0}:yt),n}const Dt=new c.u64(0);class Rt{constructor(e,t){this.numerator=void 0,this.denominator=void 0,this.toString=()=>`${this.numerator.toString()}/${this.denominator.toString()}`,this.numerator=e,this.denominator=t}static fromDecimal(e){return Rt.fromFraction(e.toDecimalPlaces(1).mul(10).toNumber(),1e3)}static fromFraction(e,t){const n="number"==typeof e?new c.u64(e.toString()):e,i="number"==typeof t?new c.u64(t.toString()):t;return new Rt(n,i)}toDecimal(){return this.denominator.eq(Dt)?new q.default(0):new q.default(this.numerator.toString()).div(new q.default(this.denominator.toString()))}add(e){const t=this.denominator.gcd(e.denominator),n=this.denominator.div(t).mul(e.denominator),i=n.div(this.denominator),o=n.div(e.denominator),s=this.numerator.mul(i),a=e.numerator.mul(o),r=s.add(a);return new Rt(new c.u64(r.toString()),new c.u64(n.toString()))}}const Ot=m.struct([Qe("tradeFeeNumerator"),Qe("tradeFeeDenominator"),Qe("ownerTradeFeeNumerator"),Qe("ownerTradeFeeDenominator"),Qe("ownerWithdrawFeeNumerator"),Qe("ownerWithdrawFeeDenominator")],"fees"),Lt=[m.blob(8,"padding"),je("lpTokenFreezeVault"),je("poolMint"),je("baseTokenVault"),je("baseTokenMint"),je("quoteTokenVault"),je("quoteTokenMint"),je("poolSigner"),m.u8("poolSignerNonce"),je("authority"),je("initializerAccount"),je("feeBaseAccount"),je("feeQuoteAccount"),je("feePoolTokenAccount"),Ot],Ft=m.struct(Lt),Et=m.struct([...Lt,m.u8("curveType"),je("curve")]),xt=m.struct([m.blob(8,"padding"),Qe("amp")]);function qt(e,t){const n=!!t.owner.equals(ie),i=(n?Et:Ft).decode(t.data),o="curveType"in i?{curveType:i.curveType,curve:i.curve}:{};return{isV2:n,address:e,poolMint:i.poolMint,baseTokenVault:i.baseTokenVault,baseTokenMint:i.baseTokenMint,quoteTokenVault:i.quoteTokenVault,quoteTokenMint:i.quoteTokenMint,poolSigner:i.poolSigner,feeBaseAccount:i.feeBaseAccount,feeQuoteAccount:i.feeQuoteAccount,feePoolTokenAccount:i.feePoolTokenAccount,fees:{traderFee:Rt.fromFraction(i.fees.tradeFeeNumerator,i.fees.tradeFeeDenominator),ownerFee:Rt.fromFraction(i.fees.ownerTradeFeeNumerator,i.fees.ownerTradeFeeDenominator)},...o}}class _t{constructor(e,t,n){if(this.params=void 0,this.id=void 0,this.label="Aldrin",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.params=n,this.poolState=qt(e,t),this.id=e.toBase58(),1===this.poolState.curveType){const{amp:e}=this.params;if(!e)throw new Error("Amp is required for a stable curve");this.calculator=new i.TokenSwapStable(F.default.BigInt(e),new i.Fraction(F.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),F.default.BigInt(this.poolState.fees.traderFee.denominator.toString())),new i.Fraction(F.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),F.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}else this.calculator=new i.TokenSwapConstantProduct(new i.Fraction(F.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),F.default.BigInt(this.poolState.fees.traderFee.denominator.toString())),new i.Fraction(F.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),F.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}static decodeStableCurveAmp(e){const{amp:t}=xt.decode(e.data);return 2*t.toNumber()}getAccountsForUpdate(){return[this.poolState.quoteTokenVault,this.poolState.baseTokenVault]}update(e){const t=j(e,this.getAccountsForUpdate());this.tokenReserveAmounts=G(t)}getQuote({sourceMint:e,amount:t}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");let n=new q.default(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new q.default(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));const i=this.poolState.baseTokenMint.equals(e)?0:1;let o=this.calculator.exchange(this.tokenReserveAmounts,t,i);return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:n.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){if(this.poolState.isV2){if(!this.poolState.curve)throw new Error("Unable to fetch curve account.");return function({poolState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,curve:o,userTransferAuthority:s}){const[a,r,u]=t.equals(e.baseTokenMint)?[tt.Ask,n,i]:[tt.Bid,i,n];return[pt(st(a)),kt.instruction.aldrinV2Swap({accounts:{swapProgram:ie,pool:e.address,poolSigner:e.poolSigner,poolMint:e.poolMint,baseTokenVault:e.baseTokenVault,quoteTokenVault:e.quoteTokenVault,feePoolTokenAccount:e.feePoolTokenAccount,walletAuthority:s,userBaseTokenAccount:r,userQuoteTokenAccount:u,curve:o,tokenProgram:c.TOKEN_PROGRAM_ID}}).keys]}({poolState:this.poolState,curve:this.poolState.curve,...e})}return function({poolState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,a,r]=t.equals(e.baseTokenMint)?[tt.Ask,n,i]:[tt.Bid,i,n];return[pt(ot(s)),kt.instruction.aldrinSwap({accounts:{swapProgram:ne,pool:e.address,poolSigner:e.poolSigner,poolMint:e.poolMint,baseTokenVault:e.baseTokenVault,quoteTokenVault:e.quoteTokenVault,feePoolTokenAccount:e.feePoolTokenAccount,walletAuthority:o,userBaseTokenAccount:a,userQuoteTokenAccount:r,tokenProgram:c.TOKEN_PROGRAM_ID}}).keys]}({poolState:this.poolState,...e})}get reserveTokenMints(){return[this.poolState.quoteTokenMint,this.poolState.baseTokenMint]}}_t.accountInfoToAldrinPoolState=qt;const Kt={version:"0.1.0",name:"balancer_amm",instructions:[{name:"swap",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"pool",isMut:!0,isSigner:!1},{name:"taxMan",isMut:!0,isSigner:!1},{name:"bidMint",isMut:!1,isSigner:!1},{name:"treasurer",isMut:!1,isSigner:!1},{name:"srcTreasury",isMut:!0,isSigner:!1},{name:"srcAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"askMint",isMut:!1,isSigner:!1},{name:"dstTreasury",isMut:!0,isSigner:!1},{name:"dstAssociatedTokenAccount",isMut:!0,isSigner:!1},{name:"dstTokenAccountTaxman",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"bidAmount",type:"u64"},{name:"limit",type:"u64"}],returns:"u64"}],accounts:[{name:"pool",type:{kind:"struct",fields:[{name:"authority",type:"publicKey"},{name:"fee",type:"u64"},{name:"taxFee",type:"u64"},{name:"state",type:{defined:"PoolState"}},{name:"mintLpt",type:"publicKey"},{name:"taxMan",type:"publicKey"},{name:"mints",type:{vec:"publicKey"}},{name:"actions",type:{vec:{defined:"MintActionState"}}},{name:"treasuries",type:{vec:"publicKey"}},{name:"reserves",type:{vec:"u64"}},{name:"weights",type:{vec:"u64"}}]}}],types:[{name:"PoolState",type:{kind:"enum",variants:[{name:"Uninitialized"},{name:"Initialized"},{name:"Frozen"},{name:"Deleted"}]}},{name:"MintActionState",type:{kind:"enum",variants:[{name:"Active"},{name:"BidOnly"},{name:"AskOnly"},{name:"Paused"}]}}],errors:[]},Nt=(e,t)=>{const n=e.map((e=>e.toNumber()/1e9));return t.toNumber()/1e9/n.reduce(((e,t)=>e+t),0)},Ct=(e,t)=>{const{balanceIn:n,balanceOut:i,weightIn:o,weightOut:s,swapFee:a}=t,r=Number(n.toString()),u=Number(i.toString()),c=o,m=s,d=Number(a.toString())/1e9;return-r*m/(u*(-1+d)*(r/(e+r-e*d))**((c+m)/m)*c)},Vt=new r.BorshAccountsCoder(Kt);class Ut{constructor(e,t){this.address=void 0,this.label="Balansol",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolData=void 0,this.address=e,this.id=e.toBase58(),this.poolData=Vt.decode("pool",t.data)}getAccountsForUpdate(){return[new e.PublicKey(this.id)]}update(e){let[t]=j(e,this.getAccountsForUpdate());const n=Vt.decode("pool",t.data);this.poolData=n}getQuote({sourceMint:e,destinationMint:t,amount:n}){var i,o;if(!this.poolData)throw new Error(`Invalid pool data ${this.address.toBase58()}`);if(!this.poolData.state.initialized)throw new Error(`Pool is not initialized ${this.address.toBase58()}`);const s=this.poolData.mints.map((e=>e.toBase58())),a=s.indexOf(e.toBase58()),r=s.indexOf(t.toBase58());if(null===(i=this.poolData.actions[a])||void 0===i||!i.active)throw new Error(`Invalid bid mint state ${this.address.toBase58()}`);if(null===(o=this.poolData.actions[r])||void 0===o||!o.active)throw new Error(`Invalid ask mint state ${this.address.toBase58()}`);const u=Nt(this.poolData.weights,this.poolData.weights[a]),c=Nt(this.poolData.weights,this.poolData.weights[r]),m=((e,t,n,i,o,s)=>{const a=Number(t.toString()),r=Number(n.toString());return a*(1-(r/(r+e))**(o/i))*(1-Number(s.toString())/1e9)})(Number(n.toString()),this.poolData.reserves[r],this.poolData.reserves[a],c,u,this.poolData.fee.add(this.poolData.taxFee)),d=((e,t)=>{const n=Ct(0,t),i=Ct(e,t);return i<n?0:1-n/i})(Number(n.toString()),{balanceIn:this.poolData.reserves[a],balanceOut:this.poolData.reserves[r],weightIn:u,weightOut:c,swapFee:this.poolData.fee.add(this.poolData.taxFee)}),l=this.poolData.fee.add(this.poolData.taxFee).toNumber()/10**9,p=m/(1-l)*l;return{notEnoughLiquidity:!1,inAmount:n,outAmount:F.default.BigInt(Math.floor(m)),feeAmount:F.default.BigInt(Math.floor(p)),feeMint:t.toBase58(),feePct:0,priceImpactPct:d}}getSwapLegAndAccounts(t){var n;if(!this.poolData)throw new Error(`Invalid pool data ${this.address.toBase58()}`);const i=this.poolData.mints.findIndex((e=>e.equals(t.sourceMint))),o=this.poolData.mints.findIndex((e=>e.equals(t.destinationMint))),[s]=e.PublicKey.findProgramAddressSync([Buffer.from("treasurer"),this.address.toBuffer()],Oe),a=At({tokenMintAddress:t.destinationMint,walletAddress:this.poolData.taxMan});return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,sourceMint:s,destinationMint:a}){return[pt({balansol:{}}),kt.instruction.balansolSwap({accounts:{swapProgram:Oe,authority:o,pool:t.pool,taxMan:t.taxMan,bidMint:s,treasurer:t.treasurer,srcTreasury:t.srcTreasury,srcAssociatedTokenAccount:n,askMint:a,dstTreasury:t.dstTreasury,dstAssociatedTokenAccount:i,dstTokenAccountTaxman:t.dstTokenAccountTaxman,systemProgram:e.SystemProgram.programId,tokenProgram:c.TOKEN_PROGRAM_ID,associatedTokenProgram:c.ASSOCIATED_TOKEN_PROGRAM_ID,rent:e.SYSVAR_RENT_PUBKEY},remainingAccounts:t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[yt]}).keys]}({...t,additionalArgs:{pool:this.address,taxMan:this.poolData.taxMan,dstTokenAccountTaxman:a,treasurer:s,srcTreasury:this.poolData.treasuries[i],dstTreasury:this.poolData.treasuries[o],referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.destinationMint.toBase58())}})}get reserveTokenMints(){return this.poolData.mints}}Ut.getIDL=()=>Kt;const Wt=new r.BorshCoder(g.IDL);class Xt{constructor(e,t,n){this.address=void 0,this.id=void 0,this.label="Crema",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.clmmpoolData=void 0,this.reserveTokenDecimals=void 0,this.tickArrayMapPubkey=void 0,this.feeRate=void 0,this.tickArrayMap=void 0,this.tickArrayPubkeys=[],this.tickArrays=[],this.arrayStartIndex=void 0,this.swapTicks=void 0,this.address=e,this.id=e.toBase58(),this.clmmpoolData=Wt.accounts.decode("clmmpool",t.data),this.feeRate=this.clmmpoolData.feeRate,this.tickArrayMapPubkey=g.PDAUtil.getTickArrayMapPDA(ue,e).publicKey,this.reserveTokenDecimals=[n.decimalA,n.decimalB],this.arrayStartIndex=0}getAccountsForUpdate(){return[this.address,this.tickArrayMapPubkey,...this.tickArrayPubkeys]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing poolData ${this.address.toBase58()}`);this.clmmpoolData=Wt.accounts.decode("clmmpool",t.data),this.feeRate=this.clmmpoolData.feeRate;const n=e.get(this.tickArrayMapPubkey.toBase58());if(!n)throw new Error(`Missing tickArrayMap ${this.tickArrayMapPubkey.toBase58()}`);const i=Wt.accounts.decode("tickArrayMap",n.data);this.tickArrayPubkeys=this.getTickArrayPubkeys(this.address,i),this.tickArrayMap=i;const o=g.TickUtil.getArrayIndex(this.clmmpoolData.currentTickIndex,this.clmmpoolData.tickSpacing);let s=!1;const a=[];for(let t=0;t<this.tickArrayPubkeys.length;t++){const n=e.get(this.tickArrayPubkeys[t].toBase58());if(n){const e=Wt.accounts.decode("tickArray",n.data);!1===s&&e.arrayIndex>=o&&(s=!0,this.arrayStartIndex=t),a.push({address:this.tickArrayPubkeys[t],data:e})}}this.tickArrays=a;const r={aToB:[],bToA:[]};for(let e=this.arrayStartIndex;e>this.arrayStartIndex-3;e--){let t=this.tickArrays[e];t&&r.aToB.push(t)}for(let e=this.arrayStartIndex;e<this.arrayStartIndex+3;e++){let t=this.tickArrays[e];t&&r.bToA.push(t)}this.swapTicks={aToB:[],bToA:[]},[r.aToB,r.bToA].forEach(((e,t)=>{for(let n=0;n<e.length;n++){const i=e[n];if(0===t)for(let e=g.TICK_ARRAY_SIZE-1;e>=0;e--)i.data&&i.data.ticks[e].isInitialized&&this.swapTicks.aToB.push(i.data.ticks[e]);else for(let e=0;e<g.TICK_ARRAY_SIZE;e++)i.data&&i.data.ticks[e].isInitialized&&this.swapTicks.bToA.push(i.data.ticks[e])}}))}getTickArrayPubkeys(e,t){let n=[];for(let e=0;e<868;e++){let i=t.bitmap[e];for(let e=0;e<8;e++)n.push((i>>e&1)>0)}const i=[];for(let t=0;t<n.length;t++)if(n[t]){const n=g.PDAUtil.getTickArrayPDA(ue,e,t).publicKey;i.push(n)}return i}getQuote(e){let t,n,i;if(!this.swapTicks)throw new Error("swapTicks is not initialized");"ExactIn"===e.swapMode?(t=e.destinationMint,i=!0):(t=e.sourceMint,i=!1),n=!!e.sourceMint.equals(this.reserveTokenMints[0]);const o=new l.BN(e.amount.toString()),s=g.computeSwap(n,i,o,this.clmmpoolData,this.swapTicks[n?"aToB":"bToA"]),a=g.TickMath.sqrtPriceX64ToPrice(this.clmmpoolData.currentSqrtPrice,this.reserveTokenDecimals[0],this.reserveTokenDecimals[1]).toNumber(),r=g.TickMath.sqrtPriceX64ToPrice(s.nextSqrtPrice,this.reserveTokenDecimals[0],this.reserveTokenDecimals[1]).toNumber();let u=!1;if(u=i?s.amountIn.lt(o):s.amountOut.lt(o),u)throw new Error("not enough liquidity");return{notEnoughLiquidity:u,inAmount:F.default.BigInt(s.amountIn),outAmount:F.default.BigInt(s.amountOut),feeMint:t.toString(),feeAmount:F.default.multiply(F.default.BigInt(e.amount),F.default.BigInt(this.feeRate)),feePct:this.feeRate,priceImpactPct:Math.abs(a-r)/a}}getSwapLegAndAccounts(e){let t,n;if(!this.swapTicks)throw new Error("swapTicks is not initialized");const i=g.PDAUtil.getClmmConfigPDA(ue).publicKey;if(t=!!e.sourceMint.equals(this.reserveTokenMints[0]),n="ExactIn"===e.swapMode,!this.tickArrayMap)throw new Error("tickArrayMap is not initialized");const o=new l.BN(e.amount.toString()),s=g.computeSwap(t,n,o,this.clmmpoolData,this.swapTicks[t?"aToB":"bToA"],this.address,this.tickArrayMap);return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i,sourceMint:o}){const{aToB:s,accountA:a,accountB:r}=o.equals(e.tokenA)?{aToB:!0,accountA:t,accountB:n}:{aToB:!1,accountA:n,accountB:t};let u=[];return e.remainingAccounts.forEach((e=>{u.push({pubkey:e,isSigner:!1,isWritable:!0})})),u.push(yt),[pt(it(s)),kt.instruction.cremaSwap({accounts:{swapProgram:ue,clmmConfig:e.clmmConfig,clmmpool:e.clmmpool,tokenA:e.tokenA,tokenB:e.tokenB,accountA:a,accountB:r,tokenAVault:e.tokenAVault,tokenBVault:e.tokenBVault,tickArrayMap:e.tickArrayMap,owner:i,partner:ce,partnerAtaA:At({walletAddress:ce,tokenMintAddress:e.tokenA}),partnerAtaB:At({walletAddress:ce,tokenMintAddress:e.tokenB}),tokenProgram:c.TOKEN_PROGRAM_ID},remainingAccounts:u}).keys]}({additionalArgs:{clmmConfig:i,clmmpool:this.address,tokenA:this.clmmpoolData.tokenA,tokenB:this.clmmpoolData.tokenB,tokenAVault:this.clmmpoolData.tokenAVault,tokenBVault:this.clmmpoolData.tokenBVault,tickArrayMap:this.tickArrayMapPubkey,remainingAccounts:s.swapTickArrays},...e})}get reserveTokenMints(){return[this.clmmpoolData.tokenA,this.clmmpoolData.tokenB]}}class Yt{static async getStateFromStateAccount(e){const t=await e.getAccountInfo($e);if(!t)throw new Error("State account not found");return(e=>{const t=Je.decode(e.data);return{isInitialized:Boolean(t.isInitialized),stateOwner:t.stateOwner,feeOwner:t.feeOwner,initialSupply:t.initialSupply,returnFeeNumerator:t.returnFeeNumerator.toNumber(),fixedFeeNumerator:t.fixedFeeNumerator.toNumber(),feeDenominator:t.feeDenominator.toNumber(),curveType:t.curveType,curveParameters:t.curveParameters}})(t)}constructor(t,n,o){this.id=void 0,this.label="Cropper",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.feePct=void 0,this.params=void 0,this.id=t.toBase58(),this.poolState=et(t,n),this.params={...o,tokenAFeeAccount:new e.PublicKey(o.tokenAFeeAccount),tokenBFeeAccount:new e.PublicKey(o.tokenBFeeAccount)},this.feePct=new q.default(this.params.fixedFeeNumerator).add(new q.default(this.params.returnFeeNumerator)).div(this.params.feeDenominator),this.calculator=new i.TokenSwapConstantProduct(new i.Fraction(F.default.BigInt(this.params.fixedFeeNumerator),F.default.BigInt(this.params.feeDenominator)),new i.Fraction(F.default.BigInt(this.params.returnFeeNumerator),F.default.BigInt(this.params.feeDenominator)))}getAccountsForUpdate(){return[this.poolState.tokenAAccount,this.poolState.tokenBAccount]}update(e){const t=j(e,this.getAccountsForUpdate());this.tokenReserveAmounts=G(t)}getQuote({sourceMint:e,amount:t}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const n=this.poolState.mintA.equals(e)?1:0,i=this.calculator.exchange(this.tokenReserveAmounts,t,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){const t=e.sourceMint.equals(this.poolState.mintA)?this.params.tokenAFeeAccount:this.params.tokenBFeeAccount;return function({poolState:e,feeAccount:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[a,r]=n.equals(e.mintA)?[e.tokenAAccount,e.tokenBAccount]:[e.tokenBAccount,e.tokenAAccount];return[pt({cropper:{}}),kt.instruction.cropperSwap({accounts:{tokenSwapProgram:e.programId,tokenProgram:c.TOKEN_PROGRAM_ID,swap:e.ammId,swapState:$e,authority:e.authority,userTransferAuthority:s,source:i,swapSource:a,swapDestination:r,destination:o,poolMint:e.poolMint,poolFee:t}}).keys]}({poolState:this.poolState,feeAccount:t,...e})}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}Yt.decodePoolState=et;class jt{constructor(e,t){this.program=void 0,this.pool=void 0,this.bitmapCache=void 0,this.tickCache=void 0,this.accountsToFetch={bitmaps:[],ticks:[]},this.program=e,this.pool=t,this.bitmapCache=new Map,this.tickCache=new Map}async eagerLoadCache(e,t){const n=F.default.toNumber(F.default.divide(F.default.BigInt(e),F.default.BigInt(t))),{wordPos:i}=h.tickPosition(n);try{const e=[],{wordPos:n}=h.tickPosition(Math.floor(h.TickMath.MIN_TICK/t)),{wordPos:s}=h.tickPosition(Math.floor(h.TickMath.MAX_TICK/t)),a=Math.max(i-10,n),u=Math.min(i+10,s);for(let t=a;t<u;t++)e.push(this.getBitmapAddressSync(t));const c=await this.program.account.tickBitmapState.fetchMultiple(e),m=[];for(let n=0;n<u-a;n++){var o;const i=n+a,s=null===(o=c[n])||void 0===o?void 0:o.word,u=s?h.generateBitmapWord(s):new r.BN(0);if(this.bitmapCache.set(i,{address:e[n],word:u}),u&&!u.eqn(0))for(let e=0;e<256;e++)if(u.shrn(e).and(new r.BN(1)).eqn(1)){const n=this.getTickAddressSync(((i<<8)+e)*t);m.push(n)}}const d=await this.program.account.tickState.fetchMultiple(m);for(const e in m){const t=d[e];if(!t)continue;const{tick:n,liquidityNet:i}=t;this.tickCache.set(n,{address:m[e],liquidityNet:F.default.BigInt(i)})}}catch(e){}}lazyLoadAccountsToCache(e,t){const n=F.default.toNumber(F.default.divide(F.default.BigInt(e),F.default.BigInt(t))),{wordPos:i}=h.tickPosition(n),o=[],s=[],{wordPos:a}=h.tickPosition(Math.floor(h.TickMath.MIN_TICK/t)),{wordPos:u}=h.tickPosition(Math.floor(h.TickMath.MAX_TICK/t)),c=Math.max(i-10,a),m=Math.min(i+10,u);for(let e=c;e<m;e++){o.push(this.getBitmapAddressSync(e));const t=this.bitmapCache.get(e);s.push(t)}const d=[];for(let e=0;e<m-c;e++){var l,p;const n=e+c,i=null!==(l=null===(p=s[e])||void 0===p?void 0:p.word)&&void 0!==l?l:new r.BN(0);if(this.bitmapCache.set(n,{address:o[e],word:i}),i&&!i.eqn(0))for(let e=0;e<256;e++)if(i.shrn(e).and(new r.BN(1)).eqn(1)){const i=this.getTickAddressSync(((n<<8)+e)*t);d.push(i)}}return this.accountsToFetch={bitmaps:o,ticks:d},[...o,...d]}getTick(e){let t=this.tickCache.get(e);if(!t)throw new Error("Tick not cached");return{address:t.address,liquidityNet:t.liquidityNet}}async getTickAddress(e){return this.getTickAddressSync(e)}getTickAddressSync(e){return u.findProgramAddressSync([h.TICK_SEED,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),h.u32ToSeed(this.pool.fee),h.u32ToSeed(e)],this.program.programId)[0]}async getBitmapAddress(e){return this.getBitmapAddressSync(e)}getBitmapAddressSync(e){return u.findProgramAddressSync([h.BITMAP_SEED,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),h.u32ToSeed(this.pool.fee),h.u16ToSeed(e)],this.program.programId)[0]}getBitmap(e){let t=this.bitmapCache.get(e);if(!t)throw new Error("Bitmap not cached");return t}nextInitializedTickWithinOneWord(e,t,n){let i=F.default.toNumber(F.default.divide(F.default.BigInt(e),F.default.BigInt(n)));e<0&&e%n!=0&&(i-=1),t||(i+=1);const{wordPos:o,bitPos:s}=h.tickPosition(i),a=this.getBitmap(o),{next:r,initialized:u}=h.nextInitializedBit(a.word,s,t);return[h.buildTick(o,r,n),u,o,s,a.address]}updateCachedAccountInfos(e){for(const t of this.accountsToFetch.bitmaps){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickBitmapState",n.data);this.bitmapCache.set(e.wordPos,{address:t,word:h.generateBitmapWord(e.word)})}}for(const t of this.accountsToFetch.ticks){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickState",n.data);this.tickCache.set(e.tick,{address:t,liquidityNet:F.default.BigInt(e.liquidityNet)})}}}}const Gt=F.default.BigInt(1e6),Qt=new r.Program(h.IDL,Se,Xe);class zt{constructor(e,t){this.address=void 0,this.label="Cykura",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolState=void 0,this.pool=void 0,this.tickDataProvider=void 0,this.tokens=void 0,this.vaults=void 0,this.feePct=void 0,this.fee=void 0,this.address=e,this.id=e.toBase58(),this.poolState=Qt.coder.accounts.decode("poolState",t.data);const{token0:n,token1:i,fee:o,sqrtPriceX32:s,liquidity:a,tick:r}=this.poolState;this.tickDataProvider=new jt(Qt,{token0:n,token1:i,fee:o}),this.tokens={token0:new S.Token(101,n,0,"",""),token1:new S.Token(101,i,0,"","")},this.pool=new h.Pool(this.tokens.token0,this.tokens.token1,o,F.default.BigInt(s.toString()),F.default.BigInt(a.toString()),r,this.tickDataProvider),this.vaults={vault0:u.findProgramAddressSync([this.address.toBuffer(),c.TOKEN_PROGRAM_ID.toBuffer(),n.toBuffer()],c.ASSOCIATED_TOKEN_PROGRAM_ID)[0],vault1:u.findProgramAddressSync([this.address.toBuffer(),c.TOKEN_PROGRAM_ID.toBuffer(),i.toBuffer()],c.ASSOCIATED_TOKEN_PROGRAM_ID)[0]},this.fee=F.default.BigInt(this.poolState.fee),this.feePct=this.poolState.fee/F.default.toNumber(Gt)}getAccountsForUpdate(){return[this.address,...this.tickDataProvider.lazyLoadAccountsToCache(this.pool.tickCurrent,this.pool.tickSpacing)]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Could not find poolAccountInfo ${this.address.toBase58()}`);this.poolState=Qt.coder.accounts.decode("poolState",t.data);const{fee:n,sqrtPriceX32:i,liquidity:o,tick:s}=this.poolState;this.pool=new h.Pool(this.tokens.token0,this.tokens.token1,n,F.default.BigInt(i.toString()),F.default.BigInt(o.toString()),s,this.tickDataProvider),this.tickDataProvider.updateCachedAccountInfos(e)}getQuote({sourceMint:e,amount:t}){const n=e.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[o,s,a]=this.pool.getOutputAmount(S.CurrencyAmount.fromRawAmount(n,t)),r=i.toDecimal(F.default.subtract(this.pool.sqrtRatioX32,s.sqrtRatioX32)).div(this.pool.sqrtRatioX32.toString());return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.quotient,feeAmount:F.default.divide(F.default.multiply(t,this.fee),Gt),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:r.toNumber()}}getSwapLegAndAccounts(e){const[t,n]=e.sourceMint.equals(this.poolState.token0)?[this.vaults.vault0,this.vaults.vault1]:[this.vaults.vault1,this.vaults.vault0],i=u.findProgramAddressSync([h.OBSERVATION_SEED,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),h.u32ToSeed(this.poolState.fee),h.u16ToSeed(this.poolState.observationIndex)],Se)[0],o=e.sourceMint.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[,,s]=this.pool.getOutputAmount(S.CurrencyAmount.fromRawAmount(o,e.amount)),a=u.findProgramAddressSync([h.OBSERVATION_SEED,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),h.u32ToSeed(this.poolState.fee),h.u16ToSeed((this.poolState.observationIndex+1)%this.poolState.observationCardinalityNext)],Se)[0],r={poolAddress:this.address,inputVault:t,outputVault:n,nextObservationState:a,lastObservationState:i,swapAccountMetas:s};return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){return[pt({cykura:{}}),kt.instruction.cykuraSwap({accounts:{swapProgram:Se,signer:i,factoryState:fe,poolState:e.poolAddress,inputTokenAccount:t,outputTokenAccount:n,inputVault:e.inputVault,outputVault:e.outputVault,lastObservationState:e.lastObservationState,coreProgram:Se,tokenProgram:c.TOKEN_PROGRAM_ID},remainingAccounts:[...e.swapAccountMetas,{pubkey:e.nextObservationState,isSigner:!1,isWritable:!0},yt]}).keys]}({...e,additionalArgs:r})}get reserveTokenMints(){return[this.poolState.token0,this.poolState.token1]}}const Zt={DkwiQyA2JfD8ARfvMbMqu2DD4XKRkewRZVDE94SZNxSS:{price:1}},Ht=f.getDeltafiDexV2(Ie,Xe),Jt=e=>c.u64.fromBuffer(e.data.slice(64,72)),$t=e=>c.u64.fromBuffer(e.data.slice(36,44));function en(e){const t=e.readBigUInt64LE();return Number(t)}class tn{constructor(t,n){this.address=void 0,this.id=void 0,this.label="GooseFX",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.pairLayout=void 0,this.quoter=void 0,this.gooseFxAccounts=void 0,this.fixedAccounts=void 0,this.oracleAccounts=[],this.quoteParams=void 0,this.isQuoteInvalid=!0,this.slot=void 0,this.address=t,this.id=t.toBase58(),this.pairLayout=k.PAIR_LAYOUT.decode(n.data);const[i,o]=this.pairLayout.mints,s=new k.SyncSwap;this.quoter=s.getSyncQuoter(i,o),this.gooseFxAccounts=this.quoter.getAccounts();const{pairAddress:a,sslIn:r,sslOut:u,liabilityVaultIn:c,liabilityVaultOut:m,swappedLiabilityVaultIn:d,swappedLiabilityVaultOut:l}=this.gooseFxAccounts;this.fixedAccounts=[e.SYSVAR_CLOCK_PUBKEY,a,r,u,c,m,d,l],this.updateOracles()}updateOracles(){const e=Number(this.pairLayout.nOracle.toString()),t=this.pairLayout.oracles.slice(0,e).reduce(((e,t)=>{const n=Number(t.n);for(const i of t.elements.slice(0,n))e.push(i.address);return e}),[]);this.oracleAccounts=t}getAccountsForUpdate(){return[...this.fixedAccounts,...this.oracleAccounts]}isSuspended(e){if(this.quoteParams){let t=Boolean(this.quoteParams.suspended);if(void 0!==e)for(const n of this.quoteParams.publishedSlots)t||=n+this.quoteParams.maxDelay<=e;return t}return!0}update(e){var t;const[n,i,o,s,a,r,u,c]=j(e,this.fixedAccounts);if(!(i&&o&&s&&a&&r&&u&&c))throw new Error("Missing account data");const m=k.wasm.OracleRegistry;this.pairLayout=k.PAIR_LAYOUT.decode(i.data);const{oracles:d,nOracle:l,maxDelay:p}=this.pairLayout,g=Number(l.toString()),h=new m;this.updateOracles();let S=[];for(const t of d.slice(0,g)){const n=Number(t.n);for(const i of t.elements.slice(0,n)){const t=e.get(i.address.toBase58());if(!t)return void(this.isQuoteInvalid=!0);h.add_oracle(i.address.toBuffer(),t.data),S.push(BigInt(A.parsePriceData(t.data).aggregate.publishSlot))}}this.slot=BigInt(en(n.data)),this.isQuoteInvalid&&(this.isQuoteInvalid=!1),null===(t=this.quoteParams)||void 0===t||t.registry.free(),this.quoteParams={liabilityIn:BigInt(Jt(a).toString()),liabilityOut:BigInt(Jt(r).toString()),pairData:i.data,sslInData:o.data,sslOutData:s.data,swappedLiabilityIn:BigInt(Jt(u).toString()),swappedLiabilityOut:BigInt(Jt(c).toString()),registry:h,suspended:new k.SSL(o).isSuspended()||new k.SSL(s).isSuspended(),maxDelay:p,publishedSlots:S}}getQuote({sourceMint:e,amount:t}){if(!this.quoteParams||this.isQuoteInvalid)throw new Error("Missing quote data");if(this.isSuspended(this.slot))throw new Error("Quote suspended");const{quoteParams:n}=this,i=k.wasm.swap;let o;const s=e.equals(this.pairLayout.mints[0]);o=s?i(n.sslInData.slice(),n.sslOutData.slice(),n.pairData.slice(),n.liabilityIn,n.liabilityOut,n.swappedLiabilityIn,n.swappedLiabilityOut,n.registry,BigInt(t.toString())):i(n.sslOutData.slice(),n.sslInData.slice(),n.pairData.slice(),n.liabilityOut,n.liabilityIn,n.swappedLiabilityOut,n.swappedLiabilityIn,n.registry,BigInt(t.toString()));const a=this.pairLayout.feeRates[s?0:1],r={notEnoughLiquidity:!1,inAmount:F.default.BigInt(o.amount_in.toString()),outAmount:F.default.BigInt(o.amount_out.toString()),feeAmount:F.default.BigInt(o.fee_paid.toString()),feeMint:e.toBase58(),feePct:a/1e4,priceImpactPct:o.price_impact};return o.free(),r}getSwapLegAndAccounts(e){var t;if(!this.quoteParams)throw new Error("Missing quote data");const n=e.sourceMint.equals(this.pairLayout.mints[0]),{gooseFxAccounts:i}=this,[o,s,a,r,u,m]=n?[i.sslIn,i.liabilityVaultIn,i.swappedLiabilityVaultIn,i.sslOut,i.liabilityVaultOut,i.swappedLiabilityVaultOut]:[i.sslOut,i.liabilityVaultOut,i.swappedLiabilityVaultOut,i.sslIn,i.liabilityVaultIn,i.swappedLiabilityVaultIn];return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=[];return o.push(e.referrer?{pubkey:e.referrer,isSigner:!1,isWritable:!0}:yt),e.oracles.forEach((e=>{o.push({pubkey:e,isSigner:!1,isWritable:!1})})),o.push(yt),[pt({gooseFx:{}}),kt.instruction.goosefxSwap({accounts:{swapProgram:De,controller:Re,pair:e.pair,sslIn:e.sslIn,sslOut:e.sslOut,liabilityVaultIn:e.liabilityVaultIn,swappedLiabilityVaultIn:e.swappedLiabilityVaultIn,liabilityVaultOut:e.liabilityVaultOut,swappedLiabilityVaultOut:e.swappedLiabilityVaultOut,userInAta:t,userOutAta:n,feeCollectorAta:e.feeCollectorAta,userWallet:i,feeCollector:e.feeCollector,tokenProgram:c.TOKEN_PROGRAM_ID},remainingAccounts:o}).keys]}({additionalArgs:{pair:this.gooseFxAccounts.pairAddress,sslIn:o,sslOut:r,liabilityVaultIn:s,swappedLiabilityVaultIn:a,liabilityVaultOut:u,swappedLiabilityVaultOut:m,feeCollectorAta:At({walletAddress:this.pairLayout.feeCollector,tokenMintAddress:e.sourceMint}),feeCollector:this.pairLayout.feeCollector,oracles:this.oracleAccounts,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.sourceMint.toBase58())},...e})}get reserveTokenMints(){return this.pairLayout.mints}}const nn=new r.Program(y.IDL,pe,Xe);class on{static parsePoolStructure(e){return nn.coder.accounts.decode("pool",e.data)}static parseTickmap(e){return nn.coder.accounts.decode("tickmap",e.data)}static parseTick(e){return{...nn.coder.accounts.decode("tick",e.data)}}static getQuote(e,t,n,i,o,s){const{currentTickIndex:a,fee:r,tickSpacing:u,tokenX:c,liquidity:m,sqrtPrice:d}=e,p={currentTickIndex:a,tickSpacing:u,liquidity:m,fee:r,sqrtPrice:d},g={xToY:i.equals(c),byAmountIn:s===exports.SwapMode.ExactIn,swapAmount:new l.BN(o.toString()),priceLimit:i.equals(c)?y.calculatePriceSqrt(y.MIN_TICK):y.calculatePriceSqrt(y.MAX_TICK),slippage:y.toDecimal(0),ticks:t,tickmap:n,pool:p};return y.simulateSwap(g)}static getTickIndexToTickPubkeyHash(e,t,n){if(!n){const{tickAddress:n}=this.getTickAddress(e,t.currentTickIndex),i=new Map;return i.set(t.currentTickIndex,n),i}const i=y.findClosestTicks(n.bitmap,t.currentTickIndex,t.tickSpacing,y.TICK_CROSSES_PER_IX,Infinity,"down"),o=y.findClosestTicks(n.bitmap,t.currentTickIndex,t.tickSpacing,y.TICK_CROSSES_PER_IX,Infinity,"up");return i.concat([t.currentTickIndex]).concat(o).reduce(((t,n)=>{const{tickAddress:i}=this.getTickAddress(e,n);return t.set(n,i),t}),new Map)}static getTickAddress(t,n){const i=Buffer.alloc(4);i.writeInt32LE(n);const[o,s]=e.PublicKey.findProgramAddressSync([Buffer.from(r.utils.bytes.utf8.encode("tickv1")),t.toBuffer(),i],nn.programId);return{tickAddress:o,tickBump:s}}}class sn{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Invariant",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.poolStructure=void 0,this.tickmap=void 0,this.tickPkToTickIndexHash=void 0,this.ticks=new Map,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.poolStructure=on.parsePoolStructure(t),this.tickPkToTickIndexHash=on.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.feePct=new q.default(this.poolStructure.fee.v.toString()).div(y.DENOMINATOR.toString()).toNumber()}getAccountsForUpdate(){const e=this.tickPkToTickIndexHash.values();return[this.address,this.poolStructure.tickmap,...e]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing invariant pool data ${this.address.toBase58()}`);this.poolStructure=on.parsePoolStructure(t);const n=e.get(this.poolStructure.tickmap.toBase58());n&&(this.tickmap=on.parseTickmap(n)),this.tickPkToTickIndexHash=on.getTickIndexToTickPubkeyHash(this.address,this.poolStructure,this.tickmap),this.ticks.clear();for(const[t,n]of this.tickPkToTickIndexHash){const i=e.get(n.toBase58());if(!i)continue;const o=on.parseTick(i);this.ticks.set(t,o)}}getQuote({sourceMint:e,amount:t,swapMode:n}){if(!this.tickmap)throw new Error("Missing tickmap");const i=on.getQuote(this.poolStructure,this.ticks,this.tickmap,e,t,n),o=new q.default(i.priceImpact.toString()).div(y.DENOMINATOR.toString()).toNumber();if(0!==i.status)throw new Error(`Invariant simulation failed: ${this.address}`);return{notEnoughLiquidity:!1,inAmount:F.default.BigInt(i.accumulatedAmountIn.toString()),outAmount:F.default.BigInt(i.accumulatedAmountOut.toString()),feeAmount:F.default.BigInt(i.accumulatedFee.toString()),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:o}}getSwapLegAndAccounts(e){var t;if(!this.tickmap)throw new Error("Missing tickmap");const n=on.getQuote(this.poolStructure,this.ticks,this.tickmap,e.sourceMint,e.amount,e.swapMode),i={};this.tickPkToTickIndexHash.forEach(((e,t)=>{i[t]=e}));const o=n.crossedTicks.concat(this.poolStructure.currentTickIndex).map((e=>{const t=i[e];if(!t)throw new Error("Missing tick account.");return t})),s=e.sourceMint.equals(this.poolStructure.tokenX);return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const[o,s]=e.xToY?[t,n]:[n,t],a=e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[];return e.crossedTickAddresses.forEach((e=>{a.push({pubkey:e,isSigner:!1,isWritable:!0})})),a.push(yt),[pt(rt(e.xToY)),kt.instruction.invariantSwap({accounts:{swapProgram:pe,tokenProgram:c.TOKEN_PROGRAM_ID,owner:i,state:ge,pool:e.pool,tickmap:e.tickmap,accountX:o,accountY:s,reserveX:e.reserveX,reserveY:e.reserveY,programAuthority:he},remainingAccounts:a}).keys]}({...e,additionalArgs:{xToY:s,pool:this.address,tickmap:this.poolStructure.tickmap,reserveX:this.poolStructure.tokenXReserve,reserveY:this.poolStructure.tokenYReserve,crossedTickAddresses:o,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.sourceMint.toBase58())}})}get reserveTokenMints(){return[this.poolStructure.tokenX,this.poolStructure.tokenY]}}class an{constructor(e,t){var n;this.ammAccountInfo=void 0,this.id=void 0,this.label="Lifinity",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapState=void 0,this.poolInfo=void 0,this.ammData=void 0,this.ammAccountInfo=t,this.id=e.toBase58(),this.swapState=((e,t)=>{const n=t.owner,i=w.LIFINITY_AMM_LAYOUT.decode(t.data),[o]=u.findProgramAddressSync([e.toBuffer()],n);return{programId:n,authority:o,amm:e,tokenAMint:i.tokenAMint,tokenBMint:i.tokenBMint,poolMint:i.poolMint,feeAccount:i.poolFeeAccount,pythAccount:i.pythAccount,pythPcAccount:i.pythPcAccount,configAccount:i.configAccount,poolCoinTokenAccount:i.tokenAAccount,poolCoinMint:i.tokenAMint,poolPcTokenAccount:i.tokenBAccount,poolPcMint:i.tokenBMint}})(e,t),this.poolInfo={amm:(n=this.swapState).amm.toBase58(),configAccount:n.configAccount.toBase58(),feeAccount:n.feeAccount.toBase58(),pythAccount:n.pythAccount.toBase58(),pythPcAccount:n.pythPcAccount.toBase58(),poolCoinMint:n.poolCoinMint.toBase58(),poolCoinTokenAccount:n.poolCoinTokenAccount.toBase58(),poolMint:n.poolMint.toBase58(),poolPcTokenAccount:n.poolPcTokenAccount.toBase58(),poolPcMint:n.poolPcMint.toBase58(),poolCoinDecimal:0,poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:0}}getAccountsForUpdate(){return[this.swapState.poolCoinTokenAccount,this.swapState.poolPcTokenAccount,this.swapState.configAccount,this.swapState.pythAccount,this.swapState.pythPcAccount]}update(e){const t=[];this.getAccountsForUpdate().forEach(((n,i)=>{const o=e.get(n.toBase58());o&&t.push({publicKey:n,account:o})})),this.ammData=w.getParsedData([{publicKey:this.swapState.amm,account:this.ammAccountInfo},...t],this.poolInfo)}getQuote({sourceMint:e,amount:t}){if(!this.ammData)throw new Error("Accounts not loaded, missing ammData");if(this.isTradeFrozen)throw new Error("Trade is frozen");const n=this.swapState.poolCoinMint.equals(e)?w.TradeDirection.AtoB:w.TradeDirection.BtoA;if(!this.ammData.pyth.status.equals(1)||this.ammData.pythPc&&!this.ammData.pythPc.status.equals(1))throw new Error("Pyth accounts are outdated");const i=new q.default(t.toString()),o=w.getCurveAmount(i,this.ammData.pyth.publishSlot.toNumber(),this.ammData.amm,this.ammData.fees,this.ammData.coinBalance,this.ammData.pcBalance,this.ammData.config,this.ammData.pyth,this.ammData.pythPc,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:F.default.BigInt(o.amountSwapped.toString()),feeAmount:F.default.BigInt(o.fee.ceil().toString()),feeMint:e.toBase58(),feePct:o.feePercent.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({swapState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,a]=t.equals(e.tokenAMint)?[e.poolCoinTokenAccount,e.poolPcTokenAccount]:[e.poolPcTokenAccount,e.poolCoinTokenAccount];return[pt({lifinity:{}}),kt.instruction.lifinitySwap({accounts:{swapProgram:e.programId,authority:e.authority,amm:e.amm,userTransferAuthority:o,sourceInfo:n,destinationInfo:i,swapSource:s,swapDestination:a,poolMint:e.poolMint,feeAccount:e.feeAccount,tokenProgram:c.TOKEN_PROGRAM_ID,pythAccount:e.pythAccount,pythPcAccount:e.pythPcAccount,configAccount:e.configAccount}}).keys]}({swapState:this.swapState,...e})}get reserveTokenMints(){return[this.swapState.poolCoinMint,this.swapState.poolPcMint]}get isTradeFrozen(){var e;return 1===(null===(e=this.ammData)||void 0===e?void 0:e.amm.freezeTrade)}}class rn{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Lifinity V2",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.ammState=void 0,this.poolInfo=void 0,this.ammData=void 0,this.slot=void 0,this.address=e;const n=new r.BorshAccountsCoder(P.IDL);var i;this.id=e.toBase58(),this.ammState=n.decode("amm",t.data),this.poolInfo={amm:this.id,poolMint:(i=this.ammState).poolMint.toBase58(),feeAccount:i.feeAccount.toBase58(),oracleMainAccount:i.oracleMainAccount.toBase58(),oracleSubAccount:i.oracleSubAccount.toBase58(),oraclePcAccount:i.oraclePcAccount.toBase58(),poolCoinTokenAccount:i.tokenAAccount.toBase58(),poolCoinMint:i.tokenAMint.toBase58(),poolCoinDecimal:0,poolPcTokenAccount:i.tokenBAccount.toBase58(),poolPcMint:i.tokenBMint.toBase58(),poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:i.baseDecimals}}getAccountsForUpdate(){return[this.address,this.ammState.tokenAAccount,this.ammState.tokenBAccount,this.ammState.oracleMainAccount,this.ammState.oracleSubAccount,this.ammState.oraclePcAccount,e.SYSVAR_CLOCK_PUBKEY]}update(e){const t=this.getAccountsForUpdate().reduce(((t,n)=>{const i=e.get(n.toBase58());return i&&t.push({publicKey:n,account:i}),t}),new Array);this.ammData=P.getParsedData(t,this.poolInfo),this.slot=en(t[t.length-1].account.data)}getQuote({sourceMint:e,amount:t}){if(!this.ammData)throw new Error("Accounts not loaded, missing ammData");if(void 0===this.slot)throw new Error("Slot not fetched");if(this.isTradeFrozen)throw new Error("Trade is frozen");const n=this.ammState.tokenAMint.equals(e)?P.TradeDirection.AtoB:P.TradeDirection.BtoA;if(this.ammData.oracleMain&&!this.ammData.oracleMain.status.equals(1)||this.ammData.oracleSub&&!this.ammData.oracleSub.status.equals(1)||this.ammData.oraclePc&&!this.ammData.oraclePc.status.equals(1))throw new Error("Pyth accounts are outdated");const i=new q.default(t.toString()),o=P.getCurveAmount(i,this.slot,this.ammData.amm,this.ammData.fees,this.ammData.coinBalance,this.ammData.pcBalance,this.ammData.config,this.ammData.oracleMain,this.ammData.oracleSub,this.ammData.oraclePc,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:F.default.BigInt(o.amountSwapped.toString()),feeAmount:F.default.BigInt(o.fee.ceil().toString()),feeMint:e.toBase58(),feePct:o.feePercent.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({ammState:e,amm:t,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s}){const[a,r]=n.equals(e.tokenAMint)?[e.tokenAAccount,e.tokenBAccount]:[e.tokenBAccount,e.tokenAAccount];return[pt({lifinityV2:{}}),kt.instruction.lifinityV2Swap({accounts:{swapProgram:xe,authority:u.findProgramAddressSync([t.toBuffer()],xe)[0],amm:t,userTransferAuthority:s,sourceInfo:i,destinationInfo:o,swapSource:a,swapDestination:r,poolMint:e.poolMint,feeAccount:e.feeAccount,tokenProgram:c.TOKEN_PROGRAM_ID,oracleMainAccount:e.oracleMainAccount,oracleSubAccount:e.oracleSubAccount,oraclePcAccount:e.oraclePcAccount}}).keys]}({ammState:this.ammState,amm:this.address,...e})}get reserveTokenMints(){return[this.ammState.tokenAMint,this.ammState.tokenBMint]}get isTradeFrozen(){return 1===this.ammState.freezeTrade}}var un="marinade_finance",cn=[{name:"initialize",accounts:[{name:"creatorAuthority",isMut:!1,isSigner:!0},{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!1,isSigner:!1},{name:"liqPool",accounts:[{name:"lpMint",isMut:!1,isSigner:!1},{name:"solLegPda",isMut:!1,isSigner:!1},{name:"msolLeg",isMut:!1,isSigner:!1}]},{name:"treasuryMsolAccount",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"data",type:{defined:"InitializeData"}}]},{name:"changeAuthority",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"data",type:{defined:"ChangeAuthorityData"}}]},{name:"addValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!1,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"score",type:"u32"}]},{name:"removeValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"}]},{name:"setValidatorScore",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"},{name:"score",type:"u32"}]},{name:"configValidatorSystem",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0}],args:[{name:"extraRuns",type:"u32"}]},{name:"deposit",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"depositStakeAccount",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeAuthority",isMut:!1,isSigner:!0},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"msolMint",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"liquidUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"addLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"lpMintAuthority",isMut:!1,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!1,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"removeLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"burnFrom",isMut:!0,isSigner:!1},{name:"burnFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"transferMsolTo",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokens",type:"u64"}]},{name:"setLpParams",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"minFee",type:{defined:"Fee"}},{name:"maxFee",type:{defined:"Fee"}},{name:"liquidityTarget",type:"u64"}]},{name:"configMarinade",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"params",type:{defined:"ConfigMarinadeParams"}}]},{name:"orderUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"burnMsolFrom",isMut:!0,isSigner:!1},{name:"burnMsolAuthority",isMut:!1,isSigner:!0},{name:"newTicketAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"claim",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"ticketAccount",isMut:!0,isSigner:!1},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"stakeReserve",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeConfig",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"updateActive",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"updateDeactivated",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"}]},{name:"deactivateStake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"splitStakeAccount",isMut:!0,isSigner:!0},{name:"splitStakeRentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"emergencyUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorManagerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"mergeStakes",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"destinationStake",isMut:!0,isSigner:!1},{name:"sourceStake",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"destinationStakeIndex",type:"u32"},{name:"sourceStakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]}],mn=[{name:"State",type:{kind:"struct",fields:[{name:"msolMint",type:"publicKey"},{name:"adminAuthority",type:"publicKey"},{name:"operationalSolAccount",type:"publicKey"},{name:"treasuryMsolAccount",type:"publicKey"},{name:"reserveBumpSeed",type:"u8"},{name:"msolMintAuthorityBumpSeed",type:"u8"},{name:"rentExemptForTokenAcc",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"stakeSystem",type:{defined:"StakeSystem"}},{name:"validatorSystem",type:{defined:"ValidatorSystem"}},{name:"liqPool",type:{defined:"LiqPool"}},{name:"availableReserveBalance",type:"u64"},{name:"msolSupply",type:"u64"},{name:"msolPrice",type:"u64"},{name:"circulatingTicketCount",type:"u64"},{name:"circulatingTicketBalance",type:"u64"},{name:"lentFromReserve",type:"u64"},{name:"minDeposit",type:"u64"},{name:"minWithdraw",type:"u64"},{name:"stakingSolCap",type:"u64"},{name:"emergencyCoolingDown",type:"u64"}]}},{name:"TicketAccountData",type:{kind:"struct",fields:[{name:"stateAddress",type:"publicKey"},{name:"beneficiary",type:"publicKey"},{name:"lamportsAmount",type:"u64"},{name:"createdEpoch",type:"u64"}]}}],dn=[{name:"Fee",type:{kind:"struct",fields:[{name:"basisPoints",type:"u32"}]}},{name:"InitializeData",type:{kind:"struct",fields:[{name:"adminAuthority",type:"publicKey"},{name:"validatorManagerAuthority",type:"publicKey"},{name:"minStake",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"liqPool",type:{defined:"LiqPoolInitializeData"}},{name:"additionalStakeRecordSpace",type:"u32"},{name:"additionalValidatorRecordSpace",type:"u32"},{name:"slotsForStakeDelta",type:"u64"}]}},{name:"LiqPoolInitializeData",type:{kind:"struct",fields:[{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"lpTreasuryCut",type:{defined:"Fee"}}]}},{name:"ChangeAuthorityData",type:{kind:"struct",fields:[{name:"admin",type:{option:"publicKey"}},{name:"validatorManager",type:{option:"publicKey"}},{name:"operationalSolAccount",type:{option:"publicKey"}},{name:"treasuryMsolAccount",type:{option:"publicKey"}}]}},{name:"ConfigMarinadeParams",type:{kind:"struct",fields:[{name:"rewardsFee",type:{option:{defined:"Fee"}}},{name:"slotsForStakeDelta",type:{option:"u64"}},{name:"minStake",type:{option:"u64"}},{name:"minDeposit",type:{option:"u64"}},{name:"minWithdraw",type:{option:"u64"}},{name:"stakingSolCap",type:{option:"u64"}},{name:"liquiditySolCap",type:{option:"u64"}},{name:"autoAddValidatorEnabled",type:{option:"bool"}}]}},{name:"LiqPool",type:{kind:"struct",fields:[{name:"lpMint",type:"publicKey"},{name:"lpMintAuthorityBumpSeed",type:"u8"},{name:"solLegBumpSeed",type:"u8"},{name:"msolLegAuthorityBumpSeed",type:"u8"},{name:"msolLeg",type:"publicKey"},{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"treasuryCut",type:{defined:"Fee"}},{name:"lpSupply",type:"u64"},{name:"lentFromSolLeg",type:"u64"},{name:"liquiditySolCap",type:"u64"}]}},{name:"List",type:{kind:"struct",fields:[{name:"account",type:"publicKey"},{name:"itemSize",type:"u32"},{name:"count",type:"u32"},{name:"newAccount",type:"publicKey"},{name:"copiedCount",type:"u32"}]}},{name:"StakeRecord",type:{kind:"struct",fields:[{name:"stakeAccount",type:"publicKey"},{name:"lastUpdateDelegatedLamports",type:"u64"},{name:"lastUpdateEpoch",type:"u64"},{name:"isEmergencyUnstaking",type:"u8"}]}},{name:"StakeSystem",type:{kind:"struct",fields:[{name:"stakeList",type:{defined:"List"}},{name:"delayedUnstakeCoolingDown",type:"u64"},{name:"stakeDepositBumpSeed",type:"u8"},{name:"stakeWithdrawBumpSeed",type:"u8"},{name:"slotsForStakeDelta",type:"u64"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"minStake",type:"u64"},{name:"extraStakeDeltaRuns",type:"u32"}]}},{name:"ValidatorRecord",type:{kind:"struct",fields:[{name:"validatorAccount",type:"publicKey"},{name:"activeBalance",type:"u64"},{name:"score",type:"u32"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"duplicationFlagBumpSeed",type:"u8"}]}},{name:"ValidatorSystem",type:{kind:"struct",fields:[{name:"validatorList",type:{defined:"List"}},{name:"managerAuthority",type:"publicKey"},{name:"totalValidatorScore",type:"u32"},{name:"totalActiveBalance",type:"u64"},{name:"autoAddValidatorEnabled",type:"u8"}]}},{name:"CommonError",type:{kind:"enum",variants:[{name:"InvalidProgramId",fields:["publicKey"]},{name:"UnexpectedAccount",fields:["publicKey"]},{name:"CalculationFailure"},{name:"AccountWithLockup"},{name:"NumberTooLow",fields:["u64","u64"]},{name:"NumberTooHigh",fields:["u64","u64"]},{name:"FeeTooHigh",fields:[{defined:"Fee"}]},{name:"FeesWrongWayRound",fields:[{defined:"Fee"},{defined:"Fee"}]},{name:"LiquidityTargetTooLow"},{name:"TicketNotDue",fields:["u64"]},{name:"TicketNotReady"},{name:"WrongBeneficiary"},{name:"InsufficientLiquidity"},{name:"InvalidValidator"}]}},{name:"InitializeError",type:{kind:"enum",variants:[{name:"WrongReserveOwner",fields:["publicKey"]},{name:"NonEmptyReserveData",fields:[{defined:"usize"}]},{name:"InvalidInitialReserveLamports",fields:["u64"]},{name:"ZeroValidatorChunkSize"},{name:"TooBigValidatorChunkSize",fields:["u32"]},{name:"ZeroCreditChunkSize"},{name:"TooBigCreditChunkSize",fields:["u32"]},{name:"TooLowCreditFee",fields:["u64"]},{name:"InvalidMintAuthority",fields:[{name:"expected",type:"publicKey"},{name:"got",type:"publicKey"}]},{name:"MintHasInitialSupply",fields:["u64"]},{name:"InvalidOwnerFeeState",fields:[{defined:"spl_token::state::AccountState"}]}]}}],ln={__proto__:null,version:"0.0.0",name:un,instructions:cn,accounts:mn,types:dn,default:{version:"0.0.0",name:un,instructions:cn,accounts:mn,types:dn}};function pn(e,t,n){return n.isZero()?e:e.mul(t).div(n)}class gn{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Marinade",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.hasDynamicAccounts=!0,this.marinadeFinanceProgram=void 0,this.marinadeStateResponse=void 0,this.liqPoolSolLegPdaAddress=void 0,this.marinadeState=void 0,this.id=e.toBase58(),this.marinadeFinanceProgram=new r.Program(ln,Ae,{}),this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data),this.address=e,this.liqPoolSolLegPdaAddress=this.findProgramDerivedAddress("liq_sol")}getAccountsForUpdate(){return[this.address,this.liqPoolSolLegPdaAddress,this.marinadeStateResponse.liqPool.msolLeg]}update(e){const[t,n,i]=j(e,this.getAccountsForUpdate());this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data);const o=a.deserializeAccount(i.data);if(!o)throw new Error(`liqPoolMSOLLeg token account cannot be deserialized ${this.marinadeStateResponse.liqPool.msolLeg.toBase58()}`);this.marinadeState=new hn(this.marinadeStateResponse,new x.default(n.lamports),o.amount)}getQuote({sourceMint:e,amount:t}){if(!this.marinadeState)throw new Error("Update was not run to create a complete marinadeState");const n=new x.default(t.toString()),i=e.equals(c.NATIVE_MINT)?this.marinadeState.depositQuote(n):this.marinadeState.liquidUnstakeQuote(n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:F.default.BigInt(i.outAmount.toString()),feeAmount:F.default.BigInt(i.feeAmount.toString()),feeMint:this.marinadeStateResponse.msolMint.toBase58(),feePct:i.feePct,priceImpactPct:0}}getSwapLegAndAccounts(t){return t.sourceMint.equals(c.NATIVE_MINT)?function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const s=u.findProgramAddressSync([Buffer.from("temp-wsol-token-account"),o.toBuffer()],Mt)[0],a=u.findProgramAddressSync([Buffer.from("temp-sol-pda"),o.toBuffer()],Mt)[0];return[pt({marinadeDeposit:{}}),kt.instruction.marinadeDeposit({accounts:{marinadeFinanceProgram:Ae,state:t.address,msolMint:t.marinadeStateResponse.msolMint,liqPoolSolLegPda:t.liqPoolSolLegPda,liqPoolMsolLeg:t.marinadeStateResponse.liqPool.msolLeg,liqPoolMsolLegAuthority:t.liqPoolMsolLegAuthority,reservePda:t.reservePda,transferFrom:a,mintTo:i,msolMintAuthority:t.msolMintAuthority,systemProgram:e.SystemProgram.programId,tokenProgram:c.TOKEN_PROGRAM_ID,userWsolTokenAccount:n,tempWsolTokenAccount:s,userTransferAuthority:o,wsolMint:c.NATIVE_MINT,rent:e.SYSVAR_RENT_PUBKEY}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress,liqPoolMsolLegAuthority:this.findProgramDerivedAddress("liq_st_sol_authority"),reservePda:this.findProgramDerivedAddress("reserve"),msolMintAuthority:this.findProgramDerivedAddress("st_mint")},...t}):function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const s=u.findProgramAddressSync([Buffer.from("temp-sol-pda"),o.toBuffer()],Mt)[0];return[pt({marinadeUnstake:{}}),kt.instruction.marinadeUnstake({accounts:{marinadeFinanceProgram:Ae,state:t.address,msolMint:t.marinadeStateResponse.msolMint,liqPoolSolLegPda:t.liqPoolSolLegPda,liqPoolMsolLeg:t.marinadeStateResponse.liqPool.msolLeg,treasuryMsolAccount:t.marinadeStateResponse.treasuryMsolAccount,getMsolFrom:n,getMsolFromAuthority:o,transferSolTo:s,systemProgram:e.SystemProgram.programId,tokenProgram:c.TOKEN_PROGRAM_ID,userWsolTokenAccount:i}}).keys]}({additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress},...t})}get reserveTokenMints(){return[c.NATIVE_MINT,this.marinadeStateResponse.msolMint]}findProgramDerivedAddress(e,t=[]){const n=[this.address.toBuffer(),Buffer.from(e),...t],[i]=u.findProgramAddressSync(n,this.marinadeFinanceProgram.programId);return i}}class hn{constructor(e,t,n){this.state=void 0,this.liqPoolSolLegPdaLamports=void 0,this.liqPoolMSOLLegAmount=void 0,this.state=e,this.liqPoolSolLegPdaLamports=t,this.liqPoolMSOLLegAmount=n}depositQuote(e){let t=e;const n=this.calcMSOLFromLamports(t),i=x.default.min(n,this.liqPoolMSOLLegAmount);let o=new x.default(0);if(t=(()=>{if(i.gt(new x.default(0))){const e=n.eq(i)?t:this.calcLamportsFromMSOLAmount(i);return o=o.add(i),Sn(t,e)}return t})(),t.gt(new x.default(0))){this.checkStakingCap(t);const e=this.calcMSOLFromLamports(t);o=o.add(e)}return{outAmount:o,feeAmount:0,feePct:0,priceImpactPct:0}}checkStakingCap(e){if(this.totalLamportsUnderControl().add(e).gt(this.state.stakingSolCap))throw new Error("Staking cap reached")}calcMSOLFromLamports(e){return t=e,n=this.totalVirtualStakedLamports(),(i=this.state.msolSupply).eq(new x.default(0))?t:pn(t,i,n);var t,n,i}calcLamportsFromMSOLAmount(e){return pn(e,this.totalVirtualStakedLamports(),this.state.msolSupply)}totalVirtualStakedLamports(){return Sn(this.totalLamportsUnderControl(),this.state.circulatingTicketBalance)}totalLamportsUnderControl(){return this.state.validatorSystem.totalActiveBalance.add(this.totalCoolingDown()).add(this.state.availableReserveBalance)}totalCoolingDown(){return this.state.stakeSystem.delayedUnstakeCoolingDown.add(this.state.emergencyCoolingDown)}liquidUnstakeQuote(e){const t=Sn(this.liqPoolSolLegPdaLamports,this.state.rentExemptForTokenAcc),n=this.calcLamportsFromMSOLAmount(e),i=function(e,t,n,i,o){if(o.gte(i))return t;const s=i.sub(o);return s.gte(n)?e:t-pn(new x.default(t-e),s,n).toNumber()}(this.state.liqPool.lpMinFee.basisPoints,this.state.liqPool.lpMaxFee.basisPoints,this.state.liqPool.lpLiquidityTarget,t,n),o=e.mul(new x.default(i)).div(new x.default(1e4)),s=this.calcLamportsFromMSOLAmount(e.sub(o));if(s.add(this.state.rentExemptForTokenAcc).gt(this.liqPoolSolLegPdaLamports))throw new Error("Insufficient liquidity");return{outAmount:s,feeAmount:o,feePct:i/1e4,priceImpactPct:0}}}function Sn(e,t){return e.gt(t)?e.sub(t):new x.default(0)}const fn=Math.pow(10,10),An=m.struct([m.u8("version"),m.u8("isInitialized"),m.u8("nonce"),Qe("amplificationCoefficient"),Qe("feeNumerator"),Qe("adminFeeNumerator"),m.u32("tokenAccountsLength"),Qe("precisionFactor"),Qe("precisionMultiplierA"),Qe("precisionMultiplierB"),Qe("precisionMultiplierC"),Qe("precisionMultiplierD"),je("tokenAccountA"),je("tokenAccountB"),je("tokenAccountC"),je("tokenAccountD")]),Mn=(e,t)=>{const n=t.owner,i=An.decode(t.data),o=i.tokenAccountsLength,s=Ze([e.toBuffer(),Buffer.from([i.nonce])],n),a=[i.precisionMultiplierA.toNumber(),i.precisionMultiplierB.toNumber(),i.precisionMultiplierC.toNumber(),i.precisionMultiplierD.toNumber()].slice(0,o),r=[i.tokenAccountA,i.tokenAccountB,i.tokenAccountC,i.tokenAccountD].slice(0,o);return{programId:n,authority:s,isInitialized:Boolean(i.isInitialized),nonce:i.nonce,ammId:e,amplificationCoefficient:i.amplificationCoefficient.toNumber(),feeNumerator:i.feeNumerator.toNumber(),tokenAccountsLength:o,precisionFactor:i.precisionFactor.toNumber(),precisionMultipliers:a,tokenAccounts:r}};class kn{constructor(t,n,o){this.params=void 0,this.id=void 0,this.label="Mercurial",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapLayout=void 0,this.tokenMints=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.params=o,this.id=t.toBase58(),this.swapLayout=Mn(t,n),this.calculator=new i.Stable(F.default.BigInt(this.swapLayout.tokenAccountsLength),F.default.BigInt(this.swapLayout.amplificationCoefficient),this.swapLayout.precisionMultipliers.map((e=>F.default.BigInt(e))),new i.Fraction(F.default.BigInt(this.swapLayout.feeNumerator),F.default.BigInt(fn))),this.tokenMints=o.tokenMints.map((t=>new e.PublicKey(t)))}getAccountsForUpdate(){return this.swapLayout.tokenAccounts}update(e){const t=j(e,this.getAccountsForUpdate());this.tokenReserveAmounts=G(t)}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const i=this.tokenReserveAmounts.findIndex(((t,n)=>this.tokenMints[n].equals(e))),o=this.tokenReserveAmounts.findIndex(((e,n)=>this.tokenMints[n].equals(t))),s=this.calculator.exchange(this.tokenReserveAmounts,n,i,o),a=this.swapLayout.feeNumerator/fn;return{notEnoughLiquidity:!1,inAmount:n,outAmount:s.expectedOutputAmount,feeAmount:s.fees,feeMint:t.toBase58(),feePct:a,priceImpactPct:s.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({swapLayout:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=[];for(const t of e.tokenAccounts)o.push({pubkey:t,isSigner:!1,isWritable:!0});return[pt({mercurial:{}}),kt.instruction.mercurialSwap({accounts:Pt(e,t,n,i),remainingAccounts:o}).keys]}({swapLayout:this.swapLayout,...e})}get reserveTokenMints(){return this.params.tokenMints.map((t=>new e.PublicKey(t)))}}kn.decodeSwapLayout=Mn;const yn=new r.Program(T.AmmIdl,T.PROGRAM_ID,Xe),wn=new r.Program(T.VaultIdl,T.PROGRAM_ID,Xe),Pn=e=>yn.coder.accounts.decode("pool",e.data),Tn=e=>wn.coder.accounts.decode("vault",e.data);class bn{constructor(t,n,i){this.address=void 0,this.id=void 0,this.label="Meteora",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.data=void 0,this.depegAccount=void 0,this.depegAccounts=new Map,this.vaultLpMint=void 0,this.vaultToken=void 0,this.feePct=void 0,this.address=t,this.id=t.toBase58(),this.poolState=Pn(n),this.vaultLpMint={a:new e.PublicKey(i.vaultLpMint.a),b:new e.PublicKey(i.vaultLpMint.b)},this.vaultToken={a:new e.PublicKey(i.vaultToken.a),b:new e.PublicKey(i.vaultToken.b)},i.depegAccount&&(this.depegAccount={...i.depegAccount,pubkey:new e.PublicKey(i.depegAccount.pubkey),data:Buffer.from(i.depegAccount.data[0],i.depegAccount.data[1]),owner:new e.PublicKey(i.depegAccount.owner)},this.depegAccounts=new Map([[this.depegAccount.pubkey.toBase58(),this.depegAccount]]));const{ownerTradeFeeDenominator:o,ownerTradeFeeNumerator:s,tradeFeeDenominator:a,tradeFeeNumerator:r}=this.poolState.fees;this.feePct=new q.default(s.toString()).div(o.toString()).add(new q.default(r.toString()).div(a.toString())).toNumber()}getAccountsForUpdate(){var t;const n=[this.poolState.aVault,this.poolState.bVault,this.poolState.aVaultLp,this.poolState.bVaultLp,this.poolState.lpMint,this.vaultLpMint.a,this.vaultLpMint.b,this.vaultToken.a,this.vaultToken.b,e.SYSVAR_CLOCK_PUBKEY];return null!==(t=this.depegAccount)&&void 0!==t&&t.pubkey&&n.push(this.depegAccount.pubkey),n}update(e){const[t,n,i,o,s,a,r,u,c,m,d]=j(e,this.getAccountsForUpdate());d&&this.depegAccount&&(this.depegAccount.data=d.data),this.data={vaultA:Tn(t),vaultB:Tn(n),poolAVaultLpAmount:Jt(i),poolBVaultLpAmount:Jt(o),poolLpTotalSupply:$t(s),vaultALpTotalSupply:$t(a),vaultBLpTotalSupply:$t(r),vaultAReserve:Jt(u),vaultBReserve:Jt(c),currentTime:new l.BN(m.data.readBigInt64LE(32).toString()).toNumber()}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(void 0===this.data)throw new Error("Unable to fetch accounts.");let i=new l.BN(n.toString());const o=T.calculateSwapQuote(e,i,{currentTime:this.data.currentTime,depegAccounts:this.depegAccounts,poolState:this.poolState,poolVaultALp:this.data.poolAVaultLpAmount,poolVaultBLp:this.data.poolBVaultLpAmount,vaultA:this.data.vaultA,vaultALpSupply:this.data.vaultALpTotalSupply,vaultB:this.data.vaultB,vaultBLpSupply:this.data.vaultBLpTotalSupply,vaultAReserve:this.data.vaultAReserve,vaultBReserve:this.data.vaultBReserve});return{notEnoughLiquidity:!1,inAmount:n,outAmount:F.default.BigInt(o.amountOut.toString()),feeAmount:F.default.BigInt(o.fee.toString()),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:0}}getSwapLegAndAccounts(e){var t,n;if(void 0===this.data)throw new Error("Unable to fetch accounts.");const i=e.sourceMint.equals(this.poolState.tokenAMint)?this.poolState.adminTokenAFee:this.poolState.adminTokenBFee;return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=[];return o.push(e.referrer?{pubkey:e.referrer,isSigner:!1,isWritable:!0}:yt),o.push(e.depeg?{pubkey:e.depeg,isSigner:!1,isWritable:!1}:yt),[pt({meteora:{}}),kt.instruction.meteoraSwap({accounts:{swapProgram:be,pool:e.pool,userSourceToken:t,userDestinationToken:n,aVault:e.aVault,bVault:e.bVault,aTokenVault:e.aTokenVault,bTokenVault:e.bTokenVault,aVaultLpMint:e.aVaultLpMint,bVaultLpMint:e.bVaultLpMint,aVaultLp:e.aVaultLp,bVaultLp:e.bVaultLp,adminTokenFee:e.adminTokenFee,user:i,vaultProgram:ve,tokenProgram:c.TOKEN_PROGRAM_ID},remainingAccounts:o}).keys]}({additionalArgs:{pool:this.address,aVault:this.poolState.aVault,bVault:this.poolState.bVault,aTokenVault:this.vaultToken.a,bTokenVault:this.vaultToken.b,aVaultLpMint:this.vaultLpMint.a,bVaultLpMint:this.vaultLpMint.b,aVaultLp:this.poolState.aVaultLp,bVaultLp:this.poolState.bVaultLp,adminTokenFee:i,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.sourceMint.toBase58()),depeg:null===(n=this.depegAccount)||void 0===n?void 0:n.pubkey},...e})}get reserveTokenMints(){return[this.poolState.tokenAMint,this.poolState.tokenBMint]}}bn.accountInfoToMeteoraSwapLayout=Pn,bn.accountInfoToVaultLayout=Tn;const vn=m.struct([m.nu64("status"),m.nu64("nonce"),m.nu64("orderNum"),m.nu64("depth"),m.nu64("coinDecimals"),m.nu64("pcDecimals"),m.nu64("state"),m.nu64("resetFlag"),m.nu64("minSize"),m.nu64("volMaxCutRatio"),m.nu64("amountWaveRatio"),m.nu64("coinLotSize"),m.nu64("pcLotSize"),m.nu64("minPriceMultiplier"),m.nu64("maxPriceMultiplier"),m.nu64("systemDecimalsValue"),m.nu64("minSeparateNumerator"),m.nu64("minSeparateDenominator"),m.nu64("tradeFeeNumerator"),m.nu64("tradeFeeDenominator"),m.nu64("pnlNumerator"),m.nu64("pnlDenominator"),m.nu64("swapFeeNumerator"),m.nu64("swapFeeDenominator"),m.nu64("needTakePnlCoin"),m.nu64("needTakePnlPc"),m.nu64("totalPnlPc"),m.nu64("totalPnlCoin"),ze("poolTotalDepositPc"),ze("poolTotalDepositCoin"),ze("swapCoinInAmount"),ze("swapPcOutAmount"),m.nu64("swapCoin2PcFee"),ze("swapPcInAmount"),ze("swapCoinOutAmount"),m.nu64("swapPc2CoinFee"),je("poolCoinTokenAccount"),je("poolPcTokenAccount"),je("coinMintAddress"),je("pcMintAddress"),je("lpMintAddress"),je("ammOpenOrders"),je("serumMarket"),je("serumProgramId"),je("ammTargetOrders"),je("poolWithdrawQueue"),je("poolTempLpTokenAccount"),je("ammOwner"),je("pnlOwner")]);class In{constructor(t,n,o){this.ammId=void 0,this.id=void 0,this.label="Raydium",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.coinMint=void 0,this.pcMint=void 0,this.status=void 0,this.serumProgramId=void 0,this.serumMarket=void 0,this.ammOpenOrders=void 0,this.ammTargetOrders=void 0,this.poolCoinTokenAccount=void 0,this.poolPcTokenAccount=void 0,this.serumMarketKeys=void 0,this.coinReserve=void 0,this.pcReserve=void 0,this.feePct=void 0,this.calculator=void 0,this.ammId=t,this.id=t.toBase58();const s=vn.decode(n.data);this.status=s.status,this.coinMint=new e.PublicKey(s.coinMintAddress),this.pcMint=new e.PublicKey(s.pcMintAddress),this.poolCoinTokenAccount=new e.PublicKey(s.poolCoinTokenAccount),this.poolPcTokenAccount=new e.PublicKey(s.poolPcTokenAccount),this.serumProgramId=new e.PublicKey(s.serumProgramId),this.serumMarket=new e.PublicKey(s.serumMarket),this.ammOpenOrders=new e.PublicKey(s.ammOpenOrders),this.ammTargetOrders=new e.PublicKey(s.ammTargetOrders),this.serumMarketKeys=Object.keys(o).reduce(((t,n)=>{if(!o[n])throw new Error(`Could not find ${n} in params`);return t[n]=new e.PublicKey(o[n]),t}),{});const a=s.swapFeeNumerator,r=s.swapFeeDenominator;this.feePct=new q.default(a.toString()).div(r.toString()),this.calculator=new i.TokenSwapConstantProduct(new i.Fraction(F.default.BigInt(a),F.default.BigInt(r)),i.ZERO_FRACTION)}static decodeSerumMarketKeysString(e,n,i,o){if(!n.equals(Ke))return{serumBids:e.toBase58(),serumAsks:e.toBase58(),serumEventQueue:e.toBase58(),serumCoinVaultAccount:e.toBase58(),serumPcVaultAccount:e.toBase58(),serumVaultSigner:e.toBase58()};const s=t.Market.getLayout(n).decode(o.data),a=Ze([i.toBuffer(),s.vaultSignerNonce.toArrayLike(Buffer,"le",8)],n);return{serumBids:s.bids.toBase58(),serumAsks:s.asks.toBase58(),serumEventQueue:s.eventQueue.toBase58(),serumCoinVaultAccount:s.baseVault.toBase58(),serumPcVaultAccount:s.quoteVault.toBase58(),serumVaultSigner:a.toBase58()}}getAccountsForUpdate(){return[this.ammId,this.poolCoinTokenAccount,this.poolPcTokenAccount,this.ammOpenOrders]}update(e){const[n,i,o,s]=j(e,this.getAccountsForUpdate()),[a,r]=[Jt(i),Jt(o)],u=t.OpenOrders.fromAccountInfo(this.ammOpenOrders,s,s.owner),m=vn.decode(n.data);this.coinReserve=a.add(u.baseTokenTotal).sub(new c.u64(String(m.needTakePnlCoin))),this.pcReserve=r.add(u.quoteTokenTotal).sub(new c.u64(String(m.needTakePnlPc)))}getQuote({sourceMint:e,amount:t}){const{coinReserve:n,pcReserve:i}=this;if(!this.isTradable)throw new Error("Pool is not tradable");if(!n||!i)throw new Error("Pool token accounts balances not refreshed or empty");const o=this.coinMint.equals(e)?1:0,s=this.calculator.exchange([F.default.BigInt(n),F.default.BigInt(i)],t,o);return{notEnoughLiquidity:!1,inAmount:t,outAmount:s.expectedOutputAmount,feeAmount:s.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:s.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({raydiumAmm:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){return[pt({raydium:{}}),kt.instruction.raydiumSwap({accounts:bt(e,t,n,i)}).keys]}({raydiumAmm:this,...e})}get reserveTokenMints(){return[this.coinMint,this.pcMint]}get isTradable(){return 1===this.status||6===this.status}}const Bn=new r.Program({version:"0.0.1",name:"add_decimals",instructions:[],accounts:[{name:"wrappedToken",type:{kind:"struct",fields:[{name:"decimals",type:"u8"},{name:"multiplier",type:"u64"},{name:"wrappedUnderlyingMint",type:"publicKey"},{name:"wrappedUnderlyingTokens",type:"publicKey"},{name:"wrapperMint",type:"publicKey"},{name:"nonce",type:"u8"}]}}],errors:[]},oe,Xe);class Dn{constructor(e,t){this.address=void 0,this.accountInfo=void 0,this.id=void 0,this.label="Saber (Decimals)",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.wrappedToken=void 0,this.multiplierJsbi=void 0,this.address=e,this.accountInfo=t,this.id=e.toBase58(),this.wrappedToken=Bn.coder.accounts.decode("wrappedToken",t.data),this.multiplierJsbi=F.default.BigInt(this.wrappedToken.multiplier)}getAccountsForUpdate(){return new Array}update(e){}toWrappedAmount(e){return F.default.multiply(this.multiplierJsbi,e)}toUnderlyingAmount(e){return F.default.divide(e,this.multiplierJsbi)}getAmounts(e,t){if(t)return[e,this.toWrappedAmount(e)];{const t=this.toUnderlyingAmount(e);return[this.toWrappedAmount(t),t]}}getQuote({sourceMint:e,amount:t}){const n=this.wrappedToken.wrappedUnderlyingMint.equals(e),[o,s]=this.getAmounts(t,n);return{notEnoughLiquidity:!1,inAmount:o,outAmount:s,feeAmount:i.ZERO,feeMint:e.toBase58(),feePct:0,priceImpactPct:0}}getSwapLegAndAccounts(e){return function({wrapper:e,wrappedToken:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,deposit:s}){return[pt(s?{saberAddDecimalsDeposit:{}}:{saberAddDecimalsWithdraw:{}}),kt.instruction.saberAddDecimals({accounts:{addDecimalsProgram:oe,wrapper:e,wrapperMint:t.wrapperMint,wrapperUnderlyingTokens:t.wrappedUnderlyingTokens,owner:o,userUnderlyingTokens:s?n:i,userWrappedTokens:s?i:n,tokenProgram:c.TOKEN_PROGRAM_ID}}).keys]}({wrapper:this.address,wrappedToken:this.wrappedToken,...e,deposit:this.wrappedToken.wrappedUnderlyingMint.equals(e.sourceMint)})}get reserveTokenMints(){return[this.wrappedToken.wrappedUnderlyingMint,this.wrappedToken.wrapperMint]}get wrapperMint(){return this.wrappedToken.wrapperMint}}class Rn{constructor(e){this.stableSwap=void 0,this.id=void 0,this.label="Saber",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.stableSwap=e,this.id=e.config.swapAccount.toBase58(),this.calculator=new i.Stable(i.TWO,n.calculateAmpFactor(this.stableSwap.state),[i.ONE,i.ONE],new i.Fraction(this.stableSwap.state.fees.trade.numerator,this.stableSwap.state.fees.trade.denominator))}getAccountsForUpdate(){return[this.stableSwap.state.tokenA.reserve,this.stableSwap.state.tokenB.reserve]}update(e){const t=j(e,this.getAccountsForUpdate());this.tokenReserveAmounts=G(t)}getQuote({sourceMint:e,destinationMint:t,amount:i}){if(this.stableSwap.state.isPaused)throw new Error("Saber pool is paused");if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const o=new q.default(this.stableSwap.state.fees.trade.asFraction.toFixed(4)),[s,a]=this.stableSwap.state.tokenA.mint.equals(e)?[0,1]:[1,0];this.calculator.setAmp(n.calculateAmpFactor(this.stableSwap.state));const r=this.calculator.exchange(this.tokenReserveAmounts,i,s,a);return{notEnoughLiquidity:!1,inAmount:i,outAmount:r.expectedOutputAmount,feeAmount:r.fees,feeMint:t.toBase58(),feePct:o.toNumber(),priceImpactPct:r.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({stableSwap:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){return[pt({saber:{}}),kt.instruction.saberSwap({accounts:It(e,t,n,i,o)}).keys]}({stableSwap:this.stableSwap,...e})}get reserveTokenMints(){return[this.stableSwap.state.tokenA.mint,this.stableSwap.state.tokenB.mint]}}const On=m.struct([m.blob(8,"discriminator"),je("factory"),m.u8("bump"),Qe("index"),je("admin"),je("token0Reserves"),je("token0Mint"),je("token0Fees"),je("token1Reserves"),je("token1Mint"),je("token1Fees"),m.u8("isPaused"),je("poolMint"),Qe("tradeFeeKbps"),Qe("withdrawFeeKbps"),Qe("adminTradeFeeKbps"),Qe("adminWithdrawFeeKbps")]);class Ln{constructor(e,t){this.id=void 0,this.label="Sencha",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.poolState=void 0,this.calculator=void 0,this.tokenReserveAmounts=void 0,this.id=e.toBase58(),this.poolState=((e,t)=>{const n=t.owner,i=On.decode(t.data);return{programId:n,isPaused:Boolean(i.isPaused),bump:i.bump,ammId:e,token0Reserves:i.token0Reserves,token1Reserves:i.token1Reserves,token0Mint:i.token0Mint,token1Mint:i.token1Mint,token0Fees:i.token0Fees,token1Fees:i.token1Fees,poolMint:i.poolMint,tradeFeeKbps:i.tradeFeeKbps.toNumber()}})(e,t),this.calculator=new i.TokenSwapConstantProduct(new i.Fraction(F.default.BigInt(this.poolState.tradeFeeKbps),F.default.BigInt(1e7)),new i.Fraction(i.ZERO,i.ZERO),!1)}get isPaused(){return this.poolState.isPaused}getAccountsForUpdate(){return[this.poolState.token0Reserves,this.poolState.token1Reserves]}update(e){const t=j(e,this.getAccountsForUpdate());this.tokenReserveAmounts=G(t)}getQuote({sourceMint:e,amount:t}){if(this.isPaused)throw new Error("Sencha pool is paused");if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const n=this.poolState.token0Mint.equals(e)?1:0;let i=this.calculator.exchange(this.tokenReserveAmounts,t,n),o=this.poolState.tradeFeeKbps/1e7;return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:o,priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({poolState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o}){const[s,a]=t.equals(e.token0Mint)?[e.token0Reserves,e.token1Reserves]:[e.token1Reserves,e.token0Reserves],[r,u]=t.equals(e.token0Mint)?[e.token0Fees,e.token1Fees]:[e.token1Fees,e.token0Fees];return[pt({sencha:{}}),kt.instruction.senchaSwap({accounts:{swapProgram:e.programId,tokenProgram:c.TOKEN_PROGRAM_ID,swap:e.ammId,userAuthority:o,inputUserAccount:n,inputTokenAccount:s,inputFeesAccount:r,outputUserAccount:i,outputTokenAccount:a,outputFeesAccount:u}}).keys]}({poolState:this.poolState,...e})}get reserveTokenMints(){return[this.poolState.token0Mint,this.poolState.token1Mint]}}const Fn=["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS","5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z","EERNEEnBqdGzBS8dd46wwNY5F2kwnaCQ3vsq2fNKGogZ","8sFf9TW3KzxLiBXcDcjAxqabEsRroo4EiRr3UG1xbJ9m","2iDSTGhjJEiRxNaLF27CY6daMYPs5hgYrP2REHd5YD62"],En=["B2na8Awyd7cpC59iEU43FagJAPLigr3AP3s38KM982bu"];function*xn(e){const t=e.isBids;for(const{key:n,quantity:i}of e.slab.items(t)){const e=F.default.BigInt(n.ushrn(64).toString());yield[e,F.default.BigInt(i.toString())]}}function qn(e,t){const n=e._decoded.baseLotSize;return n.isZero()?new q.default(0):function(e,t){const n=new q.default(e.div(t).toString()),i=e.umod(t),o=i.gcd(t);return n.add(new q.default(i.div(o).toString()).div(new q.default(t.div(o).toString())))}(t.mul(e._decoded.quoteLotSize).mul(e._baseSplTokenMultiplier),n.mul(e._quoteSplTokenMultiplier))}class _n{constructor(e){this.market=void 0,this.id=void 0,this.label=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this._orderbooks=void 0,this.isOpenbook=void 0,this.market=e,this.id=e.address.toBase58(),this.isOpenbook=e.programId.equals(Ke),this.label=this.isOpenbook?"Openbook":"Serum"}get orderbooks(){return this._orderbooks}getAccountsForUpdate(){return[this.market.asksAddress,this.market.bidsAddress]}update(e){const[n,i]=j(e,this.getAccountsForUpdate()),o=t.Orderbook.decode(this.market,n.data),s=t.Orderbook.decode(this.market,i.data);this._orderbooks={asks:o,bids:s}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.orderbooks)throw new Error("Failed to find orderbooks");const o=function({market:e,asks:t,bids:n,fromAmount:o,fromMint:s,toMint:a,isOpenbook:r}){const u=r?En.includes(e.address.toBase58())?1e-4:4e-4:Fn.includes(e.address.toBase58())?1e-4:4e-4;return s.equals(e.quoteMintAddress)&&a.equals(e.baseMintAddress)?function(e,t,n,o){let s=i.ZERO,a=i.ZERO,r=i.ZERO,u=i.ZERO,c=i.ZERO;const m=e.quoteSizeLotsToNumber(new x.default(1));let d=m?F.default.BigInt(new q.default(n.toString()).div(1+o).div(m).floor()):i.ZERO;const l=F.default.BigInt(e.baseSizeLotsToNumber(new x.default(1)).toString());for(let[e,n]of xn(t)){F.default.equal(a,i.ZERO)&&(a=e),r=e;const t=F.default.multiply(n,l),o=F.default.multiply(n,e);if(c=F.default.add(c,t),F.default.greaterThanOrEqual(o,d)){const t=F.default.divide(d,e);u=F.default.add(u,F.default.multiply(e,t)),s=F.default.add(s,F.default.multiply(l,t)),d=i.ZERO;break}u=F.default.add(u,F.default.multiply(e,n)),s=F.default.add(s,t),d=F.default.subtract(d,o)}let p=0;if(F.default.notEqual(a,i.ZERO)){const e=new q.default(a.toString());p=new q.default(r.toString()).sub(e).div(e).toNumber()}const g=qn(e,new x.default(a.toString())),h=qn(e,new x.default(u.toString())),S=h.mul(l.toString()).ceil(),f=h.mul(l.toString()).mul(o).ceil();return{side:"buy",notEnoughLiquidity:F.default.lessThanOrEqual(c,s),minimum:{in:F.default.BigInt(g.mul(l.toString()).mul(1+o).ceil()),out:l},inAmount:F.default.BigInt(S.add(f)),outAmount:s,feeAmount:F.default.BigInt(f),priceImpactPct:p,feePct:o}}(e,t,o,u):function(e,t,n,o){let s=F.default.BigInt(0),a=F.default.BigInt(0),r=F.default.BigInt(0),u=F.default.BigInt(0),c=n,m=F.default.BigInt(0);const d=F.default.BigInt(e.baseSizeLotsToNumber(new x.default(1))),l=F.default.BigInt(e.quoteSizeLotsToNumber(new x.default(1)));for(const[e,n]of xn(t)){F.default.equal(a,i.ZERO)&&(a=e),r=e;const t=F.default.multiply(d,n),o=F.default.multiply(n,F.default.multiply(e,l));if(u=F.default.add(u,t),F.default.greaterThanOrEqual(t,c)){const t=F.default.divide(c,d),n=F.default.multiply(t,e);s=F.default.add(s,F.default.multiply(n,l)),c=F.default.subtract(c,n),m=F.default.add(m,F.default.multiply(t,d));break}s=F.default.add(s,o),c=F.default.subtract(c,t),m=F.default.add(m,t)}let p=new q.default(s.toString()).mul(1-o).floor(),g=0;const h=qn(e,new x.default(a.toString()));if(F.default.notEqual(a,i.ZERO)){const t=qn(e,new x.default(r.toString()));g=h.minus(t).div(h).toNumber()}return{side:"sell",notEnoughLiquidity:F.default.greaterThan(F.default.BigInt(n),u),minimum:{in:d,out:F.default.BigInt(h.mul(F.default.toNumber(d)).mul(1-o).floor().toString())},inAmount:m,outAmount:F.default.BigInt(p),feeAmount:F.default.BigInt(new q.default(s.toString()).mul(o).round()),priceImpactPct:g,feePct:o}}(e,n,o,u)}({market:this.market,asks:this.orderbooks.asks,bids:this.orderbooks.bids,fromMint:e,toMint:t,fromAmount:n,isOpenbook:this.isOpenbook});return{notEnoughLiquidity:o.notEnoughLiquidity,minInAmount:o.minimum.in,minOutAmount:o.minimum.out,inAmount:o.inAmount,outAmount:o.outAmount,feeAmount:o.feeAmount,feeMint:this.market.quoteMintAddress.toBase58(),feePct:o.feePct,priceImpactPct:o.priceImpactPct}}getSwapLegAndAccounts(e){var t;if(!e.openOrdersAddress)throw new Error("Missing open orders");return function({market:e,sourceMint:t,openOrdersAddress:n,userSourceTokenAccount:i,userDestinationTokenAccount:o,userTransferAuthority:s,referrer:a,isOpenbook:r}){const{side:u,coinWallet:c,pcWallet:m}=t.equals(e.baseMintAddress)?{side:tt.Ask,coinWallet:i,pcWallet:o}:{side:tt.Bid,coinWallet:o,pcWallet:i};return[pt(r?ct(u):nt(u)),kt.instruction.serumSwap({accounts:vt(e,n,i,c,m,s),remainingAccounts:a?[{pubkey:a,isSigner:!1,isWritable:!0}]:[yt]}).keys]}({market:this.market,openOrdersAddress:e.openOrdersAddress,referrer:null==e||null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(this.market.quoteMintAddress.toBase58()),isOpenbook:this.isOpenbook,...e})}get reserveTokenMints(){return[this.market.baseMintAddress,this.market.quoteMintAddress]}}_n.getL2=xn;const Kn=m.struct([m.u8("version"),m.u8("isInitialized"),m.u8("bumpSeed"),je("tokenProgramId"),je("tokenAccountA"),je("tokenAccountB"),je("tokenPool"),je("mintA"),je("mintB"),je("feeAccount"),Qe("tradeFeeNumerator"),Qe("tradeFeeDenominator"),Qe("ownerTradeFeeNumerator"),Qe("ownerTradeFeeDenominator"),Qe("ownerWithdrawFeeNumerator"),Qe("ownerWithdrawFeeDenominator"),Qe("hostFeeNumerator"),Qe("hostFeeDenominator"),m.u8("curveType"),m.blob(32,"curveParameters")]),Nn=m.struct([m.u8("version"),m.u8("isInitialized"),m.u8("bumpSeed"),je("tokenProgramId"),je("tokenAccountA"),je("tokenAccountB"),je("tokenPool"),je("mintA"),je("mintB"),je("feeAccount"),Qe("tradeFeeNumerator"),Qe("tradeFeeDenominator"),Qe("ownerTradeFeeNumerator"),Qe("ownerTradeFeeDenominator"),Qe("ownerWithdrawFeeNumerator"),Qe("ownerWithdrawFeeDenominator"),m.u8("curveType"),m.blob(32,"curveParameters"),m.u8("poolNonce")]);var Cn;!function(e){e[e.ConstantProduct=0]="ConstantProduct",e[e.Stable=2]="Stable"}(Cn||(Cn={}));class Vn{constructor(t,n,o){if(this.label=void 0,this.id=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.tokenSwapState=void 0,this.curveType=void 0,this.feePct=void 0,this.tokenReserveAmounts=void 0,this.calculator=void 0,this.label=o,this.id=t.toBase58(),this.tokenSwapState=function(t,n){const i=n.owner,o=i.equals(we)?Nn.decode(n.data):Kn.decode(n.data);if(!o.isInitialized)throw new Error("Invalid token swap state");const s=Ze([t.toBuffer(),Buffer.from([o.bumpSeed])],i),a=new e.PublicKey(o.tokenPool),r=new e.PublicKey(o.feeAccount),u=new e.PublicKey(o.tokenAccountA),c=new e.PublicKey(o.tokenAccountB),m=new e.PublicKey(o.mintA),d=new e.PublicKey(o.mintB);return{address:t,programId:i,tokenProgramId:new e.PublicKey(o.tokenProgramId),poolToken:a,feeAccount:r,authority:s,tokenAccountA:u,tokenAccountB:c,mintA:m,mintB:d,tradeFeeNumerator:o.tradeFeeNumerator,tradeFeeDenominator:o.tradeFeeDenominator,ownerTradeFeeNumerator:o.ownerTradeFeeNumerator,ownerTradeFeeDenominator:o.ownerTradeFeeDenominator,ownerWithdrawFeeNumerator:o.ownerWithdrawFeeNumerator,ownerWithdrawFeeDenominator:o.ownerWithdrawFeeDenominator,curveType:o.curveType,curveParameters:o.curveParameters,poolNonce:"poolNonce"in o?o.poolNonce:void 0}}(t,n),this.curveType=this.tokenSwapState.curveType,!(this.curveType in Cn))throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);const s=Vn.getFeeFraction(this.tokenSwapState.tradeFeeNumerator,this.tokenSwapState.tradeFeeDenominator),a=Vn.getFeeFraction(this.tokenSwapState.ownerTradeFeeNumerator,this.tokenSwapState.ownerTradeFeeDenominator);this.calculator=this.tokenSwapState.curveType===Cn.ConstantProduct?new i.TokenSwapConstantProduct(s,a):new i.TokenSwapStable(F.default.BigInt(this.tokenSwapState.curveParameters[0]),s,a),this.feePct=Vn.getFeeDecimal(this.tokenSwapState.tradeFeeNumerator,this.tokenSwapState.tradeFeeDenominator).add(Vn.getFeeDecimal(this.tokenSwapState.ownerTradeFeeNumerator,this.tokenSwapState.ownerTradeFeeDenominator)).toNumber()}static getFeeFraction(e,t){return new i.Fraction(F.default.BigInt(e.toString()),F.default.BigInt(t.toString()))}static getFeeDecimal(e,t){return e.eq(new c.u64(0))?new q.default(0):new q.default(e.toString()).div(t.toString())}getAccountsForUpdate(){return[this.tokenSwapState.tokenAccountA,this.tokenSwapState.tokenAccountB]}update(e){const t=j(e,this.getAccountsForUpdate());this.tokenReserveAmounts=G(t)}getQuote({sourceMint:e,amount:t}){if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const n=this.reserveTokenMints[0].equals(e)?1:0,i=this.calculator.exchange(this.tokenReserveAmounts,t,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:i.priceImpact.toNumber()}}getSwapLegAndAccounts(e){return function({tokenSwapState:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,isStep:s}){const[a,r]=t.equals(e.mintA)?[e.tokenAccountA,e.tokenAccountB]:[e.tokenAccountB,e.tokenAccountA];return[pt(s?{step:{}}:{tokenSwap:{}}),(s?kt.instruction.stepSwap:kt.instruction.tokenSwap)({accounts:{tokenSwapProgram:e.programId,tokenProgram:c.TOKEN_PROGRAM_ID,swap:e.address,authority:e.authority,userTransferAuthority:o,source:n,swapSource:a,swapDestination:r,destination:i,poolMint:e.poolToken,poolFee:e.feeAccount}}).keys]}({tokenSwapState:this.tokenSwapState,...e,isStep:this.tokenSwapState.programId.equals(we)})}get reserveTokenMints(){return[this.tokenSwapState.mintA,this.tokenSwapState.mintB]}}function Un(e){return e.reduce(((t,n)=>(e.forEach((e=>{n!==e&&t.push([n,e])})),t)),new Array)}const Wn=F.default.BigInt(100);class Xn{constructor(e,t,n){this.firstAmm=void 0,this.secondAmm=void 0,this.reserveTokenMints=void 0,this.market=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.portion1=0,this.portion2=0,this.firstAmm=e,this.secondAmm=t,this.reserveTokenMints=n,this.market=e instanceof _n?e.market:t instanceof _n?t.market:null}static getAmmIdsFromSplitTradeAmmId(e){const t=e.split("-");return t.length>1?t:[]}static create(e,t){if(!function(e,t){return!U(K,e.label,t.label)}(e,t))return;const n=Un(e.reserveTokenMints),i=Un(t.reserveTokenMints);for(const o of n)for(const n of i)if(o.every(((e,t)=>e.equals(n[t]))))return new Xn(e,t,o)}setPortions(e,t){if(e+t!==100)throw new Error("Split trade portions must sum to 100");this.portion1=e,this.portion2=t}get id(){return`${this.firstAmm.id}-${this.secondAmm.id}`}get label(){return[{label:this.firstAmm.label,portion:this.portion1},{label:this.secondAmm.label,portion:this.portion2}].sort(((e,t)=>t.portion-e.portion)).map((({label:e,portion:t})=>`${e} (${t}%)`)).join(" + ")}getAccountsForUpdate(){return[]}update(e){}getQuote(e){const t=e.sourceMint.toBase58(),n=e.amount;let o={outAmount:i.ZERO,portion:0,firstQuote:void 0,secondQuote:void 0};for(let t=100;t-=5;t>0){const i=F.default.divide(F.default.multiply(n,F.default.BigInt(t)),Wn),s=F.default.subtract(n,i),a=this.firstAmm.getQuote({...e,amount:i}),r=this.secondAmm.getQuote({...e,amount:s}),u=F.default.add(a.outAmount,r.outAmount);if(F.default.lessThan(u,o.outAmount))break;o={outAmount:u,portion:t,firstQuote:a,secondQuote:r}}if(!o.firstQuote||!o.secondQuote)throw new Error("Unreachable: There was no better solution than getting 0 outAmount");const{outAmount:s,portion:a,firstQuote:r,secondQuote:u}=o,c=a,m=100-c;this.portion1=c,this.portion2=m;let d={amount:r.feeAmount,mint:r.feeMint},l={amount:u.feeAmount,mint:u.feeMint};d.mint!==l.mint&&(d.mint!==t&&(d={amount:F.default.divide(F.default.divide(F.default.multiply(d.amount,F.default.multiply(n,F.default.BigInt(c))),Wn),o.outAmount),mint:t}),l.mint!==t&&(l={amount:F.default.divide(F.default.divide(F.default.multiply(F.default.multiply(l.amount,n),F.default.BigInt(m)),Wn),o.outAmount),mint:t}));const p=(c*r.feePct+m*u.feePct)/100,g=(c*r.priceImpactPct+m*u.priceImpactPct)/100;return{notEnoughLiquidity:!1,inAmount:e.amount,outAmount:s,feeAmount:F.default.add(d.amount,l.amount),feeMint:d.mint,feePct:p,priceImpactPct:g}}getSwapLegAndAccounts(e){let[t,n]=this.firstAmm.getSwapLegAndAccounts(e),[i,o]=this.secondAmm.getSwapLegAndAccounts(e),s=[gt(this.portion1,t),gt(this.portion2,i)],a=[...n,...o];return[lt(s),a]}}function Yn(e,t){const n=b.ParsableWhirlpool.parse(t);if(!n)throw new Error(`Failed to parse whirlpool ${e.toBase58()}`);return n}function jn(e,t){const n=b.ParsableTickArray.parse(t);if(!n)throw new Error(`Failed to parse tick array ${e.toBase58()}`);return n}class Gn{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Orca (Whirlpools)",this.shouldPrefetch=!0,this.exactOutputSupported=!0,this.hasDynamicAccounts=!0,this.whirlpoolData=void 0,this.tickArrays={aToB:[],bToA:[]},this.tickPks=void 0,this.oracle=void 0,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.whirlpoolData=Yn(e,t.data),this.oracle=u.findProgramAddressSync([Buffer.from("oracle"),e.toBuffer()],le)[0],this.feePct=new q.default(this.whirlpoolData.feeRate).div(1e6),this.tickPks=this.getTickArrayPks()}getTickArrayPks(){const e={aToB:[],bToA:[]};return[!0,!1].forEach((t=>{e[t?"aToB":"bToA"].push(...b.SwapUtils.getTickArrayPublicKeys(this.whirlpoolData.tickCurrentIndex,this.whirlpoolData.tickSpacing,t,le,this.address))})),e}getAccountsForUpdate(){return[this.address,...this.tickPks.aToB,...this.tickPks.bToA]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing ${this.address.toBase58()}`);this.whirlpoolData=Yn(this.address,t.data),this.tickPks=this.getTickArrayPks();const n={aToB:[],bToA:[]};[!0,!1].forEach((t=>{const i=t?"aToB":"bToA";for(const t of this.tickPks[i]){const o=t.toBase58(),s=e.get(o);if(!s)continue;const a=jn(t,s.data);n[i].push({address:t,data:a})}})),this.tickArrays=n}getQuote({sourceMint:e,amount:t,swapMode:n}){const i=!!e.equals(this.whirlpoolData.tokenMintA),o=n===exports.SwapMode.ExactIn,s=b.swapQuoteWithParams({amountSpecifiedIsInput:o,aToB:i,otherAmountThreshold:b.SwapUtils.getDefaultOtherAmountThreshold(o),sqrtPriceLimit:b.SwapUtils.getDefaultSqrtPriceLimit(i),tickArrays:this.tickArrays[i?"aToB":"bToA"],tokenAmount:new x.default(t.toString()),whirlpoolData:this.whirlpoolData}),a=F.default.BigInt(s.estimatedAmountIn.toString()),r=F.default.BigInt(s.estimatedAmountOut.toString()),u=F.default.BigInt(this.feePct.mul(a.toString()).floor().toString()),c=s.aToB?new q.default(s.estimatedAmountOut.toString()).div(s.estimatedAmountIn.toString()):new q.default(s.estimatedAmountIn.toString()).div(s.estimatedAmountOut.toString()),m=(d=this.whirlpoolData.sqrtPrice,new q.default(d.toString()).mul(q.default.pow(2,-64))).pow(2);var d;const l=m.minus(c).div(m).abs().toNumber();return{notEnoughLiquidity:!1,inAmount:a,outAmount:r,feeAmount:u,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:Number(l)}}getSwapLegAndAccounts(e){const t=e.sourceMint.equals(this.whirlpoolData.tokenMintA),n=e.swapMode===exports.SwapMode.ExactIn,{tickArray0:i,tickArray1:o,tickArray2:s}=b.swapQuoteWithParams({amountSpecifiedIsInput:n,aToB:t,otherAmountThreshold:b.SwapUtils.getDefaultOtherAmountThreshold(n),sqrtPriceLimit:b.SwapUtils.getDefaultSqrtPriceLimit(t),tickArrays:this.tickArrays[t?"aToB":"bToA"],tokenAmount:new x.default(e.amount.toString()),whirlpoolData:this.whirlpoolData});return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const[o,s]=e.aToB?[t,n]:[n,t];return[pt(at(e.aToB)),kt.instruction.whirlpoolSwap({accounts:{swapProgram:le,tokenProgram:c.TOKEN_PROGRAM_ID,tokenAuthority:i,whirlpool:e.whirlpool,tokenOwnerAccountA:o,tokenVaultA:e.tokenVaultA,tokenOwnerAccountB:s,tokenVaultB:e.tokenVaultB,tickArray0:e.tickArray0,tickArray1:e.tickArray1,tickArray2:e.tickArray2,oracle:e.oracle}}).keys]}({additionalArgs:{aToB:t,whirlpool:this.address,tickArray0:i,tickArray1:o,tickArray2:s,oracle:this.oracle,...this.whirlpoolData},...e})}createExactOutSwapInstruction(e){const t=e.sourceMint.equals(this.whirlpoolData.tokenMintA),n=e.swapMode===exports.SwapMode.ExactIn,{tickArray0:i,tickArray1:o,tickArray2:s}=b.swapQuoteWithParams({amountSpecifiedIsInput:n,aToB:t,otherAmountThreshold:b.SwapUtils.getDefaultOtherAmountThreshold(n),sqrtPriceLimit:b.SwapUtils.getDefaultSqrtPriceLimit(t),tickArrays:this.tickArrays[t?"aToB":"bToA"],tokenAmount:new x.default(e.amount.toString()),whirlpoolData:this.whirlpoolData});return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i,outAmount:o,inAmount:s,slippageBps:a,platformFee:r,overflowFeeAccount:u}){var m;const[d,l]=e.aToB?[t,n]:[n,t];return kt.instruction.whirlpoolSwapExactOutput(o,{amount:s,slippageBps:a},e.aToB,null!==(m=null==r?void 0:r.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:le,tokenProgram:c.TOKEN_PROGRAM_ID,tokenAuthority:i,whirlpool:e.whirlpool,tokenOwnerAccountA:d,tokenVaultA:e.tokenVaultA,tokenOwnerAccountB:l,tokenVaultB:e.tokenVaultB,tickArray0:e.tickArray0,tickArray1:e.tickArray1,tickArray2:e.tickArray2,oracle:e.oracle},remainingAccounts:Bt(null==r?void 0:r.feeAccount,u)})}({additionalArgs:{aToB:t,whirlpool:this.address,tickArray0:i,tickArray1:o,tickArray2:s,oracle:this.oracle,...this.whirlpoolData},...e,outAmount:new x.default(e.amount.toString()),inAmount:new x.default(e.inAmount.toString()),slippageBps:e.slippageBps,platformFee:e.platformFee,overflowFeeAccount:e.overflowFeeAccount})}get reserveTokenMints(){return[this.whirlpoolData.tokenMintA,this.whirlpoolData.tokenMintB]}}class Qn{constructor(t,n,i){this.address=void 0,this.id=void 0,this.label="Dradex",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.state=void 0,this.orderBookState=void 0,this.quoteCalculator=void 0,this.marketUser=void 0,this.address=t,this.id=t.toBase58(),this.state=v.dexCoder.accounts.decode("market",n.data),this.marketUser=new e.PublicKey(i.marketUser)}getAccountsForUpdate(){return[this.address,...this.reserveTokenMints,this.state.orderBook.bids,this.state.orderBook.asks]}update(e){const t=e.get(this.id),n=e.get(this.state.orderBook.bids.toString()),i=e.get(this.state.orderBook.asks.toString()),o=this.reserveTokenMints.map((t=>e.get(t.toString())));if(!t||!n||!i||o.find((e=>!e)))throw new Error(`One of the required accounts is missing: ${this.address.toBase58()}`);if(o.length!==this.reserveTokenMints.length)throw new Error(`Missing mint info: ${this.address.toBase58()}`);this.state=v.dexCoder.accounts.decode("market",t.data);const s=this.reserveTokenMints.map(((e,t)=>a.deserializeMint(o[t].data,e)));this.orderBookState={bids:I.OrderBook.decode(n.data).items,asks:I.OrderBook.decode(i.data).items},this.quoteCalculator=new v.QuoteCalculator(this.state,this.orderBookState,s)}getQuote(e){if(!this.quoteCalculator)throw new Error(`Quote calculator is not initialized: ${this.address.toBase58()}`);const t=this.quoteCalculator.getQuote(e);return{...t,priceImpactPct:t.priceImpactPct/100}}getSwapLegAndAccounts(t){var n;return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,sourceMint:s}){const{side:a,t0User:r,t1User:u}=s.equals(t.t0)?{side:tt.Ask,t0User:n,t1User:i}:{side:tt.Bid,t0User:i,t1User:n};return[pt(ut(a)),kt.instruction.dradexSwap({accounts:{swapProgram:Le,pair:t.pair,market:t.market,eventQueue:t.eventQueue,dexUser:qe,marketUser:t.marketUser,bids:t.bids,asks:t.asks,t0Vault:t.t0Vault,t1Vault:t.t1Vault,t0User:r,t1User:u,master:Ee,signer:o,systemProgram:e.SystemProgram.programId,tokenProgram:c.TOKEN_PROGRAM_ID,logger:Fe},remainingAccounts:t.referrer?[{pubkey:t.referrer,isSigner:!1,isWritable:!0}]:[yt]}).keys]}({additionalArgs:{pair:this.state.pair,market:this.address,eventQueue:this.state.eventQueue,marketUser:this.marketUser,bids:this.state.orderBook.bids,asks:this.state.orderBook.asks,t0:this.state.t0,t1:this.state.t1,t0Vault:this.state.t0Vault,t1Vault:this.state.t1Vault,referrer:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(t.destinationMint.toBase58())},...t})}get reserveTokenMints(){return[this.state.t0,this.state.t1]}}class zn{constructor(e,t){this.address=void 0,this.label="Raydium CLMM",this.id=void 0,this.reserveTokenMints=void 0,this.hasDynamicAccounts=!0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.programId=void 0,this.poolState=void 0,this.coder=void 0,this.tickArrayPks=void 0,this.tickArrayCache={},this.ammV3PoolInfo=void 0,this.address=e,this.id=e.toBase58(),this.address=e,this.coder=new r.BorshAccountsCoder(B.IDL),this.poolState=this.coder.decode("poolState",t.data),this.reserveTokenMints=[this.poolState.tokenMint0,this.poolState.tokenMint1],this.programId=_e,this.tickArrayPks=B.Amm.getTickArrayPks(this.address,this.poolState,this.programId)}getAccountsForUpdate(){return[this.address,this.poolState.ammConfig,...this.tickArrayPks]}update(e){const t=e.get(this.id);if(!t)throw new Error("Missing poolStateAccountInfo");const n=e.get(this.poolState.ammConfig.toBase58());if(!n)throw new Error("Missing ammConfigAccoutnInfo");this.poolState=this.coder.decode("poolState",t.data);const i=this.coder.decode("ammConfig",n.data);this.tickArrayPks=B.Amm.getTickArrayPks(this.address,this.poolState,this.programId);const o={};for(const t of this.tickArrayPks){const n=e.get(t.toBase58());if(!n)continue;const i=this.coder.decode("tickArrayState",n.data);o[i.startTickIndex]={...i,address:t}}this.tickArrayCache=o,this.ammV3PoolInfo=B.Amm.formatPoolInfo({address:this.address,poolState:this.poolState,ammConfig:i,programId:this.programId})}getQuote(e){if(e.swapMode!==exports.SwapMode.ExactIn)throw Error("ExactOut does not support");if(0!==this.poolState.status)throw new Error("Pool is not swapable");if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");const{amountOut:t,fee:n,priceImpact:i}=B.Amm.computeAmountOut({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:e.sourceMint,amountIn:new x.default(e.amount.toString()),slippage:0});return{notEnoughLiquidity:!1,inAmount:e.amount,outAmount:F.default.BigInt(t.toString()),feeAmount:F.default.BigInt(n.toString()),feeMint:e.sourceMint.toString(),feePct:this.ammV3PoolInfo.ammConfig.tradeFeeRate/10**6,priceImpactPct:i}}getSwapLegAndAccounts(e){if(!this.ammV3PoolInfo)throw new Error("Missing ammV3PoolInfo");const{remainingAccounts:t}=B.Amm.computeAmountOut({poolInfo:this.ammV3PoolInfo,tickArrayCache:this.tickArrayCache,baseMint:e.sourceMint,amountIn:new x.default(e.amount.toString()),slippage:0}),[n,i]=e.sourceMint.equals(this.poolState.tokenMint0)?[this.poolState.tokenVault0,this.poolState.tokenVault1]:[this.poolState.tokenVault1,this.poolState.tokenVault0],o=t.shift();if(!o)throw new Error("Missing at least one tick array");return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){const o=e.remainingAccounts.map((e=>({pubkey:e,isWritable:!0,isSigner:!1})));return o.push(yt),[pt({raydiumClmm:{}}),kt.instruction.raydiumClmmSwap({accounts:{swapProgram:_e,payer:i,ammConfig:e.ammConfig,poolState:e.poolState,inputTokenAccount:t,outputTokenAccount:n,inputVault:e.inputVault,outputVault:e.outputVault,observationState:e.observationState,tokenProgram:c.TOKEN_PROGRAM_ID,tickArray:e.tickArray},remainingAccounts:o}).keys]}({additionalArgs:{poolState:this.address,inputVault:n,outputVault:i,observationState:this.poolState.observationKey,tickArray:o,remainingAccounts:t,...this.poolState},...e})}}const Zn=new r.Program({version:"0.1.1",name:"marcopolo",instructions:[{name:"createPool",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!0},{name:"poolYAccount",isMut:!0,isSigner:!0},{name:"adminXAccount",isMut:!0,isSigner:!1},{name:"adminYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"projectOwner",isMut:!1,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"lpFee",type:{defined:"FixedPoint"}},{name:"buybackFee",type:{defined:"FixedPoint"}},{name:"projectFee",type:{defined:"FixedPoint"}},{name:"mercantiFee",type:{defined:"FixedPoint"}},{name:"initialTokenX",type:{defined:"Token"}},{name:"initialTokenY",type:{defined:"Token"}},{name:"bump",type:"u8"}]},{name:"createProvider",accounts:[{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"tokenXAmount",type:{defined:"Token"}},{name:"tokenYAmount",type:{defined:"Token"}},{name:"bump",type:"u8"}]},{name:"createState",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"nonce",type:"u8"}]},{name:"addTokens",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"deltaX",type:{defined:"Token"}},{name:"deltaY",type:{defined:"Token"}}]},{name:"withdrawBuyback",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"buybackXAccount",isMut:!0,isSigner:!1},{name:"buybackYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"swap",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"swapperXAccount",isMut:!0,isSigner:!1},{name:"swapperYAccount",isMut:!0,isSigner:!1},{name:"swapper",isMut:!0,isSigner:!0},{name:"referrerXAccount",isMut:!0,isSigner:!1},{name:"referrerYAccount",isMut:!0,isSigner:!1},{name:"referrer",isMut:!0,isSigner:!1},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"deltaIn",type:{defined:"Token"}},{name:"priceLimit",type:{defined:"FixedPoint"}},{name:"xToY",type:"bool"}]},{name:"withdrawShares",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"shares",type:{defined:"Token"}}]},{name:"withdrawLpFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"ownerXAccount",isMut:!0,isSigner:!1},{name:"ownerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"withdrawProjectFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"projectOwnerXAccount",isMut:!0,isSigner:!1},{name:"projectOwnerYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"projectOwner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"createFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supply",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"createDualFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenProjectFirst",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"createTripleFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenProjectFirst",isMut:!1,isSigner:!1},{name:"tokenProjectSecond",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!0},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!0},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!0},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"supplyProjectSecond",type:{defined:"Token"}},{name:"duration",type:"u64"},{name:"bump",type:"u8"}]},{name:"withdrawRewards",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"provider",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!0,isSigner:!1},{name:"tokenProjectFirst",isMut:!0,isSigner:!1},{name:"tokenProjectSecond",isMut:!0,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"ownerMarcoAccount",isMut:!0,isSigner:!1},{name:"ownerProjectFirstAccount",isMut:!0,isSigner:!1},{name:"ownerProjectSecondAccount",isMut:!0,isSigner:!1},{name:"owner",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"closePool",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"buybackXAccount",isMut:!0,isSigner:!1},{name:"buybackYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"withdrawMercantiFee",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"mercantiXAccount",isMut:!0,isSigner:!1},{name:"mercantiYAccount",isMut:!0,isSigner:!1},{name:"poolXAccount",isMut:!0,isSigner:!1},{name:"poolYAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[]},{name:"addSupply",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"supplyMarco",type:{defined:"Token"}},{name:"supplyProjectFirst",type:{defined:"Token"}},{name:"supplyProjectSecond",type:{defined:"Token"}},{name:"duration",type:"u64"}]},{name:"updateFees",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1}],args:[{name:"newBuybackFee",type:{defined:"FixedPoint"}},{name:"newProjectFee",type:{defined:"FixedPoint"}},{name:"newProviderFee",type:{defined:"FixedPoint"}},{name:"newMercantiFee",type:{defined:"FixedPoint"}}]},{name:"resetFarm",accounts:[{name:"state",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"farm",isMut:!0,isSigner:!1},{name:"tokenX",isMut:!1,isSigner:!1},{name:"tokenY",isMut:!1,isSigner:!1},{name:"tokenMarco",isMut:!1,isSigner:!1},{name:"tokenMarcoAccount",isMut:!0,isSigner:!1},{name:"tokenProjectFirstAccount",isMut:!0,isSigner:!1},{name:"tokenProjectSecondAccount",isMut:!0,isSigner:!1},{name:"adminMarcoAccount",isMut:!0,isSigner:!1},{name:"adminProjectFirstAccount",isMut:!0,isSigner:!1},{name:"adminProjectSecondAccount",isMut:!0,isSigner:!1},{name:"admin",isMut:!0,isSigner:!0},{name:"programAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]}],accounts:[{name:"farm",type:{kind:"struct",fields:[{name:"pool",type:"publicKey"},{name:"tokens",type:{array:["publicKey",3]}},{name:"tokenAccounts",type:{array:["publicKey",3]}},{name:"supply",type:{array:[{defined:"Token"},3]}},{name:"supplyLeft",type:{array:[{defined:"Token"},3]}},{name:"accumulatedSecondsPerShare",type:{defined:"FixedPoint"}},{name:"offsetSecondsPerShare",type:{defined:"FixedPoint"}},{name:"startTime",type:"u64"},{name:"endTime",type:"u64"},{name:"lastUpdate",type:"u64"},{name:"bump",type:"u8"},{name:"farmType",type:{defined:"FarmType"}}]}},{name:"pool",type:{kind:"struct",fields:[{name:"tokenX",type:"publicKey"},{name:"tokenY",type:"publicKey"},{name:"poolXAccount",type:"publicKey"},{name:"poolYAccount",type:"publicKey"},{name:"admin",type:"publicKey"},{name:"projectOwner",type:"publicKey"},{name:"tokenXReserve",type:{defined:"Token"}},{name:"tokenYReserve",type:{defined:"Token"}},{name:"selfShares",type:{defined:"Token"}},{name:"allShares",type:{defined:"Token"}},{name:"buybackAmountX",type:{defined:"Token"}},{name:"buybackAmountY",type:{defined:"Token"}},{name:"projectAmountX",type:{defined:"Token"}},{name:"projectAmountY",type:{defined:"Token"}},{name:"mercantiAmountX",type:{defined:"Token"}},{name:"mercantiAmountY",type:{defined:"Token"}},{name:"lpAccumulatorX",type:{defined:"FixedPoint"}},{name:"lpAccumulatorY",type:{defined:"FixedPoint"}},{name:"constK",type:{defined:"Product"}},{name:"price",type:{defined:"FixedPoint"}},{name:"lpFee",type:{defined:"FixedPoint"}},{name:"buybackFee",type:{defined:"FixedPoint"}},{name:"projectFee",type:{defined:"FixedPoint"}},{name:"mercantiFee",type:{defined:"FixedPoint"}},{name:"farmCount",type:"u64"},{name:"bump",type:"u8"}]}},{name:"provider",type:{kind:"struct",fields:[{name:"tokenX",type:"publicKey"},{name:"tokenY",type:"publicKey"},{name:"owner",type:"publicKey"},{name:"shares",type:{defined:"Token"}},{name:"lastFeeAccumulatorX",type:{defined:"FixedPoint"}},{name:"lastFeeAccumulatorY",type:{defined:"FixedPoint"}},{name:"lastSecondsPerShare",type:{defined:"FixedPoint"}},{name:"lastWithdrawTime",type:"u64"},{name:"tokensOwedX",type:{defined:"Token"}},{name:"tokensOwedY",type:{defined:"Token"}},{name:"currentFarmCount",type:"u64"},{name:"bump",type:"u8"}]}},{name:"state",type:{kind:"struct",fields:[{name:"admin",type:"publicKey"},{name:"programAuthority",type:"publicKey"},{name:"bump",type:"u8"},{name:"nonce",type:"u8"}]}}],types:[{name:"FixedPoint",type:{kind:"struct",fields:[{name:"v",type:"u128"}]}},{name:"Token",type:{kind:"struct",fields:[{name:"v",type:"u64"}]}},{name:"Product",type:{kind:"struct",fields:[{name:"v",type:"u128"}]}},{name:"FarmType",type:{kind:"enum",variants:[{name:"Single"},{name:"Dual"},{name:"Triple"}]}}],errors:[{code:6e3,name:"DeltaTooBig",msg:"Delta greater than provider's tokens"},{code:6001,name:"TokenUnderflow",msg:"Token amount underflow"},{code:6002,name:"WrongRatio",msg:"Wrong tokens ratio"},{code:6003,name:"TooMuchShares",msg:"Too much shares provided"},{code:6004,name:"SwapToBig",msg:"Swap too big"},{code:6005,name:"FeeExceeded",msg:"Fee exceeded 100%"},{code:6007,name:"ScalesNotEqual",msg:"Scales have to be equal"},{code:6008,name:"FeeExceededDeltaOut",msg:"Fees exceeded delta_out"},{code:6009,name:"PriceLimitExceeded",msg:"Price limit exceeded"},{code:6010,name:"MintMismatch",msg:"Mint mismatch"},{code:6011,name:"TokensAreTheSame",msg:"Tokens are the same"},{code:6012,name:"WrongFarm",msg:"Cannot add supply to wrong farm"},{code:6013,name:"RewardsExceedingSupply",msg:"Cannot withdraw rewards exceeding supply left"},{code:6014,name:"FarmNotEnded",msg:"Farm has not ended, cannot add additional rewards"},{code:6015,name:"ZeroAmount",msg:"Must provide a nonzero amount"},{code:6016,name:"InvariantChanged",msg:"Invariant has changed"}],metadata:{address:"9tKE7Mbmj4mxDjWatikzGAtkoWosiiZX9y6J4Hfm2R8H"}},Ne,Xe),Hn=new q.default(10).pow(12);class Jn{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Marco Polo",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.pool=void 0,this.calculator=void 0,this.feePct=void 0,this.tokenReserveAmounts=void 0,this.address=e,this.id=e.toBase58(),this.pool=this.decodePoolState(t);const n=this.pool.lpFee.v.add(this.pool.buybackFee.v).add(this.pool.mercantiFee.v).add(this.pool.projectFee.v);this.feePct=new q.default(n.toString()).div(Hn),this.calculator=new i.TokenSwapConstantProduct(new i.Fraction(F.default.BigInt(n),F.default.BigInt(Hn)),i.ZERO_FRACTION,!1)}decodePoolState(e){return Zn.coder.accounts.decode("pool",e.data)}getAccountsForUpdate(){return[this.address]}update(e){const t=e.get(this.id);if(!t)throw new Error(`Pool account info is not found: ${this.id}`);const n=this.decodePoolState(t);this.pool=n,this.tokenReserveAmounts=[F.default.BigInt(n.tokenXReserve.v),F.default.BigInt(n.tokenYReserve.v)]}getQuote({destinationMint:e,amount:t}){const{tokenX:n}=this.pool;if(!this.tokenReserveAmounts)throw new Error("Missing tokenReserveAmounts");const i=e.equals(n)?0:1,o=this.calculator.exchange(this.tokenReserveAmounts,t,i);return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}getSwapLegAndAccounts(t){var n,i;return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:o,sourceMint:s}){const a=s.equals(t.tokenX),{swapperXAccount:r,swapperYAccount:u}=a?{swapperXAccount:n,swapperYAccount:i}:{swapperXAccount:i,swapperYAccount:n};return[pt(mt(a)),kt.instruction.marcoPoloSwap({accounts:{swapProgram:Ne,state:Ce,pool:t.pool,tokenX:t.tokenX,tokenY:t.tokenY,poolXAccount:t.poolXAccount,poolYAccount:t.poolYAccount,swapperXAccount:r,swapperYAccount:u,swapper:o,referrerXAccount:t.referrerXAccount,referrerYAccount:t.referrerYAccount,referrer:ee,programAuthority:Ve,systemProgram:e.SystemProgram.programId,tokenProgram:c.TOKEN_PROGRAM_ID,associatedTokenProgram:c.ASSOCIATED_TOKEN_PROGRAM_ID,rent:e.SYSVAR_RENT_PUBKEY}}).keys]}({additionalArgs:{pool:this.address,tokenX:this.pool.tokenX,tokenY:this.pool.tokenY,poolXAccount:this.pool.poolXAccount,poolYAccount:this.pool.poolYAccount,referrerXAccount:null===(n=t.quoteMintToReferrer)||void 0===n?void 0:n.get(this.pool.tokenX.toBase58()),referrerYAccount:null===(i=t.quoteMintToReferrer)||void 0===i?void 0:i.get(this.pool.tokenY.toBase58())},...t})}get reserveTokenMints(){return[this.pool.tokenX,this.pool.tokenY]}}Jn.getProgram=()=>Zn;const $n=({amms:e,asLegacyTransaction:t,isSplit:n})=>{if(t){if(e.length>2)return!1;const[t,i]=e;return n?!U(N,t.label,i.label):!U(C,t.label,i.label)}return!0},ei=new Map([[ke.toString(),"Orca"],[ye.toString(),"Orca"],[we.toString(),"Step"],[Pe.toString(),"Penguin"],[Te.toString(),"Saros"],[Me.toString(),"Stepn"]]);function ti(i,o,s){const a=new e.PublicKey(o.owner);if(a.equals(H)||a.equals(J)||a.equals(Ke)){const e=t.Market.getLayout(a).decode(o.data);if(!e.accountFlags.initialized||!e.accountFlags.market)throw new Error("Invalid market");const n=new t.Market(e,0,0,{},a);return new _n(n)}if(a.equals(te))return new In(i,o,s);if(a.equals(de))return new kn(i,o,s);if(a.equals(n.SWAP_PROGRAM_ID)){const e=o.data.slice(2,3),t=n.StableSwap.loadWithData(i,o.data,Ze([i.toBuffer(),e],n.SWAP_PROGRAM_ID));if(!t.state.isInitialized)return;return new Rn(t)}if(a.equals(oe))return new Dn(i,o);if(a.equals(ue))return new Xt(i,o,s);if(a.equals(ne)||a.equals(ie))return new _t(i,o,s);if([...ei.keys()].includes(a.toBase58())){var r;const e=null!==(r=ei.get(o.owner.toBase58()))&&void 0!==r?r:"Unknown";return new Vn(i,o,e)}return a.equals(se)?new Yt(i,o,s):a.equals(ae)?new Ln(i,o):a.equals(re)?new an(i,o):a.equals(xe)?new rn(i,o):a.equals(le)?new Gn(i,o):a.equals(Se)?new zt(i,o):a.equals(Ae)?new gn(i,o):a.equals(be)?new bn(i,o,s):a.equals(De)?new tn(i,o):a.equals(pe)?new sn(i,o):a.equals(Le)?new Qn(i,o,s):a.equals(Oe)?new Ut(i,o):a.equals(_e)?new zn(i,o):a.equals(Ne)?new Jn(i,o):void 0}class ni{constructor(e,t){this.connection=void 0,this.ammIdToAddressLookupTable=void 0,this.ammIdToAddressLookupTableAccount=new Map,this.connection=e,this.ammIdToAddressLookupTable=t}async getAdressLookupTableAccounts(t){const n=new Map,i=[...t.reduce(((e,t)=>{const i=this.ammIdToAddressLookupTableAccount.get(t);if(i){const e=i.key.toBase58();n.has(e)||n.set(e,t)}else{const i=this.ammIdToAddressLookupTable.get(t);i&&(e.add(i),n.set(t,i))}return e}),new Set)];return(await X(this.connection,i)).reduce(((t,o,s)=>{const a=i[s];if(o){const i=new e.AddressLookupTableAccount({key:new e.PublicKey(a),state:e.AddressLookupTableAccount.deserialize(o.data)});t.push(i);const s=n.get(a);s&&this.ammIdToAddressLookupTableAccount.set(s,i)}return t}),new Array)}}class ii{constructor(e){this.ammIdToAddressLookupTableAccount=void 0,this.ammIdToAddressLookupTableAccount=e}static async load(t,n){const i=[...n.entries()],o=await X(t,i.map((([e,t])=>t))),s=new Map;for(const[t,n]of o.entries()){const[o,a]=i[t];n&&s.set(o,new e.AddressLookupTableAccount({key:new e.PublicKey(a),state:e.AddressLookupTableAccount.deserialize(n.data)}))}return new ii(s)}getAdressLookupTableAccounts(e){const t=new Set,n=e.reduce(((e,n)=>{const i=this.ammIdToAddressLookupTableAccount.get(n);if(i){const n=i.key.toBase58();t.has(n)||(e.push(i),t.add(n))}return e}),new Array);return Promise.resolve(n)}}async function oi(e,t,n){const i=t.reduce(((e,t)=>{var n;const i=null==t||null===(n=t.params)||void 0===n?void 0:n.addressLookupTableAddress;return i&&e.set(t.pubkey,i),e}),new Map);return n?await ii.load(e,i):new ni(e,i)}const si={};function ai(e){const t=e._bn.toString(),n=si[t];if(n)return n;{const n=e.toBase58();return si[t]=n,n}}function ri(e){const t=new Map;return e.forEach((e=>{Un(e.reserveTokenMints).forEach((([n,i])=>{!function(e,t,n,i){let o=i.get(e);o||(o=new Map([[t,[]]]),i.set(e,o));let s=o.get(t);s||(s=[],o.set(t,s)),s.push(n)}(ai(n),ai(i),e,t)}))})),t}function ui(e,t,n){return Boolean(e&&t>100&&!e.has(n))}function ci(e,t){if(e===exports.SwapMode.ExactOut)return!1;if(t.length>1){const[e,n]=t;if(e instanceof In&&n instanceof In)return!1}return!0}async function mi({connection:t,marketInfos:n,owner:i,unwrapSOL:o}){const s=await Promise.all(n.map((({outputMint:n})=>async function({connection:t,payer:n,owner:{publicKey:i},mintAddress:o,unwrapSOL:s}){const r="string"==typeof o?new e.PublicKey(o):o,u=At({tokenMintAddress:r,walletAddress:i}),m={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},d=await t.getAccountInfo(u);if(null===d)m.setupInstructions.push(ft(n,u,i,r));else{const e=a.deserializeAccount(d.data);if(e&&!e.owner.equals(i))throw new Error(`/! ATA ${u.toBase58()} is not owned by ${i.toBase58()}`)}return r.equals(Z)&&s&&m.cleanupInstructions.push(c.Token.createCloseAccountInstruction(c.TOKEN_PROGRAM_ID,u,i,i,[])),{address:u,...m}}({connection:t,payer:i.publicKey,owner:i,mintAddress:n,unwrapSOL:o})))),[r]=s.splice(s.length-1,1);return{userIntermediaryTokenAccountResults:s,userDestinationTokenAccountResult:r}}async function di(t,n,i,o){const s={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]},a=i.address.toString();if(o){let e=o.get(a);if(e){let n=null;if(n=await t.getAccountInfo(e,"confirmed"),n)return{...s,address:e}}}const[r,c]=function(t,n){const[i]=u.findProgramAddressSync([Buffer.from("open_orders"),t.publicKey.toBuffer(),n.toBuffer()],Mt);return[i,kt.instruction.createOpenOrders({accounts:{openOrders:i,payer:n,dexProgram:t.programId,systemProgram:e.SystemProgram.programId,rent:e.SYSVAR_RENT_PUBKEY,market:t.publicKey}})]}(i,n);return await t.getAccountInfo(r)||(s.setupInstructions=[c]),null==o||o.set(i.address.toString(),r),{...s,address:r}}function li(e){return e.reduce(((e,t)=>t+e),0)}const pi={feeBps:0,feeAccounts:new Map};async function gi(e,t){return(await e.getTokenAccountsByOwner(t,{programId:c.TOKEN_PROGRAM_ID})).value.reduce(((e,t)=>{const n=a.deserializeAccount(t.account.data);return n&&e.set(n.mint.toBase58(),t.pubkey),e}),new Map)}const hi=e=>new Promise((t=>setTimeout(t,e)));function Si(e,t,n){if(!e)return;const i=t.get(n.toBase58());return void 0!==i?function(e,t){var n,i,o,s;const a=null===(n=t.postTokenBalances)||void 0===n||null===(i=n.find((t=>t.accountIndex===e)))||void 0===i?void 0:i.uiTokenAmount.amount,r=null===(o=t.preTokenBalances)||void 0===o||null===(s=o.find((t=>t.accountIndex===e)))||void 0===s?void 0:s.uiTokenAmount.amount;if(a)return Math.abs(parseInt(a)-(void 0!==r?parseInt(r):0))}(i,e):void 0}function fi(e,t,n){const i=t.get(n.toBase58());return void 0!==i?Math.abs(e.postBalances[i]-e.preBalances[i]):0}function Ai(){return(new Date).getTime()}const Mi={skipPreflight:!0,maxRetries:2};async function ki(e,t,n=12e4,i=500,o=2e3,s=40){const a=t.serialize(),r=await e.sendRawTransaction(a,Mi),u=Ai();let c=Ai(),m=0;for(;Ai()-u<n;){const t=Ai();m<s&&t-c>o&&(c=t,m+=1,await e.sendRawTransaction(a,Mi));const n=await Promise.any([e.getTransaction(r,{commitment:"confirmed",maxSupportedTransactionVersion:0}),hi(5e3)]);if(n)return{txid:r,transactionResponse:n};await hi(i)}return{txid:r,transactionResponse:null}}function yi(e){const t="signature"in e?e.signature:e.signatures[0];if(!t)throw new Error("Transaction has no signature");return R.bs58.encode(t)}function wi(e,t){return"message"in e?e.sign(t):e.sign(...t),yi(e)}class Pi{constructor(e,t,n){this.connection=void 0,this.feePayer=void 0,this.instructions=void 0,this.owner=void 0,this.connection=e,this.feePayer=t,this.instructions=[],this.owner=n}addInstruction(e){return this.instructions.push(e),this}async build(t,n,i){let o=[],s=[],a=[],r=[];this.instructions.forEach((e=>{s=s.concat(e.setupInstructions),o=o.concat(e.instructions),a=a.concat(e.cleanupInstructions),r=r.concat(e.signers)}));const u=s.concat(o).concat(a),c=i?this.buildLegacyTransaction({transactionInstructions:u,blockhashWithExpiryBlockHeight:t}):this.buildVersionedTransaction({transactionInstructions:u,blockhashWithExpiryBlockHeight:t,addressLookupTables:n});return{transaction:c,signers:r,execute:this.owner.isKeyPair?()=>{const n=wi(c,[this.owner.signer,...r]),i=c.serialize();return e.sendAndConfirmRawTransaction(this.connection,Buffer.from(i),{signature:n,...t})}:async()=>{throw new Error("Please use a Keypair for the owner parameter to enable the execute function")}}}buildLegacyTransaction({transactionInstructions:t,blockhashWithExpiryBlockHeight:n}){return new e.Transaction({feePayer:this.feePayer,...n}).add(...t)}buildVersionedTransaction({transactionInstructions:t,blockhashWithExpiryBlockHeight:n,addressLookupTables:i}){const o=new e.TransactionMessage({payerKey:this.feePayer,instructions:t,recentBlockhash:n.blockhash}).compileToV0Message(i);return new e.VersionedTransaction(o)}}class Ti{constructor(e){this._owner=void 0,this._owner=e}get publicKey(){return Ti.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return Ti.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return Ti.isKeyPair(this._owner)}get isPublicKey(){return Ti.isPublicKey(this._owner)}static isKeyPair(e){return void 0!==e.secretKey}static isPublicKey(e){return!Ti.isKeyPair(e)}}const bi=function(e){if(!Array.isArray(e))throw new TypeError(`Argument must be an array: ${e}`)},vi=function(e,t){return e*t.length},Ii={},Bi=function(e,t){return String(t)},Di=F.default.BigInt(1e4);function Ri({inputMint:e,outputMint:t}){return`${e}-${t}`}function Oi({ammId:e,amount:t}){return`${e}-${t.toString()}`}async function Li({inputRouteSegment:t,inputMint:n,outputMint:o,amount:s,getDepositAndFeeForRoute:a,platformFeeBps:r,slippageBps:u,filterTopNResult:c=1,onlyDirectRoutes:m,swapMode:d,asLegacyTransaction:l}){const p=n.toBase58(),g=o.toBase58();if(!t.get(p))throw new Error("No routes found for the input and output mints");const h=m?1:l?2:3,S=new Map,f=[],A=new Map;return function s({startMint:a,amount:r,level:u=1,walked:p=[a]}){const M=t.get(a);M&&M.forEach(((k,y)=>{const w=Ri({inputMint:a,outputMint:y}),P=function({amms:t,inputMint:n,outputMint:o,amount:s,swapMode:a}){return t.map((t=>{try{return{quote:t.getQuote({amount:s,sourceMint:new e.PublicKey(n),destinationMint:new e.PublicKey(o),swapMode:a}),amm:t}}catch(e){return}})).filter(Boolean).sort(((e,t)=>F.default.greaterThanOrEqual((null==t?void 0:t.quote.outAmount)||i.ZERO,(null==e?void 0:e.quote.outAmount)||i.ZERO)?1:-1))}({amms:k,inputMint:a,outputMint:y,amount:r,swapMode:d}),{filteredAmms:T,quoteMap:b}=P.reduce(((e,t)=>(e.filteredAmms.length<c&&e.filteredAmms.push(t.amm),e.quoteMap.set(Oi({ammId:t.amm.id,amount:r}),t.quote),e)),{filteredAmms:[],quoteMap:new Map});if(1!==u||y!==g||m||function(e,t){for(let n=0;n<e.length;n++)for(let i=n+1;i<e.length;i++)e[n].label!==e[i].label&&t(e[n],e[i])}(P.slice(0,Math.max(l?3:2,c)).map((({amm:e})=>e)),((e,t)=>{const i=(()=>{if($n({amms:[e,t],asLegacyTransaction:l,isSplit:!0}))return Xn.create(e,t)})();i&&f.push({amms:[i],mints:[n,o]})})),M.set(y,T),S.set(w,b),y!==g&&b.size&&!p.includes(y)&&u<h){var v;const e=b.values().next().value.outAmount,t=null!==(v=A.get(y))&&void 0!==v?v:i.ZERO;F.default.greaterThan(e,t)&&(A.set(y,e),s({startMint:y,amount:e,level:u+1,walked:p.concat(y)}))}else if(y===g){1===u&&M.set(y,k);const n=p.concat(y),i=n.map((t=>new e.PublicKey(t))),o=n.reduce(((e,i,o)=>{var s;return o<n.length-1&&e.push(null===(s=t.get(n[o]))||void 0===s?void 0:s.get(n[o+1])),e}),[]),s=function(e){if(function(e){if(!Array.isArray(e))throw new TypeError("Argument must be an array of arrays");e.forEach(bi),function({length:e}){if(e>=100)throw new TypeError(`Too many arrays (${e}): please use the 'big-cartesian' library instead of 'fast-cartesian'`)}(e),function(e){const t=e.reduce(vi,1);if(t>=4294967296){const e=Number.isFinite(t)?` (${t.toExponential(0)})`:"";throw new TypeError(`Too many combinations${e}: please use the 'big-cartesian' library instead of 'fast-cartesian'`)}}(e)}(e),0===e.length)return[];const t=[];return function(e){const t=Ii[e];if(void 0!==t)return t;const n=function(e){const t=Array.from({length:e},Bi),n=t.map((e=>`for (const value${e} of arrays[${e}]) {`)).join("\n"),i=t.map((e=>`value${e}`)).join(", "),o="}\n".repeat(e);return new Function("arrays","result",`${n}\nresult.push([${i}])\n${o}`)}(e);return Ii[e]=n,n}(e.length)(e,t),t}(o);for(let e of s)(1===e.length||$n({amms:e,asLegacyTransaction:l}))&&f.push({amms:e,mints:i})}}))}({startMint:p,amount:s}),f.map((e=>{const{amms:t,mints:n}=e;let o=[],c=s,m=i.ZERO;const l=ci(d,t),p=n,g=t.length;for(const[e,n]of t.entries())try{var h;const t=p[e],a=p[e+1],f=Ri({inputMint:t.toBase58(),outputMint:a.toBase58()}),A=null===(h=S.get(f))||void 0===h?void 0:h.get(Oi({ammId:n.id,amount:c}));if(F.default.equal(c,i.ZERO))return;const M=A||n.getQuote({sourceMint:t,destinationMint:a,amount:c,swapMode:d}),k=g-1===e&&l?{amount:F.default.divide(F.default.multiply(M.outAmount,F.default.BigInt(r)),Di),mint:a.toBase58(),pct:r/100}:{amount:i.ZERO,mint:a.toBase58(),pct:0},y=d===exports.SwapMode.ExactIn?M.outAmount:M.inAmount;let w=d===exports.SwapMode.ExactIn?F.default.subtract(y,k.amount):F.default.add(y,k.amount);F.default.lessThan(w,i.ZERO)&&(w=i.ZERO);const P=F.default.BigInt(d===exports.SwapMode.ExactIn?new q.default(w.toString()).mul(1-u/F.default.toNumber(Di)).ceil():new q.default(w.toString()).mul(1+u/F.default.toNumber(Di)).floor()),[T,b]=d===exports.SwapMode.ExactIn?[M.inAmount,w]:[w,c];o.push({amm:n,inputMint:t,outputMint:a,notEnoughLiquidity:M.notEnoughLiquidity,minInAmount:M.minInAmount,minOutAmount:M.minOutAmount,inAmount:T,outAmount:b,priceImpactPct:M.priceImpactPct,lpFee:{amount:M.feeAmount,mint:M.feeMint,pct:M.feePct},platformFee:k}),c=d===exports.SwapMode.ExactIn?w:s,m=P}catch(e){return}return{marketInfos:o,getDepositAndFee:()=>a({marketInfos:o}),inAmount:o[0].inAmount,outAmount:c,amount:s,otherAmountThreshold:m,swapMode:d,slippageBps:u,priceImpactPct:1-o.reduce(((e,t)=>e*(1-t.priceImpactPct)),1)}})).filter((e=>void 0!==e)).sort(((e,t)=>F.default.greaterThanOrEqual(t.outAmount,e.outAmount)?1:-1))}const Fi=Object.values(We).reduce(((e,t)=>(e[t.code]=t,e)),{});function Ei(e,t){let n=t.get(e);return void 0===n&&(n=t.size,t.set(e,n)),n}function xi(e){const t=t=>e.mintKeys[t],n=new Map;return Object.keys(e.indexedRouteMap).forEach((i=>{n.set(t(i),e.indexedRouteMap[i].map((e=>t(e))))})),n}async function qi({onlyDirectRoutes:e,restrictIntermediateTokens:t,asLegacyTransaction:n},i){let o=i||"https://cache.jup.ag/indexed-route-maps-v2";return e?o=o.concat("?onlyDirectRoutes=true"):t&&(o=o.concat("?restrictIntermediateTokens=true")),n&&(o=o.concat("?asLegacyTransaction=true")),xi(await(await fetch(o)).json())}class _i{constructor(e,t,n,i,o,s,a=0,r=!0,u,c,m){this.connection=void 0,this.cluster=void 0,this.tokenRouteSegments=void 0,this.feeCalculator=void 0,this.platformFeeAndAccounts=void 0,this.quoteMintToReferrer=void 0,this.routeCacheDuration=void 0,this.wrapUnwrapSOL=void 0,this.intermediateTokens=void 0,this.shouldLoadSerumOpenOrders=void 0,this.addressLookupTableProvider=void 0,this.serumOpenOrdersPromise=void 0,this.user=void 0,this.routeCache=new Map,this.routeSegmentCache=new Map,this.getDepositAndFees=async({marketInfos:e,userPublicKey:t,serumOpenOrdersPromise:n=Promise.resolve(new Map)})=>(async({connection:e,owner:t,inputMint:n,marketInfos:i,feeCalculator:o,serumOpenOrdersPromise:s,wrapUnwrapSOL:a})=>{const r=await Promise.all(i.map((async n=>{const i=n.amm;if(i instanceof _n||i instanceof Xn){if(!i.market)return;return await di(e,t.publicKey,i.market,await s)}}))),{userIntermediaryTokenAccountResults:u,userDestinationTokenAccountResult:c}=await mi({connection:e,marketInfos:i,owner:t,unwrapSOL:a});return(({intermediates:e,destination:t,openOrders:n,hasWrapUnwrapSOL:i,feeCalculator:o})=>{const s=n.filter((e=>e&&e.setupInstructions.length>0)).map((()=>23352760)),a=[...e,t].filter((e=>(null==e?void 0:e.setupInstructions.length)&&0===e.cleanupInstructions.length)).map((()=>2039280)),r=o.lamportsPerSignature;return{signatureFee:r,openOrdersDeposits:s,ataDeposits:a,totalFeeAndDeposits:li([r,...s,...a]),minimumSOLForTransaction:li([r,...s,...a,i?2039280:0])}})({intermediates:u,destination:c,openOrders:r,hasWrapUnwrapSOL:!!a&&[n,...i.map((e=>e.outputMint))].some((e=>e.equals(Z))),feeCalculator:o})})({connection:this.connection,feeCalculator:this.feeCalculator,inputMint:e[0].inputMint,marketInfos:e,serumOpenOrdersPromise:n,owner:new Ti(t),wrapUnwrapSOL:this.wrapUnwrapSOL}),this.getDepositAndFeesForUser=({marketInfos:e})=>{if(this.user&&this.serumOpenOrdersPromise){const t=new Ti(this.user);return this.getDepositAndFees({marketInfos:e,userPublicKey:t.publicKey,serumOpenOrdersPromise:this.serumOpenOrdersPromise})}return Promise.resolve(void 0)},this.exchange=async({routeInfo:e,userPublicKey:t,feeAccount:n,wrapUnwrapSOL:i,blockhashWithExpiryBlockHeight:o,asLegacyTransaction:s})=>{var a;const{connection:r,serumOpenOrdersPromise:u}=this,c=t||this.user;if(!c)throw new Error("user not found");const m=new Ti(c),d=e.marketInfos.length-1,p=e.marketInfos[0].inputMint,g=e.marketInfos[d].outputMint,h=null!=i?i:this.wrapUnwrapSOL,[S,f,A]=await Promise.all([p.equals(Z)&&h?St({connection:r,owner:m,amount:e.swapMode===exports.SwapMode.ExactIn?e.amount:e.otherAmountThreshold}):{setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[],address:At({tokenMintAddress:p,walletAddress:m.publicKey})},mi({connection:r,marketInfos:e.marketInfos,owner:m,unwrapSOL:h}),Promise.all(e.marketInfos.map((async({amm:e})=>{if(e instanceof _n||e instanceof Xn){if(!e.market)return;return await di(r,m.publicKey,e.market,await u)}})))]),M={intermediates:f.userIntermediaryTokenAccountResults,destination:f.userDestinationTokenAccountResult,openOrders:A},k=M.openOrders.filter(Boolean).length>0,y=(n=null!==(a=n)&&void 0!==a?a:e.swapMode===exports.SwapMode.ExactIn?this.platformFeeAndAccounts.feeAccounts.get(g.toBase58()):this.platformFeeAndAccounts.feeAccounts.get(p.toBase58()))?{feeBps:this.platformFeeAndAccounts.feeBps||Math.floor(100*e.marketInfos[d].platformFee.pct),feeAccount:n}:void 0,{instruction:w}=await async function({user:e,openOrdersAddresses:t,userSourceTokenAccountAddress:n,userIntermediateTokenAccountAddresses:i,userDestinationTokenAccountAddress:o,routeInfo:s,platformFee:a,quoteMintToReferrer:r}){if(s.marketInfos.length-1!==i.length)throw new Error("Missing intermediary token account address");const u=[n,...i,o],c=!!a&&a.feeBps>0&&ci(s.swapMode,s.marketInfos.map((e=>e.amm))),m=e.publicKey,d=[ht(14e5)],p=[];if(s.swapMode===exports.SwapMode.ExactIn){const e=function(e,t,n,i,o,s,a,r){const u=[],c=[];for(const[t,i]of e.marketInfos.entries()){const r=i.amm,[m,d]=o.slice(t),[l,p]=r.getSwapLegAndAccounts({sourceMint:i.inputMint,destinationMint:i.outputMint,userSourceTokenAccount:m,userDestinationTokenAccount:d,userTransferAuthority:n,openOrdersAddress:s[t],quoteMintToReferrer:a,swapMode:e.swapMode,amount:i.inAmount});u.push(l),c.push(...p)}return t&&r&&c.push({pubkey:r.feeAccount,isWritable:!0,isSigner:!1}),{swapInstruction:wt(n,i,dt(u),c,new l.BN(e.amount.toString()),new l.BN(e.outAmount.toString()),e.slippageBps,t&&r?r.feeBps:0)}}(s,c,m,o,u,t,r,a),{swapInstruction:n}=e;p.push(n)}else if(s.swapMode===exports.SwapMode.ExactOut){const{swapInstruction:e}=function(e,t,n,i,o,s){const a=e.marketInfos[0],r=a.amm;if(r.createExactOutSwapInstruction)return{swapInstruction:r.createExactOutSwapInstruction({sourceMint:a.inputMint,destinationMint:a.outputMint,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:t,quoteMintToReferrer:o,swapMode:e.swapMode,amount:e.amount,slippageBps:e.slippageBps,inAmount:e.inAmount,platformFee:s,overflowFeeAccount:null==o?void 0:o.get(a.inputMint.toBase58())})};throw new Error(`ExactOutInstruction missing for ${r.label}.`)}(s,m,n,o,r,a);p.push(e)}const{signers:g,cleanupInstructions:h}={setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]};return e.isKeyPair&&e.signer&&g.push(e.signer),{instruction:{setupInstructions:d,signers:g,cleanupInstructions:h,instructions:p}}}({user:m,openOrdersAddresses:M.openOrders.map((e=>null==e?void 0:e.address)),userSourceTokenAccountAddress:S.address,userIntermediateTokenAccountAddresses:M.intermediates.map((({address:e})=>e)),userDestinationTokenAccountAddress:M.destination.address,routeInfo:e,platformFee:y,quoteMintToReferrer:this.quoteMintToReferrer,asLegacyTransaction:s}),P=new Pi(r,m.publicKey,m),T=[...M.intermediates,S,!M.destination.address.equals(S.address)&&M.destination];P.addInstruction(w),k&&M.openOrders.forEach((e=>{e&&P.addInstruction(e)})),T.forEach((e=>{e&&P.addInstruction(e)})),o=o||await this.connection.getLatestBlockhash("confirmed");const b=await this.addressLookupTableProvider.getAdressLookupTableAccounts(e.marketInfos.map((e=>e.amm.id))),{transaction:v}=await P.build(o,b,s),I=M;return{swapTransaction:v,addressLookupTableAccounts:b,execute:({wallet:e,onTransaction:t}={})=>Ki({connection:this.connection,wallet:e,onTransaction:t,inputMint:p,outputMint:g,sourceAddress:S.address,destinationAddress:I.destination.address,swapTransaction:v,wrapUnwrapSOL:h,owner:m}).finally((()=>{this.routeCache.clear()}))}},this.connection=e,this.cluster=t,this.tokenRouteSegments=n,this.feeCalculator=i,this.platformFeeAndAccounts=o,this.quoteMintToReferrer=s,this.routeCacheDuration=a,this.wrapUnwrapSOL=r,this.intermediateTokens=u,this.shouldLoadSerumOpenOrders=c,this.addressLookupTableProvider=m}static async load({connection:t,cluster:n,user:i,platformFeeAndAccounts:o=pi,quoteMintToReferrer:s,routeCacheDuration:a=0,wrapUnwrapSOL:r=!0,marketUrl:u,restrictIntermediateTokens:c=!1,shouldLoadSerumOpenOrders:m=!0,ammsToExclude:d={GooseFX:!0,Serum:!0},usePreloadedAddressLookupTableCache:l=!1}){const[{tokenRouteSegments:p,addressLookupTableProvider:g,saberWrapperMints:h},{value:{feeCalculator:S}},f]=await Promise.all([_i.fetchAmms(t,n,d,u,l).then((({amms:e,saberWrapperMints:t,addressLookupTableProvider:n})=>({tokenRouteSegments:ri(e),addressLookupTableProvider:n,saberWrapperMints:t}))),t.getRecentBlockhashAndContext("processed"),null!=s?s:gi(t,new e.PublicKey(me))]),A=c?await _i.getIntermediateTokens(h):void 0,M=new _i(t,n,p,S,o,f,a,r,A?new Set(A):void 0,m,g);return i&&M.setUserPublicKey(i),M}getAccountToAmmIdsMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{t.getAccountsForUpdate().forEach((n=>{const i=e.get(n.toBase58())||new Set;i.add(t.id),e.set(n.toBase58(),i)}))}))}))})),e}getAmmIdToAmmMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{e.set(t.id,t)}))}))})),e}async computeRoutes({inputMint:e,outputMint:t,amount:n,slippageBps:i,feeBps:o=0,forceFetch:s,onlyDirectRoutes:a,swapMode:r=exports.SwapMode.ExactIn,filterTopNResult:u,asLegacyTransaction:c}){const m=e.toBase58(),d=t.toBase58(),l=o||(this.platformFeeAndAccounts.feeAccounts.get(d)?this.platformFeeAndAccounts.feeBps:0),p=(new Date).getTime(),g=[m,d].sort(((e,t)=>e.localeCompare(t))).join()+a+r+c,h=this.routeCache.get(g);let S=this.routeSegmentCache.get(g);S||(S=function({inputMint:e,outputMint:t,tokenRouteSegments:n,swapMode:i,intermediateTokens:o,onlyDirectRoutes:s,asLegacyTransaction:a}){const r=new Map,u=n.get(e),c=n.get(t);if(u&&c){const d=Math.min(u.size,c.size),l=new Map,p=new Map,[g,h,S,f]=[u,c,e,t];for(let[e,t]of g.entries()){if(t=i===exports.SwapMode.ExactIn?t.slice():t.filter((e=>e.exactOutputSupported)),e===f){const e=t;l.set(f,e),p.set(S,e);continue}if(s||i===exports.SwapMode.ExactOut||ui(o,d,e))continue;let u=n.get(e)||new Map;for(let[n,i]of u){if(i=i.slice(),n===f){const n=i;if(r.set(e,new Map([[S,t],[f,n]])),l.set(e,t),p.set(e,n),a)break}if(!a){var m;if(ui(o,d,n))continue;const s=null===(m=h.get(n))||void 0===m?void 0:m.slice();if(s){l.set(e,t);const o=r.get(e)||new Map;o.set(n,i),r.set(e,o);const a=r.get(n)||new Map;a.set(f,s),r.set(n,a)}}}}r.set(S,l),r.set(f,p)}return r}({inputMint:m,outputMint:d,tokenRouteSegments:this.tokenRouteSegments,intermediateTokens:this.intermediateTokens,onlyDirectRoutes:a,swapMode:r,asLegacyTransaction:c}),this.routeSegmentCache.set(g,S));let f=!1;if(-1===this.routeCacheDuration)f=!1;else if(0===this.routeCacheDuration)f=!0;else if(h){const{fetchTimestamp:e}=h;p-e>this.routeCacheDuration&&(f=!0)}else f=!0;(s||f)&&(await async function(e,t){const n=new Map,i=new Set,o=new Map;t.forEach((e=>{e.forEach((e=>{e.forEach((e=>{o.set(e.id,e),e.getAccountsForUpdate().forEach((e=>{i.add(e.toBase58())}))}))}))}));const s=Array.from(i);s.length>0&&((await X(e,s)).forEach(((e,t)=>{e&&n.set(s[t],e)})),o.forEach((e=>{e.update(n)})))}(this.connection,S),this.routeCache.set(g,{fetchTimestamp:(new Date).getTime()}));try{return{routesInfos:await Li({inputRouteSegment:S,inputMint:e,outputMint:t,amount:n,getDepositAndFeeForRoute:this.getDepositAndFeesForUser,onlyDirectRoutes:a,slippageBps:i,platformFeeBps:l,filterTopNResult:u,swapMode:r,asLegacyTransaction:c}),cached:!(s||f)}}catch(e){throw e}finally{this.routeCache.forEach((({fetchTimestamp:e},t)=>{e-p>this.routeCacheDuration&&this.routeCache.delete(t)}))}}setUserPublicKey(e){this.user=e;const t=new Ti(this.user);this.serumOpenOrdersPromise=this.shouldLoadSerumOpenOrders?_i.findSerumOpenOrdersForOwner({connection:this.connection,cluster:this.cluster,userPublicKey:t.publicKey}):Promise.resolve(new Map)}static async fetchAmms(t,n,i,o,s=!1){return async function(t,n,i={},o){const s=(t=>t.map((t=>{const{data:[n,i],pubkey:o,...s}=t;return{...s,pubkey:new e.PublicKey(o),data:Buffer.from(n,i),owner:new e.PublicKey(s.owner)}})))(n);{const e=[];if(e.length){const n=await async function(e,t){const n=await Promise.all((await X(e,t.map((e=>e.toBase58())))).map((async(e,n)=>{const i=t[n];if(!e)throw new Error(`Failed to fetch pool ${i.toBase58()}`);return{pubkey:i,...e}})));return n}(t,e);s.push(...n)}}const a=[],r=[],u=s.reduce(((e,t)=>{const n=ti(t.pubkey,t,t.params);if(n){if(U(i,n.label))return e;e.push(n),n.shouldPrefetch&&a.push(n),n instanceof Dn&&r.push(n.wrapperMint.toBase58())}return e}),new Array),[c,m,d]=await Promise.all([Q(a,t),k.loadWasm(),await oi(t,n,o)]);return{amms:u,saberWrapperMints:r,addressLookupTableProvider:d}}(t,await(async e=>await(await _.default(e)).json())(o||$[n]),i,s)}getRouteMap(e,t){return function(e,t,n,i){const o=new Map,s=new Set(e.keys());s.forEach((e=>{o.set(e,new Set)}));for(const[S,f]of e){const A=new Set(s);for(let e of f.keys()){var a,r;null===(a=o.get(S))||void 0===a||a.add(e),null===(r=o.get(e))||void 0===r||r.add(S),A.delete(e)}if(!n)for(let s of A){var u;let a=null===(u=o.get(S))||void 0===u?void 0:u.has(s);if(a)continue;const r=e.get(S),f=e.get(s);if(r&&f){const u=Math.min(r.size,f.size);let[A,M,k,y]=[r,f,S,s];for(let[r,f]of A.entries()){if(n||ui(t,u,r))continue;let A=e.get(r)||new Map;for(let[e,n]of A){if(e===y){if(!i){var c,m;null===(c=o.get(S))||void 0===c||c.add(s),null===(m=o.get(s))||void 0===m||m.add(S),a=!0;break}for(let e of f){for(let t of n)if($n({amms:[e,t],asLegacyTransaction:i})){var d,l;null===(d=o.get(S))||void 0===d||d.add(s),null===(l=o.get(s))||void 0===l||l.add(S),a=!0;break}if(a)break}}if(!i){var p;if(ui(t,u,e))continue;if(null===(p=M.get(e))||void 0===p?void 0:p.slice()){var g,h;null===(g=o.get(S))||void 0===g||g.add(s),null===(h=o.get(s))||void 0===h||h.add(S),a=!0;break}}}if(a)break}}}}return Array.from(o.entries()).reduce(((e,[t,n])=>(e.set(t,[...n]),e)),new Map)}(this.tokenRouteSegments,this.intermediateTokens,e,t)}static async getIntermediateTokens(e){const t=await async function(){const e=await(await _.default("https://cache.jup.ag/top-tokens")).json();return new Set(e.filter(((e,t)=>t<60)))}();for(const e of Ue)t.add(e);return e.forEach((e=>t.add(e))),Array.from(t)}}_i.getRemoteRouteMap=qi,_i.findSerumOpenOrdersForOwner=async({userPublicKey:e,cluster:n,connection:i})=>{const o=new Map;if(e){const s="mainnet-beta"===n?H:J;(await t.OpenOrders.findForOwner(i,e,s)).forEach((e=>{o.set(e.market.toString(),e.address)}))}return o};const Ki=async({connection:e,wallet:t,onTransaction:n,inputMint:i,outputMint:o,sourceAddress:s,destinationAddress:r,swapTransaction:u,owner:c,wrapUnwrapSOL:m})=>{let d,l;try{if(c.signer)wi(u,[c.signer]);else{if(!t)throw new Error("Signer wallet not found");u=await t.signTransaction(u)}const p=yi(u);try{const t=async()=>await async function({txid:e,transactionResponse:t}){var n;if(!t)return new a.TransactionError("Transaction was not confirmed",e);if(null!=t&&null!==(n=t.meta)&&void 0!==n&&n.err){let{message:n,programId:o,code:s}=a.parseErrorForTransaction(t);var i;return o===Mt.toBase58()&&s&&(n=null===(i=Fi[s])||void 0===i?void 0:i.msg),n||(n=a.UNKNOWN_ERROR),new a.TransactionError(n||"Something went wrong",e,s)}return t}(await ki(e,u)),d=t();null==n||n(p,1,"SWAP",d);const g=await d;if(g instanceof Error)throw g;const[h,S]=await async function({txid:e,inputMint:t,outputMint:n,user:i,sourceAddress:o,destinationAddress:s,transactionResponse:r,hasWrappedSOL:u}){let c,m;if(r){let{meta:e,transaction:a}=r;if(e){const r=a.message.getAccountKeys({accountKeysFromLookups:e.loadedAddresses}).keySegments().flat().reduce(((e,t,n)=>(e.set(t.toBase58(),n),e)),new Map);c=t.equals(Z)&&!u?fi(e,r,i):Si(e,r,o),m=n.equals(Z)&&!u?fi(e,r,i):Si(e,r,s)}}if(!c||!m)throw new a.TransactionError("Cannot find source or destination token account balance change",e,We.BalancesNotExtractedProperly.code);return[c,m]}({txid:p,inputMint:i,outputMint:o,user:c.publicKey,sourceAddress:s,destinationAddress:r,transactionResponse:g,hasWrappedSOL:!m});l={txid:p,inputAddress:s,outputAddress:r,inputAmount:h,outputAmount:S}}catch(e){d=e}if(d||!l)throw d||new Error("Swap failed");return l}catch(e){return{error:e}}};Object.defineProperty(exports,"TransactionError",{enumerable:!0,get:function(){return a.TransactionError}}),exports.ALDRIN_SWAP_PROGRAM_ID=ne,exports.ALDRIN_SWAP_V2_PROGRAM_ID=ie,exports.AldrinAmm=_t,exports.BALANSOL_PROGRAM_ID=Oe,exports.BalansolAmm=Ut,exports.CREMA_PARTNER_ACCOUNT=ce,exports.CREMA_PROGRAM_ID=ue,exports.CROPPER_PROGRAM_ID=se,exports.CYKURA_FACTORY_STATE_ADDRESS=fe,exports.CYKURA_PROGRAM_ID=Se,exports.CremaAmm=Xt,exports.CropperAmm=Yt,exports.CykuraAmm=zt,exports.DELTA_FI_PROGRAM_ID=Ie,exports.DELTA_FI_USER_ID=Be,exports.DEVNET_SERUM_DEX_PROGRAM=J,exports.DRADEX_DEX_USER=qe,exports.DRADEX_LOGGER_PROGRAM_ID=Fe,exports.DRADEX_MASTER_ID=Ee,exports.DRADEX_PROGRAM_ID=Le,exports.DeltaFiAmm=class{constructor(t,n){this.address=void 0,this.id=void 0,this.label="DeltaFi",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.hasDynamicAccounts=!1,this.swapInfo=void 0,this.feePct=void 0,this.prices=void 0,this.pythAddresses=void 0,this.address=t,this.id=t.toBase58(),this.swapInfo=Ht.coder.accounts.decode("SwapInfo",n.data);const{swapConfig:i}=this.swapInfo;this.feePct=i.tradeFeeNumerator/i.tradeFeeDenominator,this.pythAddresses=[this.swapInfo.pythPriceBase,this.swapInfo.pythPriceQuote].filter((t=>!e.SystemProgram.programId.equals(t)))}getAccountsForUpdate(){return[this.address,...this.pythAddresses]}getPriceData(e,t){const{id:n}=this,i=e.get(t.toBase58())||Zt[n];if(!i)throw new Error(`Missing pyth account info for ${t.toBase58()}`);return"data"in i?A.parsePriceData(i.data):i}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing ${this.address.toBase58()}`);this.swapInfo=Ht.coder.accounts.decode("SwapInfo",t.data);try{const t=this.getPriceData(e,this.swapInfo.pythPriceBase),n=this.getPriceData(e,this.swapInfo.pythPriceQuote);if(t.price&&n.price){const e=new M.BigNumber(t.price).dividedBy(new M.BigNumber(n.price)),i=new M.BigNumber(t.price+t.confidence).dividedBy(new M.BigNumber(n.price-n.confidence)),o=new M.BigNumber(t.price-t.confidence).dividedBy(new M.BigNumber(n.price+n.confidence));this.prices={marketPrice:e,highPrice:i,lowPrice:o}}else this.prices=void 0}catch(e){this.prices=void 0}}getQuote({destinationMint:e,amount:t}){if(!this.prices)throw new Error("Missing price data from pyth");const{swapInfo:n}=this,{amountIn:i,amountOut:o,priceImpact:s}=f.getSwappedAmountsAndPriceImpactFromRawValue(n,e.equals(n.mintQuote)?{sellBase:{}}:{sellQuote:{}},new M.BigNumber(t.toString()),this.prices.marketPrice,this.prices.highPrice,this.prices.lowPrice),a=o.multipliedBy(n.swapConfig.tradeFeeNumerator.toString()).dividedBy(n.swapConfig.tradeFeeDenominator.toString()).decimalPlaces(0),r=o.minus(a);return{notEnoughLiquidity:!1,inAmount:F.default.BigInt(i),outAmount:F.default.BigInt(r),feeAmount:F.default.BigInt(a),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:Number(s)}}getSwapLegAndAccounts(e){var t;if(!this.prices)throw new Error("Missing price data from pyth");const{swapSourceToken:n,swapDestinationToken:i,adminDestinationToken:o}=this.swapInfo.mintBase.equals(e.sourceMint)?{swapSourceToken:this.swapInfo.tokenBase,swapDestinationToken:this.swapInfo.tokenQuote,adminDestinationToken:this.swapInfo.adminFeeTokenQuote}:{swapSourceToken:this.swapInfo.tokenQuote,swapDestinationToken:this.swapInfo.tokenBase,adminDestinationToken:this.swapInfo.adminFeeTokenBase};return function({additionalArgs:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:i}){return[pt((o=e.stable,{deltaFi:{stable:o}})),kt.instruction.deltafiSwap({accounts:{swapProgram:Ie,marketConfig:e.marketConfig,swapInfo:e.swapInfo,userSourceToken:t,userDestinationToken:n,swapSourceToken:e.swapSourceToken,swapDestinationToken:e.swapDestinationToken,deltafiUser:Be,adminDestinationToken:e.adminDestinationToken,pythPriceBase:e.pythPriceBase,pythPriceQuote:e.pythPriceQuote,userAuthority:i,tokenProgram:c.TOKEN_PROGRAM_ID},remainingAccounts:e.referrer?[{pubkey:e.referrer,isSigner:!1,isWritable:!0}]:[yt]}).keys];var o}({additionalArgs:{stable:!!this.swapInfo.swapType.stableSwap,marketConfig:this.swapInfo.configKey,swapInfo:this.address,swapSourceToken:n,swapDestinationToken:i,adminDestinationToken:o,pythPriceBase:this.swapInfo.pythPriceBase,pythPriceQuote:this.swapInfo.pythPriceQuote,referrer:null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(e.destinationMint.toBase58())},...e})}get reserveTokenMints(){return[this.swapInfo.mintQuote,this.swapInfo.mintBase]}},exports.DradexAmm=Qn,exports.FAKE_PROVIDER=Xe,exports.GOOSE_FX_CONTROLLER_ID=Re,exports.GOOSE_FX_PROGRAM_ID=De,exports.GooseFXAmm=tn,exports.INDEXED_ROUTE_MAP_URL="https://cache.jup.ag/indexed-route-maps-v2",exports.INVARIANT_PROGRAM_AUTHORITY_ID=he,exports.INVARIANT_PROGRAM_ID=pe,exports.INVARIANT_STATE_ID=ge,exports.IS_DEV=!0,exports.IS_PROD=!1,exports.IS_TEST=!1,exports.InvariantAmm=sn,exports.JUPITER_ERRORS=We,exports.JUPITER_FEE_OWNER=ee,exports.JUPITER_WALLET=me,exports.Jupiter=_i,exports.LAMPORTS_PER_SIGNATURE=5e3,exports.LIFINITY_PROGRAM_ID=re,exports.LIFINITY_V2_PROGRAM_ID=xe,exports.LifinityAmm=an,exports.LifinityV2Amm=rn,exports.MAINNET_SERUM_DEX_PROGRAM=H,exports.MARCO_POLO_PROGRAM_AUTHORITY=Ve,exports.MARCO_POLO_PROGRAM_ID=Ne,exports.MARCO_POLO_STATE_ID=Ce,exports.MARINADE_PROGRAM_ID=Ae,exports.MARKETS_URL=$,exports.MERCURIAL_SWAP_PROGRAM_ID=de,exports.METEORA_PROGRAM_ID=be,exports.METEORA_VAULT_PROGRAM_ID=ve,exports.MIN_SEGMENT_SIZE_FOR_INTERMEDIATE_MINTS=100,exports.MarcoPoloAmm=Jn,exports.MarinadeAmm=gn,exports.MercurialAmm=kn,exports.MeteoraAmm=bn,exports.OPENBOOK_PROGRAM_ID=Ke,exports.ORCA_V1_PROGRAM_ID=ke,exports.ORCA_V2_PROGRAM_ID=ye,exports.Owner=Ti,exports.PENGUIN_PROGRAM_ID=Pe,exports.RAYDIUM_AMM_V4_PROGRAM_ID=te,exports.RAYDIUM_CLMM_PROGRAM_ID=_e,exports.RaydiumAmm=In,exports.RaydiumClmm=zn,exports.SABER_ADD_DECIMALS_PROGRAM_ID=oe,exports.SAROS_PROGRAM_ID=Te,exports.SENCHA_PROGRAM_ID=ae,exports.STEPN_PROGRAM_ID=Me,exports.STEP_TOKEN_SWAP_PROGRAM_ID=we,exports.SWAP_PROTOCOL_TOKENS=Ue,exports.SaberAddDecimalsAmm=Dn,exports.SaberAmm=Rn,exports.SenchaAmm=Ln,exports.SerumAmm=_n,exports.SplTokenSwapAmm=Vn,exports.SplitTradeAmm=Xn,exports.TOKEN_LIST_URL={devnet:"https://api.jup.ag/api/tokens/devnet",testnet:"https://api.jup.ag/api/markets/devnet","mainnet-beta":"https://cache.jup.ag/tokens"},exports.TransactionBuilder=Pi,exports.WHIRLPOOL_PROGRAM_ID=le,exports.WRAPPED_SOL_MINT=Z,exports.WhirlpoolAmm=Gn,exports.ammFactory=ti,exports.executeTransactions=Ki,exports.getComputeUnitLimitInstruction=ht,exports.getEmptyInstruction=()=>({setupInstructions:[],instructions:[],cleanupInstructions:[],signers:[]}),exports.getPlatformFeeAccounts=gi,exports.getRemoteRouteMap=qi,exports.getRouteInfoUniqueId=function(e){return e.marketInfos.map((e=>`${e.amm.id}-${e.inputMint}`)).join("-")},exports.indexedRouteMapToRouteMap=xi,exports.routeMapToIndexedRouteMap=function(e){const{mintToIndexMap:t,indexedRouteMap:n}=Array.from(e).reduce((({mintToIndexMap:e,indexedRouteMap:t},[n,i])=>{const o=Ei(n,e),s=[];for(const t of i){const n=Ei(t,e);s.push(n)}return t[o]=s,{mintToIndexMap:e,indexedRouteMap:t}}),{mintToIndexMap:new Map,indexedRouteMap:{}});return{mintKeys:[...t.keys()],indexedRouteMap:n}},exports.transactionSenderAndConfirmationWaiter=ki;
//# sourceMappingURL=core.cjs.development.min.js.map
